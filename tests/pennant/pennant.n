///////////////////////////////////////////////////////////////////////////////
// NABLA - a Numerical Analysis Based LAnguage                               //
//                                                                           //
// Copyright (C) 2014~2017 CEA/DAM/DIF                                       //
// IDDN.FR.001.520002.000.S.P.2014.000.10500                                 //
//                                                                           //
// Contributor(s): CAMIER Jean-Sylvain - Jean-Sylvain.Camier@cea.fr          //
//                                                                           //
// This software is a computer program whose purpose is to translate         //
// numerical-analysis specific sources and to generate optimized code        //
// for different targets and architectures.                                  //
//                                                                           //
// This software is governed by the CeCILL license under French law and      //
// abiding by the rules of distribution of free software. You can  use,      //
// modify and/or redistribute the software under the terms of the CeCILL     //
// license as circulated by CEA, CNRS and INRIA at the following URL:        //
// "http://www.cecill.info".                                                 //
//                                                                           //
// The CeCILL is a free software license, explicitly compatible with         //
// the GNU GPL.                                                              //
//                                                                           //
// As a counterpart to the access to the source code and rights to copy,     //
// modify and redistribute granted by the license, users are provided only   //
// with a limited warranty and the software's author, the holder of the      //
// economic rights, and the successive licensors have only limited liability.//
//                                                                           //
// In this respect, the user's attention is drawn to the risks associated    //
// with loading, using, modifying and/or developing or reproducing the       //
// software by the user in light of its specific status of free software,    //
// that may mean that it is complicated to manipulate, and that also         //
// therefore means that it is reserved for developers and experienced        //
// professionals having in-depth computer knowledge. Users are therefore     //
// encouraged to load and test the software's suitability as regards their   //
// requirements in conditions enabling the security of their systems and/or  //
// data to be ensured and, more generally, to use and operate it in the      //
// same conditions as regards security.                                      //
//                                                                           //
// The fact that you are presently reading this means that you have had      //
// knowledge of the CeCILL license and that you accept its terms.            //
//                                                                           //
// See the LICENSE file for details.                                         //
///////////////////////////////////////////////////////////////////////////////

// This NABLA port is an implementation of the PENNANT Mini-App.

// Charles R. Ferenbaugh, Los Alamos National Laboratory, cferenba@lanl.gov

// PENNANT is an unstructured mesh physics mini-app designed for
// advanced architecture research. It contains mesh data structures
// and a few physics algorithms adapted from the LANL rad-hydro code FLAG,
// and gives a sample of the typical memory access patterns of FLAG.

// Copyright 2012, Los Alamos National Security, LLC. All rights reserved.

// This software was produced under U.S. Government contract DE-AC52-06NA25396
// for Los Alamos National Laboratory (LANL), which is operated by Los Alamos
// National Security, LLC for the U.S. Department of Energy.

// The U.S. Government has rights to use, reproduce, and distribute this software.

// NEITHER THE GOVERNMENT NOR LOS ALAMOS NATIONAL SECURITY, LLC MAKES ANY WARRANTY,
// EXPRESS OR IMPLIED, OR ASSUMES ANY LIABILITY FOR THE USE OF THIS SOFTWARE.

// If software is modified to produce derivative works, such modified software should
// be clearly marked, so as not to confuse it with the version available from LANL.

// Additionally, redistribution and use in source and binary forms,
// with or without modification, are permitted provided that the following conditions are met:
//   1. Redistributions of source code must retain the above copyright notice,
//      this list of conditions and the following disclaimer.
//   2. Redistributions in binary form must reproduce the above copyright notice,
//      this list of conditions and the following disclaimer in the documentation
//      and/or other materials provided with the distribution.
//   3. Neither the name of Los Alamos National Security, LLC, Los Alamos National Laboratory,
//      LANL, the U.S. Government, nor the names of its contributors may be used to endorse
//      or promote products derived from this software without specific prior written permission.

// THIS SOFTWARE IS PROVIDED BY LOS ALAMOS NATIONAL SECURITY,
// LLC AND CONTRIBUTORS ‚ÄúAS IS‚Äù AND ANY EXPRESS OR IMPLIED WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL LOS ALAMOS NATIONAL SECURITY, LLC OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
// OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
///////////////////////////////////////////////////////////////////////////////
with ‚Ñù¬≤;

///////////////////////////////////////////////////////////////////////////////
// /tmp/nabla/nabla/nabla --lambda pennant -i pennant.n
///////////////////////////////////////////////////////////////////////////////
options{
  // Mesh options
  ‚Ñù LENGTH                    = 1.125;
  ‚Ñï X_EDGE_ELEMS              = 3;
  ‚Ñï Y_EDGE_ELEMS              = 3;
  ‚Ñï Z_EDGE_ELEMS              = 1;
  ‚Ñï option_max_iterations = 0;// ! utilis√© en dur dans le backend lambda !
  ‚Ñù option_Œ¥t_initial = 1e-7; // ! utilis√© en dur dans le backend lambda !
  ‚Ñù option_stoptime = 1.;     // ! utilis√© en dur dans le backend lambda !


  // Pennant options
  ‚Ñæ option_debug = true;
  ‚Ñï cstop=999999; // simulation stop cycle
  ‚Ñù tstop=1.e99;  // simulation stop time
  ‚Ñù dtmax=1.e99;  // maximum timestep size
  ‚Ñù dtinit=1.e99; // initial timestep size
  ‚Ñù dtfac=1.2;    // factor limiting timestep growth
  ‚Ñï dtreport=10;  // frequency for timestep reports
  ‚Ñù cfl=0.6;      // Courant number, limits timestep
  ‚Ñù cflv=0.1;     // volume change limit for timestep
  ‚Ñù rinit=1.0;    // initial density for main mesh
  ‚Ñù einit=0.0;    // initial energy for main mesh
  ‚Ñæ subregion=true;
  ‚Ñù subrgn_xmin=0.0;
  ‚Ñù subrgn_xmax=0.025;
  ‚Ñù subrgn_ymin=0.0;
  ‚Ñù subrgn_ymax=0.025;
  ‚Ñù rinitsub=1.0; // initial density in subregion
  ‚Ñù einitsub=0.0; // initial energy in subregion
  ‚Ñù uinitradial=0.0; // initial velocity in radial direction
  //std::vector<‚Ñù> bcx; // x values of x-plane fixed boundaries
  //std::vector<‚Ñù> bcy; // y values of y-plane fixed boundaries
  ‚Ñù option_gamma=5./3.; // coeff. for ideal gas equation
  ‚Ñù ssmin=0;      // minimum sound speed for gas
  ‚Ñù alfa=0.5;     // alpha coefficient for TTS model
  ‚Ñù qgamma=5./3.; // gamma coefficient for Q model
  ‚Ñù q1=0.0;       // linear coefficients for Q model
  ‚Ñù q2=2.0;       // quadratic coefficients for Q model
};

#define dbg(...) if (option_debug) printf("%s%s%s","\n[35m",__VA_ARGS__,"[m")
#define dbc(clr,...) if (option_debug) printf("\n[%dm%s%s",clr,__VA_ARGS__,"[m")
#define red 31
#define green 32
#define yellow 33
#define blue 34
#define magenta 35
#define cyan 36
#define white 37

// ****************************************************************************
// * Zone Variables
// ****************************************************************************
cells{
  ‚Ñù¬≤ zx;    // zone center coordinates
  ‚Ñù¬≤ zxp;   // zone ctr coords, middle of cycle
  ‚Ñù zarea;  // zone area
  ‚Ñù zvol;   // zone volume
  ‚Ñù zareap; // zone area, middle of cycle
  ‚Ñù zvolp;  // zone volume, middle of cycle
  ‚Ñù zvol0;  // zone volume, start of cycle
  ‚Ñù zdl;    // zone characteristic length
  ‚Ñù zm;     // zone mass
  ‚Ñù zr;     // zone density
  ‚Ñù zrp;    // zone density, middle of cycle
  ‚Ñù ze;     // zone specific internal energy (energy per unit mass)
  ‚Ñù zetot;  // zone total internal energy
  ‚Ñù zw;     // zone work done in cycle
  ‚Ñù zwrate; // zone work rate
  ‚Ñù zp;     // zone pressure
  ‚Ñù zss;    // zone sound speed
  ‚Ñù zdu;    // zone velocity difference
  ‚Ñù z0per;  // zone tmp variable in PolyGas calcStateAtHalf
  ‚Ñù¬≤ z0uc;  // zone tmp centered velocity
  ‚Ñù zr0;    // zone tmp
  ‚Ñù z0tmp;  // zone tmp
  ‚Ñù sarea[faces];  // side area
  ‚Ñù svol[faces];   // side volume
  ‚Ñù sareap[faces]; // side area, middle of cycle
  ‚Ñù svolp[faces];  // side volume, middle of cycle
  ‚Ñù¬≤ ssurfp[faces];// side surface vector
  ‚Ñù smf[faces];    // side mass fraction
  ‚Ñù¬≤ sfp[faces];   // side force from pressure
  ‚Ñù¬≤ sfq[faces];   // side force from artificial visc.
  ‚Ñù¬≤ sft[faces];   // side force from tts
  ‚Ñù¬≤ cftot[nodes]; // corner force, total from all sources
  ‚Ñù cmaswt[nodes]; // corner contribution to pmaswt
  ‚Ñù c0area[nodes]; // corner tmp
  ‚Ñù c0evol[nodes]; // corner tmp
  ‚Ñù c0du[nodes];   // corner tmp
  ‚Ñù c0div[nodes];  // corner tmp
  ‚Ñù c0cos[nodes];  // corner tmp
  ‚Ñù¬≤ c0qe[nodes];  // corner tmp
  ‚Ñù c0w;           // corner tmp
  ‚Ñù c0rmu;         // corner tmp
};


// ****************************************************************************
// * Point Variables
// ****************************************************************************
nodes{
  ‚Ñù¬≤ px0;   // point coords, start of cycle
  ‚Ñù¬≤ px;    // point coordinates
  ‚Ñù¬≤ pxp;   // point coords, middle of cycle
  ‚Ñù¬≤ pu;    // point velocity
  ‚Ñù¬≤ pu0;   // point velocity, start of cycle
  ‚Ñù¬≤ pap;   // point acceleration
  ‚Ñù¬≤ pf;    // point force
  ‚Ñù pmaswt; // point mass, weighted by 1/r
};


// ****************************************************************************
// * Edge Variables
// ****************************************************************************
faces{
  ‚Ñù¬≤ ex;    // edge center coordinates
  ‚Ñù¬≤ exp;   // edge ctr coords, middle of cycle
  ‚Ñù elen;   // edge length
};


// ****************************************************************************
// * Global Variables
// ****************************************************************************
global{
  //‚Ñù time; // simulation time
  ‚Ñï cycle;  // simulation cycle number
  ‚Ñù dt;     // current timestep
  ‚Ñù dtlast; // previous timestep
  ‚Ñù dtrec;  // maximum timestep for hydro
  ‚Ñù¬≤ vfix;// vector perp. to fixed plane
  ‚Ñù dvovmax;
};



// ****************************************************************************
// * Partie d'initialisation ]-‚àû,-0.0[
// ****************************************************************************
‚àÄ nodes @ -32.0{
  px=coord;
  cout<<"\n[37m[Mesh::init] coord["<<n<<"]="<<coord<<"[m";
}

‚àÄ cells meshCalcCtrs_zx @ -31.9 {
  zx=0;
  ‚àÄ node zx+=px;
  zx /= nbNode;
  cout<<"\n[37m[Mesh::calcCtrs] zx["<<c<<"]="<<zx<<"[m";
}

‚àÄ faces meshCalcCtrs_ex @ -31.9 {
  ex = 0.0;
  ‚àÄ node ex += px; 
  ex /= nbNode;
  assert(nbNode==2);
  cout<<"\n[37m[Mesh::calcCtrs] ex["<<uid<<"]="<<ex<<"[m";
}


‚àÄ cells iniMeshCalcVolsCross2D @ -31.8 {
  //const ‚Ñù¬≥ X[4] = {px[0],px[1],px[2],px[3]};
  const ‚Ñù¬≥ edge0 = px[1]-px[0];
  const ‚Ñù¬≥ edge1 = px[2]-px[1];
  const ‚Ñù¬≥ edge2 = px[3]-px[2];
  const ‚Ñù¬≥ edge3 = px[0]-px[3];
  const ‚Ñù sa0 = ¬Ω * cross2D(edge0, zx-px[0]);
  const ‚Ñù sa1 = ¬Ω * cross2D(edge1, zx-px[1]);
  const ‚Ñù sa2 = ¬Ω * cross2D(edge2, zx-px[2]);
  const ‚Ñù sa3 = ¬Ω * cross2D(edge3, zx-px[3]);
  ‚àÄ face sarea=sa[#];
}
 
/*
‚àÄ cells iniMeshCalcVols @ -31.8 {
  zvol=0.0;
  zarea=0.0; 
  const double third = ‚Öì;
  ‚àÄ face {
    const ‚Ñù sa = ¬Ω * cross2D(px[1] - px[0], zx - px[0]);
    const ‚Ñù sv = third * sa * (px[0].x + px[1].x + zx.x);
    sarea = sa;
    svol = sv;
    zarea += sa;
    zvol += sv;
  }
  }*/


//Mesh::calcVols


optTest @ -30.0 {
  dbc(magenta,"optTest");
  if (cstop == 999999 && tstop == 1.e99) {
    cerr << endl << "Must specify either cstop or tstop" << endl;
    exit;
  }
}

iniGlobals @ -20.0 {
  dbc(magenta,"iniGlobals");
  time = 0.0;
  cycle = 0;
}

// initializeHydroVars: Hydro::init
‚àÄ cells iniZr @ -14.9 { zr=rinit; }
‚àÄ cells iniZe @ -14.9 { ze=einit; }
‚àÄ cells iniZwrate @ -14.9 { zwrate=0.0; }
‚àÄ cells @ -14.8 if (subregion) {
  const double eps = 1.e-12;
  if (!(zx.x > (subrgn_xmin - eps) && zx.x < (subrgn_xmax + eps) &&
        zx.y > (subrgn_ymin - eps) && zx.y < (subrgn_ymax + eps))) continue;
  zr = rinitsub;
  ze = einitsub;
}
‚àÄ cells iniZm @ -14.7 {
  zm = zr * zvol;
  cout<<"\n[37m[Hydro::init] zm["<<c<<"]="<<zm<<"[m";
}
‚àÄ cells iniZetot @ -14.6 { zetot = ze * zm;}


‚àÄ nodes iniPuRadial @ -14.5 if (uinitradial!=0.0) {
  const ‚Ñù eps = 1.e-12;
  const ‚Ñù pmag = length(px);
  if (pmag > eps)
    pu = uinitradial * px / pmag;
  else pu = 0.0;
}
‚àÄ nodes iniPuStd @ -14.5 if (uinitradial==0.0) { pu=0.0; }

resetDtHydro2 @ -14.4 { dtrec = 1.e99; }
// End of Hydro::init


// ****************************************************************************
// * Partie boucle de calcul ]+0.0,+‚àû[ 
// ****************************************************************************
incCycle @ 1.0 { cycle += 1; }

calcGlobalDt @ 2.0 {
  // Save timestep from last cycle
  dtlast = dt;
  // Compute timestep for this cycle
  dt = dtmax;
  if (cycle == 1) {    // compare to initial timestep
    if (dtinit < dt) dt = dtinit;
  } else {
    const double dtrecover = dtfac * dtlast;
    if (dtrecover < dt) dt = dtrecover;
  }
  // compare to time-to-end
  if ((tstop - time) < dt) dt = tstop - time;
  // compare to hydro dt
  if (dtrec < dt) dt = dtrec;
}

// Hydro::doCycle
// Begin hydro cycle

‚àÄ nodes saveOffPxFromPreviousCycle @ 3.0 { px0=px; }
‚àÄ nodes saveOffPuFromPreviousCycle @ 3.0 { pu0=pu; }

// ===== Predictor step =====
// 1. advance mesh to center of time step
‚àÄ nodes advPosHalf0 @ 3.1 { pxp = px0 + pu0 * ¬Ω * dt; }

// save off zone variable values from previous cycle
‚àÄ cells saveOffZvolFromPreviousCycle @ 3.2 { zvol0=zvol; }

// 1a. compute new mesh geometry
‚àÄ cells computeZxp @ 3.3 {
  zxp=0.0;
  ‚àÄ node zxp+=pxp;
  zxp /= nbNode;
}

‚àÄ faces computeExp @ 3.3 {
  exp = 0.0;
  ‚àÄ node exp += pxp;
  exp /= nbNode;
  assert(nbNode==2);
}

‚àÄ cells calcVols @ 3.4 {
  zvolp=0.0;
  zareap=0.0; 
  const double third = ‚Öì;
  //int count = 0;
#warning cells face supported
  const int n=0;
  ‚àÄ face {
    const ‚Ñù sap = ¬Ω * cross2D(pxp/*[1]*/ - pxp/*[0]*/, zxp    - pxp);
    const ‚Ñù svp = third * sap * (pxp/*[0]*/.x + pxp/*[1]*/.x + zxp.x);
    sareap = sap;
    svolp = svp;
    zarea += sap;
    zvol += svp;
    // check for negative side volumes
    //if (svp <= 0.) exit;
  } 
  //if (count > 0) numsbad += count;
}

‚àÄ cells calcSurfVecs @ 3.5 { ‚àÄ face { const int n=f; ssurfp = rotateCCW(exp - zxp);} }

‚àÄ faces calcEdgeLen @ 3.5 { elen = length(pxp[1] - pxp[0]); }

‚àÄ cells calcCharLen @ 3.5 {
  zdl = 1.e99;
  const int n=0;
  ‚àÄ face {
    const ‚Ñù area = sareap;
    ‚Ñù base = elen;
    ‚Ñù fac = 4.0;//(znump == 3 ? 3.0 : 4.0);
    ‚Ñù sdl = fac * area / base;
    zdl = min(zdl, sdl);
  }
}

// 2. compute point masses
‚àÄ cells calcRhoIni @ 4.0 { zrp = zm / zvolp; }
‚àÄ cells calcRhoCompute @ 4.1 {
  const int n=0;
  ‚àÄ face {
    const ‚Ñù m = zrp * zareap * 0.5 * (smf + smf/*[+1]*/);
    cmaswt = m;
  }
}

// 3. compute material state (half-advanced)
// calcStateAtHalf
‚àÄ cells computeEosAtBeginningOfTimeStep @ 5.0 {
  const ‚Ñù gm1 = option_gamma - 1.;
  const ‚Ñù ss2 = max(ssmin * ssmin, 1.e-99);
  ‚Ñù rx = zr;
  ‚Ñù local_ex = max(ze, 0.0);
  ‚Ñù local_px = gm1 * rx * local_ex;
  ‚Ñù prex = gm1 * local_ex;
  ‚Ñù perx = gm1 * rx;
  ‚Ñù csqd = max(ss2, prex + perx * local_px / (rx * rx));
  zp =local_px;
  z0per = perx;
  zss = ‚àö(csqd);
  }

‚àÄ cells advancePressureToTheHalfStep @ 5.0 {
  const ‚Ñù dth = ¬Ω * dt;
  ‚Ñù zminv = 1. / zm;
  ‚Ñù dv = (zvolp - zvol0) * zminv;
  ‚Ñù bulk = zr0 * zss * zss;
  ‚Ñù denom = 1. + 0.5 * z0per * dv;
  ‚Ñù src = zwrate * dth * zminv;
  zp += (z0per * src - zr0 * bulk * dv) / denom;
}

// 4. compute forces
‚àÄ cells pgasCalcForce @ 6.0 {
  const int n=0;
  ‚àÄ face {
    //const ‚Ñù¬≤ sfx = -zp * ssurfp;
    sfp=-zp * ssurfp;;
  }
}
‚àÄ cells ttsCalcForce @ 6.1 {
  const int n=0;
  ‚àÄ face {
    ‚Ñù svfacinv = zareap / sareap;
    ‚Ñù srho = zrp * smf * svfacinv;
    ‚Ñù sstmp = max(zss, ssmin);
    sstmp = alfa * sstmp * sstmp;
    ‚Ñù sdp = sstmp * (srho - zrp);
    //‚Ñù¬≤ sqq = -sdp * ssurfp;
    sft = -sdp * ssurfp;
  }
}

‚àÄ cells qcsCalcForce_zoneCenteredVelocity @ 6.2 {
  z0uc=0;
  ‚àÄ node z0uc += pu;
  z0uc /= nbNode;  
}

‚àÄ cells qcsCalcForce_divergenceAtTheCorner @ 6.3 {
  ‚àÄ node {
    // Velocities and positions
    // 0 = point p
/*
    ‚Ñù¬≥ up0 = pu;
    ‚Ñù¬≥ xp0 = px;
    // 1 = edge e2
    ‚Ñù¬≤ up1 = 0.5 * (pu + pu);
    ‚Ñù¬≤ xp1 = ex;
    // 2 = zone center z
    ‚Ñù¬≤ up2 = z0uc;
    ‚Ñù¬≤ xp2 = zx;
    // 3 = edge e1
    up3 = ¬Ω * (pu + pu);
    xp3 = ex;
    // compute 2d cartesian volume of corner
    ‚Ñù cvolume = 0.5 * cross(xp2 - xp0, xp3 - xp1);
    c0area[c0] = cvolume;
    // compute cosine angle
    ‚Ñù¬≤ v1 = xp3 - xp0;
    ‚Ñù¬≤ v2 = xp1 - xp0;
    ‚Ñù de1 = elen;
    ‚Ñù de2 = elen;
    ‚Ñù minelen = min(de1, de2);
    c0cos = ((minelen < 1.e-12) ?
                 0. :
                 4. * dot2D(v1, v2) / (de1 * de2));
    // compute divergence of corner
    c0div = (cross(up2 - up0, xp3 - xp1) -
                 cross(up3 - up1, xp2 - xp0)) /
      (2.0 * cvolume);
    // compute evolution factor
    ‚Ñù¬≤ dxx1 = 0.5 * (xp1 + xp2 - xp0 - xp3);
    ‚Ñù¬≤ dxx2 = 0.5 * (xp2 + xp3 - xp0 - xp1);
    ‚Ñù dx1 = length(dxx1);
    ‚Ñù dx2 = length(dxx2);
    // average corner-centered velocity
    ‚Ñù¬≤ duav = 0.25 * (up0 + up1 + up2 + up3);
    ‚Ñù test1 = abs(dot2D(dxx1, duav) * dx2);
    ‚Ñù test2 = abs(dot2D(dxx2, duav) * dx1);
    ‚Ñù num = (test1 > test2 ? dx1 : dx2);
    ‚Ñù den = (test1 > test2 ? dx2 : dx1);
    ‚Ñù r = num / den;
    ‚Ñù evol = sqrt(4.0 * cvolume * r);
    evol = min(evol, 2.0 * minelen);
    // compute delta velocity
    ‚Ñù dv1 = length2(up1 + up2 - up0 - up3);
    ‚Ñù dv2 = length2(up2 + up3 - up0 - up1);
    ‚Ñù du = sqrt(max(dv1, dv2));
    c0evol = (c0div < 0.0 ? evol : 0.);
    c0du   = (c0div < 0.0 ? du   : 0.);
*/
  }
}

‚àÄ cells qcsCalcForce_setQCnForce @ 6.4 {
  const ‚Ñù gammap1 = qgamma + 1.0;
  // [4.1] Compute the c0rmu (real Kurapatenko viscous scalar)
  ‚àÄ node {
    // Kurapatenko form of the viscosity
    ‚Ñù ztmp2 = q2 * 0.25 * gammap1 * c0du;
    ‚Ñù ztmp1 = q1 * zss;
    ‚Ñù zkur = ztmp2 + sqrt(ztmp2 * ztmp2 + ztmp1 * ztmp1);
    // Compute c0rmu for each corner
    ‚Ñù rmu = zkur * zrp * c0evol;
    c0rmu = ((c0div > 0.0) ? 0. : rmu);
  }  
  // [4.2] Compute the c0qe for each corner
/*  ‚àÄ node {
    // Compute: c0qe(1,2,3)=edge 1, y component (2nd), 3rd corner
    //          c0qe(2,1,3)=edge 2, x component (1st)
    c0qe[2 * c0]     = c0rmu[c0] * (pu[p] - pu[p1]) / elen[e1];
    c0qe[2 * c0 + 1] = c0rmu[c0] * (pu[p2] - pu[p]) / elen[e2];
  }
*/
}

// [5] Compute the Q forces
// Routine number [5]  in the full algorithm CS2DQforce(...)
// [5.1] Preparation of extra variables
‚àÄ cells qcsCalcForce_setForce_preparationOfExtraVariables @ 6.5 {
  ‚àÄ node {
    ‚Ñù csin2 = 1.0 - c0cos * c0cos;
    c0w   = ((csin2 < 1.e-4) ? 0. : c0area / csin2);
    c0cos = ((csin2 < 1.e-4) ? 0. : c0cos);
  }
}
‚àÄ cells qcsCalcForce_setForce_setUpTheForcesOnCorners @ 6.6 {
  //const int n=0;
  ‚àÄ face {
    // Edge length for c1, c2 contribution to s
    //‚Ñù el = elen;
//    sfq = (c0w[c10] * (c0qe[2*c10+1] + c0cos[c10] * c0qe[2*c10]) +
//           c0w[c20] * (c0qe[2*c20] + c0cos[c20] * c0qe[2*c20+1])) / el;
  }
}
// Routine number [6] in the full algorithm
‚àÄ cells qcsCalcForce_setVelDiff @ 6.7 {
  z0tmp=0;
  ‚àÄ node {
    ‚Ñù¬≥ dx = px - px;
    ‚Ñù¬≥ du = pu - pu;
    //‚Ñù lenx = elen;
    ‚Ñù dux = dot2D(du, dx);
    //dux = (lenx > 0. ? abs(dux) / lenx : 0.);
    z0tmp = max(z0tmp, dux);
  }
  zdu = q1 * zss + 2. * q2 * z0tmp;
}

‚àÄ cells sumCrnrForce @ 7.0 {
  const int n=0;
  ‚àÄ face {
    const ‚Ñù¬≥ f = (sfp + sfq + sft) - (sfp/*[-1]*/ + sfq/*[-1]*/ + sft/*[-1]*/);
    cftot = f;
  }
}


‚àÄ nodes sumCornerMassesToPoints @ 8.0{
  pmaswt=0;
  //‚àÄ cell pmaswt+=cmaswt;
}
‚àÄ nodes sumCornerForcesToPoints @ 8.1{
  pmaswt=0;
  ‚àÄ cell pf+=cftot;
}

// 4a. apply boundary conditions
//‚àÄ bcs applyFixedBC(pu0, pf, bfirst, blast);
‚àÄ nodes applyFixedBC @ 9.0 {
  pu = project(pu, vfix);
  pf = project(pf, vfix);
}

‚àÄ nodes calcAccel @ 10.0 { //(pf, pmaswt, pap, pfirst, plast);
  const double fuzz = 1.e-99;
  pap = pf / max(pmaswt, fuzz);
}
// ===== Corrector step =====
// 6. advance mesh to end of time step
‚àÄ nodes advPosFull @ 11.0 { //(px0, pu0, pap, dt, px, pu, pfirst, plast);
  pu = pu0 + pap * dt;
  px = px0 + 0.5 * (pu + pu0) * dt;
}

resetDtHydro @ 12.0 { dtrec = 1.e99; }

// 6a. compute new mesh geometry
‚àÄ cells computeNewMeshGeometry @ 13.0 { // px, ex, zx, sfirst, slast);
  zx=0.0;
  ‚àÄ node zx+=px;
  zx /= nbNode;
}
‚àÄ faces computeExpBis @ 13.1 {
  ex = 0.0;
  ‚àÄ node ex += px;
  ex /= nbNode;
  assert(nbNode==2);
}
‚àÄ cells calcVolsBis @ 13.2 { // (px, zx, sarea, svol, zarea, zvol6
  zvolp=0.0;
  zareap=0.0;
  const ‚Ñù third = ‚Öì;
  const ‚Ñï n=0;
  ‚àÄ face {
    const int n=f;
    const ‚Ñù sa = ¬Ω * cross2D(px - px, zx - px);
    const ‚Ñù sv = third * sa * (pxp.x + px.x + zx.x);
    sarea = sa;
    svol = sv;
    zarea += sa;
    zvol += sv;
    //if (svp <= 0.) exit;
  }
}

// 7. compute work
‚àÄ cells computeWork @ 14.0 {
  zw=0; 
/*  const ‚Ñù dth = 0.5 * dt;
  ‚Ñù¬≥ sftot = sf + sf2;
  ‚Ñù sd1 = dot2D( sftot, (pu0 + pu));
  ‚Ñù sd2 = dot2D(-sftot, (pu0 + pu));
  ‚Ñù dwork = -dth * (sd1 * px.x + sd2 * px.x);
  zetot += dwork;
  zw += dwork;
*/
}

// 7a. compute work rate
‚àÄ cells calcWorkRate @ 15.0 { //(zvol0, zvol, zw, zp, dt, zwrate, zfirst, zlast);
  ‚Ñù dtinv = 1. / dt;
  ‚Ñù dvol = zvol - zvol0;
  zwrate = (zw + zp * dvol) * dtinv;
}

// 8. update state variables
‚àÄ cells calcEnergy @ 16.0 { //(zetot, zm, ze, zfirst, zlast);
  const ‚Ñù fuzz = 1.e-99;
  ze = zetot / (zm + fuzz);
}

‚àÄ cells calcRho @ 17.0 { //(zm, zvol, zr, zfirst, zlast);
  zr = zm / zvol;
}

// 9.  compute timestep for next cycle
‚àÄ cells calcDtHydro @ 18.0 { //(zdl, zvol, zvol0, dt, zfirst, zlast);
  //‚Ñù dtchunk = 1.e99;
}
‚àÄ cells calcDtHydro_Courant @ 19.0 {
  const ‚Ñù fuzz = 1.e-99;
  ‚Ñù dtnew = 1.e99;
  ‚Ñù cdu = max(zdu, max(zss, fuzz));
  ‚Ñù zdthyd = zdl * cfl / cdu;
  //int zmin = -1;
  //zmin = (zdthyd < dtnew ? z : zmin);
  dtnew = (zdthyd < dtnew ? zdthyd : dtnew);
  if (dtnew < dtrec) dtrec = dtnew;
  // reduce
}
‚àÄ cells calcDtHydro_Volume @ 20.0 {
  dvovmax = 1.e-99;
  ‚Ñù zdvov = fabs((zvol - zvol0) / zvol0);
  //zmax = (zdvov > dvovmax ? z : zmax);
  dvovmax = (zdvov > dvovmax ? zdvov : dvovmax);
}
calcDtHydro_Volume_test @ 20.1 {
  ‚Ñù dtnew = dtlast * cflv / dvovmax;
  if (dtnew < dtrec) dtrec = dtnew;
}

// End of Hydro::doCycle

incTime @ 30.0 { time += dt; }

tstExit @ 40.0 {
  if (cycle < cstop && time < tstop) return;
  exit;
}
