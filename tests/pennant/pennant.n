///////////////////////////////////////////////////////////////////////////////
// This NABLA port is an implementation of the PENNANT Mini-App              //
// from Charles R. Ferenbaugh (cferenba@lanl.gov), LANL                      //
// ‚àá contributor(s): CAMIER Jean-Sylvain - Jean-Sylvain.Camier@cea.fr        //
///////////////////////////////////////////////////////////////////////////////
// PENNANT is an unstructured mesh physics mini-app designed for advanced    //
// architecture research. It contains mesh data structures and a few physics //
// algorithms adapted from the LANL rad-hydro code FLAG, and gives a sample  //
// of the typical memory access patterns of FLAG.                            //
///////////////////////////////////////////////////////////////////////////////
// Copyright 2012, Los Alamos National Security, LLC. All rights reserved.   //
// This software was produced under US Government contract DE-AC52-06NA25396 //
// for Los Alamos National Laboratory, which is operated by Los Alamos       //
// National Security, LLC for the U.S. Department of Energy.                 //
// The US Government has rights to use, reproduce and distribute this        //
// software.                                                                 //
// NEITHER THE GOVERNMENT NOR LOS ALAMOS NATIONAL SECURITY, LLC MAKES ANY    //
// WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY LIABILITY FOR THE USE OF     //
// THIS SOFTWARE.                                                            //
// If this software is modified to produce derivative works, such modified   //
// software should be clearly marked, so as not to confuse it with the       //
// version available from LANL.                                              //
// Additionally, redistribution and use in source and binary forms, with or  //
// without modification, are permitted provided that the following           //
// conditions are met:                                                       //
//  1. Redistributions of source code must retain the above copyright notice,//
//     this list of conditions and the following disclaimer.                 //
//  2. Redistributions in binary form must reproduce the above copyright     //
//     notice, this list of conditions and the following disclaimer in the   //
//     documentation and/or other materials provided with the distribution.  //
//  3. Neither the name of Los Alamos National Security, LLC, Los Alamos     //
//     National Laboratory, LANL, the U.S. Government, nor the names of its  //
//     contributors may be used to endorse or promote products derived from  //
//     this software without specific prior written permission.              //
///////////////////////////////////////////////////////////////////////////////
// THIS SOFTWARE IS PROVIDED BY LOS ALAMOS NATIONAL SECURITY, LLC AND        //
// CONTRIBUTORS ‚ÄúAS IS‚Äù AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,    //
// BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS //
// FOR A PARTICULAR PURPOSE ARE DISCLAIMED.                                  //
// IN NO EVENT SHALL LOS ALAMOS NATIONAL SECURITY, LLC OR CONTRIBUTORS BE    //
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR       //
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF      //
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  //
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN   //
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)   //
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF    //
// THE POSSIBILITY OF SUCH DAMAGE.                                           //
///////////////////////////////////////////////////////////////////////////////
with ‚Ñù¬≤;

// ****************************************************************************
// Default options should match test/sedovsmall/sedovsmall.pnt
// cstop=100, tstop=1.0, meshtype=rect, meshparams=3 3 1.125 1.125
// subregion=0.0 0.3 0.0 0.3, rinitsub=1.0, einitsub=40.222, bcx=0.0 1.125
// bcy=0.0 1.125, ssmin=0.1, q1=0.1, q2=1.0, dtinit=0.0025
// ****************************************************************************
options{
  // Mesh options
  ‚Ñù LENGTH       = 1.125;
  ‚Ñï X_EDGE_ELEMS = 3;
  ‚Ñï Y_EDGE_ELEMS = 3;
  ‚Ñï Z_EDGE_ELEMS = 1;
  ‚Ñï option_max_iterations = 0;// ! utilis√© en dur dans le backend lambda !
  ‚Ñù option_Œ¥t_initial = 1e-7; // ! utilis√© en dur dans le backend lambda !
  ‚Ñù option_stoptime = 1.0;    // ! utilis√© en dur dans le backend lambda !
  // Pennant options
  ‚Ñæ trace       = false;
  ‚Ñï cstop       = 100;    // simulation stop cycle
  ‚Ñù tstop       = 1.0;    // simulation stop time
  ‚Ñù dtmax       = 1.e99;  // maximum timestep size
  ‚Ñù dtinit      = 0.0025; // initial timestep size
  ‚Ñù dtfac       = 1.2;    // factor limiting timestep growth
  ‚Ñï dtreport    = 10;     // frequency for timestep reports
  ‚Ñù cfl         = 0.6;    // Courant number, limits timestep
  ‚Ñù cflv        = 0.1;    // volume change limit for timestep
  ‚Ñù rinit       = 1.0;    // initial density for main mesh
  ‚Ñù einit       = 0.0;    // initial energy for main mesh
  ‚Ñæ subregion   = true;
  ‚Ñù subrgn_xmin = 0.0;
  ‚Ñù subrgn_xmax = 0.3;
  ‚Ñù subrgn_ymin = 0.0;
  ‚Ñù subrgn_ymax = 0.3;
  ‚Ñù rinitsub    = 1.0;    // initial density in subregion
  ‚Ñù einitsub    = 40.222; // initial energy in subregion
  ‚Ñù uinitradial = 0.0;    // initial velocity in radial direction
  ‚Ñù ggamma      = 5./3.;  // coeff. for ideal gas equation
  ‚Ñù ssmin       = 0.1;    // minimum sound speed for gas
  ‚Ñù alpha       = 0.5;    // alpha coefficient for TTS model
  ‚Ñù qgamma      = 5./3.;  // gamma coefficient for Q model
  ‚Ñù q1          = 0.1;    // linear coefficients for Q model
  ‚Ñù q2          = 1.0;    // quadratic coefficients for Q model
  ‚Ñæ chaos       = false;
  ‚Ñù chaos_seed  = 1.1234567890123;
};


// ****************************************************************************
// * Trace & Debug
// ****************************************************************************
enum{red=31,green,yellow,blue,magenta,cyan,white};
#define dbg(...) if (trace) printf("%s%s%s","\n[35m",__VA_ARGS__,"[m")
#define dbc(clr,...) if (trace) cout<<"["<<clr<<"m"<<__VA_ARGS__<<"[m"<<endl;


// ****************************************************************************
// * Zone/Sides/Corners Variables
// ****************************************************************************
cells{
  ‚Ñù¬≤ zx;    // zone center coordinates
  ‚Ñù¬≤ zxp;   // zone ctr coords, middle of cycle
  ‚Ñù zarea;  // zone area
  ‚Ñù zvol;   // zone volume
  ‚Ñù zareap; // zone area, middle of cycle
  ‚Ñù zvolp;  // zone volume, middle of cycle
  ‚Ñù zvol0;  // zone volume, start of cycle
  ‚Ñù zdl;    // zone characteristic length
  ‚Ñù zm;     // zone mass
  ‚Ñù zr;     // zone density
  ‚Ñù zrp;    // zone density, middle of cycle
  ‚Ñù ze;     // zone specific internal energy (energy per unit mass)
  ‚Ñù zetot;  // zone total internal energy
  ‚Ñù zw;     // zone work done in cycle
  ‚Ñù zwrate; // zone work rate
  ‚Ñù zp;     // zone pressure
  ‚Ñù zss;    // zone sound speed
  ‚Ñù zdu;    // zone velocity difference
  ‚Ñù z0per;  // zone tmp variable in PolyGas calcStateAtHalf
  ‚Ñù¬≤ z0uc;  // zone tmp centered velocity
  // Sides
  ‚Ñù sarea[faces];  // area
  ‚Ñù svol[faces];   // volume
  ‚Ñù sareap[faces]; // area, middle of cycle
  ‚Ñù svolp[faces];  // volume, middle of cycle
  ‚Ñù¬≤ ssurfp[faces];// surface vector
  ‚Ñù smf[faces];    // mass fraction
  ‚Ñù¬≤ sfp[faces];   // force from pressure
  ‚Ñù¬≤ sfq[faces];   // force from artificial visc.
  ‚Ñù¬≤ sft[faces];   // force from tts
  // Corners
  ‚Ñù¬≤ cftot[nodes]; // force, total from all sources
  ‚Ñù cmaswt[nodes]; // contribution to pmaswt
  ‚Ñù c0area[nodes]; // tmp
  ‚Ñù c0evol[nodes]; // tmp
  ‚Ñù c0du[nodes];   // tmp
  ‚Ñù c0div[nodes];  // tmp
  ‚Ñù c0cos[nodes];  // tmp
  ‚Ñù¬≤ c0qe0[nodes]; // tmp
  ‚Ñù¬≤ c0qe1[nodes]; // tmp
  ‚Ñù c0w[nodes];    // tmp
  ‚Ñù c0rmu[nodes];  // tmp
};


// ****************************************************************************
// * Point Variables
// ****************************************************************************
nodes{
  ‚Ñù¬≤ px,px0,pxp; // point coordinates, start & middle of cycle
  ‚Ñù¬≤ pu,pu0;     // point velocity
  ‚Ñù¬≤ pap,pf;     // point acceleration, force
  ‚Ñù pmaswt;      // point mass, weighted by 1/r
};


// ****************************************************************************
// * Edge Variables
// ****************************************************************************
faces{
  ‚Ñù¬≤ ex,exp; // edge center coordinates & middle of cycle
  ‚Ñù elen;    // edge length
};


// ****************************************************************************
// * Global Variables
// ****************************************************************************
global{
  ‚Ñï cycle;  // simulation cycle number
  ‚Ñù dt;     // current timestep
  ‚Ñù dtrec;  // maximum timestep for hydro
  ‚Ñù dvovmax;//
};


// ****************************************************************************
// * Partie d'initialisation ]-‚àû,-0.0[
// ****************************************************************************
iniCout @ -48.0 {cout<<"\n[m";}

‚àÄ nodes iniMeshCoords @ -32.0{
  px = coord;
  px *= (chaos)?chaos_seed:1.0;
  dbc(yellow,"[iniMeshCoords] px["<<n<<"]="<<px);
}

‚àÄ cells iniMeshCalcCtrs_zx @ -31.9 {
  zx=0;
  ‚àÄ node zx+=px;
  zx /= nbNode;
  dbc(yellow,"[Mesh::calcCtrs] zx["<<c<<"]="<<zx);
}

‚àÄ faces iniMeshCalcCtrs_ex @ -31.88 {
  ex = 0.0;
  ‚àÄ node ex += px; 
  ex /= nbNode;
  assert(nbNode==2);
  //dbc(yellow,"[Mesh::calcCtrs] ex["<<uid<<"]="<<ex);
}

‚àÄ cells iniMeshCalcVols @ -31.8 {
  const int N = nbNode;
  ‚Ñù¬≥ X[4]; ‚àÄ node X[#]=px;
  zvol=0;
  zarea=0; 
  ‚àÄ node{
    const int i=#;
    const int j=(#+1)%N;
    sarea = ¬Ω * cross2D(X[j]-X[i],zx-X[i]);
    svol = ‚Öì* sarea * (X[i].x+X[j].x+zx.x);
    zarea += sarea;
    zvol  += svol;
  }
  dbc(yellow,"[iniMeshCalcVols] zvol="<<zvol);
}

‚àÄ cells iniMeshCalcSideFracs @ -31.7 {
  ‚àÄ face {
    smf = sarea / zarea;
    //dbc(yellow,"[iniMeshCalcSideFracs] smf["<<c<<"]="<<smf);
  }
}

iniTstOptions @ -30.0 {
  dbc(magenta,"optTest");
  if (cstop == 999999 && tstop == 1.e99) {
    cerr << endl << "Must specify either cstop or tstop" << endl;
    exit;
  }
}

iniGlobals @ -20.0 {
  dbc(magenta,"iniGlobals");
  time = 0.0;
  cycle = 0;
}

‚àÄ cells iniZr @ -14.9 { zr=rinit; }
‚àÄ cells iniZe @ -14.9 { ze=einit; }
‚àÄ cells iniZwrate @ -14.9 { zwrate=0.0; }
‚àÄ cells @ -14.8 if (subregion) {
  const double eps = 1.e-12;
  if (!(zx.x > (subrgn_xmin - eps) && zx.x < (subrgn_xmax + eps) &&
        zx.y > (subrgn_ymin - eps) && zx.y < (subrgn_ymax + eps))) continue;
  dbc(white,"[subregion] zx["<<c<<"] in subregion!");
  zr = rinitsub;
  ze = einitsub;
}

‚àÄ cells iniZm @ -14.7 {
  zm = zr * zvol;
  dbc(white,"[Hydro::init] zm["<<c<<"]="<<zm);
}

‚àÄ cells iniZetot @ -14.6 {
  zetot = ze * zm;
  dbc(white,"[Hydro::init] zetot["<<c<<"]="<<zetot);
}

‚àÄ nodes iniPuRadial @ -14.5 if (uinitradial!=0.0) {
  const ‚Ñù eps = 1.e-12;
  const ‚Ñù pmag = length(px);
  if (pmag > eps) pu = uinitradial * px / pmag;
  else pu = 0.0;
}
‚àÄ nodes iniPuStd @ -14.5 if (uinitradial==0.0) { pu=0.0; }

iniRstDtHydro @ -14.4 { dtrec = 1.e99; }


// ****************************************************************************
// * Partie boucle de calcul ]+0.0,+‚àû[ 
// ****************************************************************************

incCycle @ 1.0 { cycle += 1; }

calcGlobalDt @ 2.0 {
  // Save timestep from last cycle
  const ‚Ñù dtlast = dt;
  // Compute timestep for this cycle
  dt = dtmax;
  if (cycle == 1) {    // compare to initial timestep
    dbc(magenta,"[Driver::calcGlobalDt] initial timestep, dtinit="<<dtinit);
    if (dtinit < dt) dt = dtinit;
  } else {
    const ‚Ñù dtrecover = dtfac * dtlast;
    if (dtrecover < dt) dt = dtrecover;
  }
  // compare to time-to-end
  if ((tstop - time) < dt) dt = tstop - time;
  // compare to hydro dt
  if (dtrec < dt) dt = dtrec;
  dbc(magenta,"[calcGlobalDt] dt="<<dt);
}

// Hydro::doCycle
// Begin hydro cycle

‚àÄ nodes saveOffPxFromPreviousCycle @ 3.0 { px0=px; }
‚àÄ nodes saveOffPuFromPreviousCycle @ 3.0 { pu0=pu; }
‚àÄ cells saveOffZvolFromPreviousCycle @ 3.0 { zvol0=zvol; }

// ===== Predictor step =====
// 1. advance mesh to center of time step
‚àÄ nodes advPosHalf0 @ 3.1 {
  pxp = px0 + pu0 * ¬Ω * dt;
  dbc(white,"[Hydro::advPosHalf] pxp"<<pxp);
}

// 1a. compute new mesh geometry
‚àÄ cells computeZxp @ 3.2 {
  zxp=0;
  ‚àÄ node zxp+=pxp;
  zxp/= nbNode;
  dbc(yellow,"[Mesh::calcCtrs] zxp["<<c<<"]="<<zxp);
}

‚àÄ faces computeExp @ 3.2 {
  exp = 0.0;
  ‚àÄ node exp += pxp;
  exp /= nbNode;
  //dbc(yellow,"[Mesh::calcCtrs] exp["<<f<<"]="<<exp);
}

‚àÄ cells calcVols @ 3.4 {
  const int N = nbNode;
  ‚Ñù¬≥ X[4]; ‚àÄ node X[#]=pxp;
  zareap=0; 
  zvolp=0;
  ‚àÄ node {
    const ‚Ñï j=(#+1)%N;
    sareap = ¬Ω * cross2D(X[j]-X[#],zxp-X[#]);
    svolp = ‚Öì* sareap * (X[#].x+X[j].x+zxp.x);
    zareap += sareap;
    zvolp  += svolp;
  } 
  dbc(yellow,"[calcVols] zvolp="<<zvolp);
}
//‚àÄ cells dumpZareap @ 3.41{dbc(yellow,"[calcVols] zareap="<<zareap);} 
//‚àÄ cells dumpSareap @ 3.42{ ‚àÄ node dbc(yellow,"[calcVols] sareap="<<sareap);} 

‚àÄ cells calcSurfVecs @ 3.5 {
  ‚àÄ face{
    ssurfp = rotateCCW(exp - zxp);
    //dbc(yellow,"[calcSurfVecs] ssurfp="<<ssurfp);
  }
}

‚àÄ faces calcEdgeLen @ 3.5 {
  elen = length(pxp[1]-pxp[0]);
  //dbc(yellow,"[calcEdgeLen] elen["<<f<<"]="<<elen);
}

‚àÄ cells calcCharLen @ 3.6 {
  zdl = 1.e99;
  ‚àÄ face {
    const ‚Ñù sdl = 4.0 * sareap / elen;
    zdl = min(zdl, sdl);
  }
  dbc(yellow,"[calcCharLen] zdl="<<zdl);
}

// 2. compute point masses
‚àÄ cells calcRhoOne @ 4.0 {
  zrp = zm / zvolp;
  dbc(white,"[calcRhoOne] zr="<<zrp);
}

‚àÄ cells calcCrnrMass @ 4.1 {
  const ‚Ñï N = nbNode;
  ‚Ñù m[4]; ‚àÄ node m[#]=smf;
  ‚àÄ node {
    const ‚Ñï j=(#+N-1)%N;
    cmaswt = ¬Ω * zrp * zareap * (m[#] + m[j]);
    dbc(white,"[calcCrnrMass] cmaswt="<<cmaswt);
  }
}

// 3. compute material state (half-advanced)
// calcStateAtHalf
‚àÄ cells calcStateAtHalf_calcEOS @ 5.0 {
  const ‚Ñù gm1 = ggamma - 1.0;
  const ‚Ñù ss2 = fmax(ssmin * ssmin, 1.e-99);
  const ‚Ñù rx = zr;
  const ‚Ñù local_ex = fmax(ze, 0.0);
  const ‚Ñù local_px = gm1 * rx * local_ex;
  const ‚Ñù prex = gm1 * local_ex;
  const ‚Ñù perx = gm1 * rx;
  const ‚Ñù csqd = fmax(ss2, prex + perx * local_px / (rx * rx));
  zp =local_px;
  z0per = perx;
  zss = ‚àö(csqd);
}
//‚àÄ cells dumpZss @ 5.01 {dbc(cyan,"[PolyGas::calcEOS] zss="<<zss);}
‚àÄ cells calcStateAtHalf_next @ 5.1 {
  const ‚Ñù dth = ¬Ω * dt;
  const ‚Ñù zminv = 1.0 / zm;
  const ‚Ñù dv = (zvolp - zvol0) * zminv;
  const ‚Ñù bulk = zr * zss * zss;
  const ‚Ñù denom = 1.0 + ¬Ω * z0per * dv;
  const ‚Ñù src = zwrate * dth * zminv;
  zp += (z0per * src - zr * bulk * dv) / denom;
  //dbc(cyan,"[PolyGas::calcStateAtHalf_next] zp="<<zp);
}

// 4. compute forces
‚àÄ cells pgasCalcForce @ 6.0 {
  ‚àÄ face {
    sfp=-zp * ssurfp;
    dbc(cyan,"[PolyGas::calcForce] sf["<<f<<"]="<<sfp);
  }
}
‚àÄ cells ttsCalcForce @ 6.1 {
  ‚àÄ face {
    const ‚Ñù svfacinv = zareap / sareap;
    const ‚Ñù srho = zrp * smf * svfacinv;
    ‚Ñù sstmp = fmax(zss, ssmin);
    sstmp = alpha * sstmp * sstmp;
    const ‚Ñù sdp = sstmp * (srho - zrp);
    const ‚Ñù¬≥ sqq = -sdp * ssurfp;
    sft = sqq;
    dbc(magenta,"[TTS::calcForce] sft="<<sft);
  }
}

‚àÄ cells qcsCalcForce_zoneCenteredVelocity @ 6.2 {
  z0uc=0;
  ‚àÄ node z0uc += pu;
  z0uc /= nbNode;  
  //dbc(green,"[QCS::setCornerDiv] z0uc="<<z0uc);
}

‚àÄ cells qcsCalcForce_setCornerDiv @ 6.3 {
  const ‚Ñï N = nbNode;
  const ‚Ñù¬≥ _pu[4] = {pu[0],pu[1],pu[2],pu[3]};
  const ‚Ñù¬≥ _ex[4] = {exp[0],exp[1],exp[2],exp[3]};
  const ‚Ñù _elen[4] = {elen[0],elen[1],elen[2],elen[3]};
  ‚àÄ node {
    const ‚Ñï i=(#+N-1)%N; // previous
    const ‚Ñï j=(#);       // current
    const ‚Ñï k=(#+1)%N;   // next
    //dbc(green,"[QCS::setCornerDiv] i="<<i<<", j="<<j<<", k="<<k);
    // Velocities and positions
    // 0 = point p
    const ‚Ñù¬≥ up0 = pu;
    const ‚Ñù¬≥ xp0 = pxp;
    //dbc(green,"[QCS::setCornerDiv] up0="<<up0<<", xp0="<<xp0);
    // 1 = edge e2
    const ‚Ñù¬≥ up1 = ¬Ω * (_pu[#] + _pu[k]);
    const ‚Ñù¬≥ xp1 = _ex[j];
    //dbc(green,"[QCS::setCornerDiv] up1="<<up1<<", xp1="<<xp1);
    // 2 = zone center z
    const ‚Ñù¬≥ up2 = z0uc;
    const ‚Ñù¬≥ xp2 = zxp;
    //dbc(green,"[QCS::setCornerDiv] up2="<<up2<<", xp2="<<xp2);
    // 3 = edge e1
    const ‚Ñù¬≥ up3 = ¬Ω * (_pu[i] + _pu[#]);
    const ‚Ñù¬≥ xp3 = _ex[i];
    //dbc(green,"[QCS::setCornerDiv] up3="<<up3<<", xp3="<<xp3);
    // compute 2d cartesian volume of corner
    const ‚Ñù cvolume = ¬Ω * cross2D(xp2-xp0, xp3-xp1);
    c0area = cvolume;
    //dbc(green,"[QCS::setCornerDiv] c0area="<<c0area);
    // compute cosine angle
    const ‚Ñù¬≥ v1 = xp3-xp0;
    const ‚Ñù¬≥ v2 = xp1-xp0;
    const ‚Ñù de1 = _elen[i];
    const ‚Ñù de2 = _elen[#];
    ‚Ñù minelen = min(de1, de2);
    //dbc(green,"[QCS::setCornerDiv] minelen="<<minelen);
    c0cos = ((minelen < 1.e-12) ?
                 0.0 : 4.0 * dot2D(v1,v2)/(de1*de2));
    //dbc(green,"[QCS::setCornerDiv] c0cos="<<c0cos);
    // compute divergence of corner
    c0div = (cross2D(up2-up0, xp3-xp1)-cross2D(up3-up1, xp2-xp0))/(2.0*cvolume);
    //dbc(green,"[QCS::setCornerDiv] c0div="<<c0div);
    // compute evolution factor
    const ‚Ñù¬≥ dxx1 = ¬Ω * (xp1+xp2-xp0-xp3);
    const ‚Ñù¬≥ dxx2 = ¬Ω * (xp2+xp3-xp0-xp1);
    const ‚Ñù dx1 = length(dxx1);
    const ‚Ñù dx2 = length(dxx2);
    // average corner-centered velocity
    const ‚Ñù¬≥ duav = 0.25 * (up0+up1+up2+up3);
    const ‚Ñù test1 = fabs(dot2D(dxx1,duav)*dx2);
    const ‚Ñù test2 = fabs(dot2D(dxx2,duav)*dx1);
    const ‚Ñù num = (test1>test2?dx1:dx2);
    const ‚Ñù den = (test1>test2?dx2:dx1);
    const ‚Ñù r = num / den;
    //‚Ñù evol = sqrt(4.0 * cvolume * r);
    const ‚Ñù evol = min(sqrt(4.0*cvolume*r),2.0*minelen);
    // compute delta velocity
    const ‚Ñù dv1 = length2(up1+up2-up0-up3);
    const ‚Ñù dv2 = length2(up2+up3-up0-up1);
    const ‚Ñù du = sqrt(max(dv1, dv2));
    c0evol = (c0div < 0.0 ? evol : 0.);
    //dbc(green,"[QCS::setCornerDiv] c0evol="<<c0evol);
    c0du   = (c0div < 0.0 ? du   : 0.);
    //dbc(green,"[QCS::setCornerDiv] c0du="<<c0du);
  }
}

// [4.1] Compute the c0rmu (real Kurapatenko viscous scalar)
‚àÄ cells qcsCalcForce_setQCnForce_4_1 @ 6.4 {
  const ‚Ñù gammap1 = qgamma + 1.0;
  ‚àÄ node {
    // Kurapatenko form of the viscosity
    const ‚Ñù ztmp2 = q2 * 0.25 * gammap1 * c0du;
    const ‚Ñù ztmp1 = q1 * zss;
    const ‚Ñù zkur = ztmp2 + sqrt(ztmp2 * ztmp2 + ztmp1 * ztmp1);
    // Compute c0rmu for each corner
    const ‚Ñù rmu = zkur * zrp * c0evol;
    c0rmu = ((c0div > 0.0) ? 0. : rmu);
    //dbc(green,"[QCS::setQCnForce] c0rmu="<<c0rmu);
  }
}

// [4.2] Compute the c0qe for each corner
‚àÄ cells qcsCalcForce_setQCnForce_4_2 @ 6.5 {
  const int N = nbNode;
  const ‚Ñù¬≥ _pu[4] = {pu[0],pu[1],pu[2],pu[3]};
  const ‚Ñù _elen[4] = {elen[0],elen[1],elen[2],elen[3]};
  ‚àÄ node {
    const ‚Ñï p1=(#+N-1)%N; // previous
    const ‚Ñï p=(#);        // current
    const ‚Ñï p2=(#+1)%N;   // next
    // Compute: c0qe(1,2,3)=edge 1, y component (2nd), 3rd corner
    //          c0qe(2,1,3)=edge 2, x component (1st)
    //dbc(green,"[QCS::setQCnForce] pu[p]="<<_pu[p]<<", pu[p2]="<<_pu[p2]);
    //dbc(green,"[QCS::setQCnForce] elen[e2]="<<_elen[p]<<", c0rmu="<<c0rmu);
    c0qe0 = c0rmu * (_pu[p] - _pu[p1]) / _elen[p1];
    //dbc(green,"[QCS::setQCnForce] c0qe0="<<c0qe0);
    c0qe1 = c0rmu * (_pu[p2] - _pu[p]) / _elen[p];
    //dbc(green,"[QCS::setQCnForce] c0qe1="<<c0qe1);
  }
}
//‚àÄ cells @ 6.51 { ‚àÄ node dbc(green,"[QCS::setQCnForce] c0qe0="<<c0qe0);}
//‚àÄ cells @ 6.52 { ‚àÄ node dbc(green,"[QCS::setQCnForce] c0qe1="<<c0qe1);}

// [5] Compute the Q forces
// Routine number [5]  in the full algorithm CS2DQforce(...)
// [5.1] Preparation of extra variables
‚àÄ cells qcsCalcForce_setForce_preparationOfExtraVariables @ 6.6 {
  ‚àÄ node {
    const ‚Ñù csin2 = 1.0 - c0cos * c0cos;
    //dbc(green,"[QCS::setForce] csin2="<<csin2);
    c0w   = ((csin2 < 1.e-4) ? 0. : c0area / csin2);
    c0cos = ((csin2 < 1.e-4) ? 0. : c0cos);
    //dbc(green,"[QCS::setForce] c0cos="<<c0cos);
  }
}
//‚àÄ cells @ 6.61 { ‚àÄ node dbc(green,"[QCS::setForce] c0w="<<c0w);}
//‚àÄ cells @ 6.62 { ‚àÄ node dbc(green,"[QCS::setForce] c0cos="<<c0cos);}

‚àÄ cells qcsCalcForce_setForce_setUpTheForcesOnCorners @ 6.7 {
  const ‚Ñï N = nbNode;
  const ‚Ñù _elen[4] = {elen[0],elen[1],elen[2],elen[3]};
  ‚àÄ face {
    // Edge length for c1, c2 contribution to s
    const ‚Ñù _el = _elen[#];
    const ‚Ñï c20 = (#+1)%N; // next
    sfq = (c0w*(c0qe1+c0cos*c0qe0)
           +c0w[NABLA_FACE_PER_CELL*c+c20]
           *(c0qe0[NABLA_FACE_PER_CELL*c+c20]
             +c0cos[NABLA_FACE_PER_CELL*c+c20]
             *c0qe1[NABLA_FACE_PER_CELL*c+c20]))/_el;
    dbc(green,"[QCS::setForce] sfq="<<sfq);
  }
}
// Routine number [6] in the full algorithm
‚àÄ cells qcsCalcForce_setVelDiff @ 6.8 {
  ‚Ñù z0tmp=0;
  const ‚Ñï N = nbNode;
  ‚Ñù¬≥ u[4]; ‚àÄ node u[#]=pu;
  ‚Ñù¬≥ x[4]; ‚àÄ node x[#]=pxp;
  ‚Ñù e[4]; ‚àÄ face e[#]=elen;
  ‚àÄ node {
    //const ‚Ñï i=(#+N-1)%N; // previous
    const ‚Ñï j=(#);       // current
    const ‚Ñï k=(#+1)%N; // next
    const ‚Ñù¬≥ dx = x[k]-x[j];
    const ‚Ñù¬≥ du = u[k]-u[j];
    //dbc(green,"[QCS::setVelDiff] dx="<<dx<<", du="<<du);
    const ‚Ñù lenx = e[j];
    const ‚Ñù dux = (lenx > 0. ? fabs(dot2D(du,dx)) / lenx : 0.);
    //dbc(green,"[QCS::setVelDiff] dux="<<dux);
    z0tmp = max(z0tmp, dux);
    //dbc(green,"[QCS::setVelDiff] z0tmp="<<z0tmp);
  }
  zdu = q1 * zss + 2. * q2 * z0tmp;
  dbc(green,"[QCS::setVelDiff] zdu="<<zdu);
}
//‚àÄ cells @ 6.61 { ‚àÄ node dbc(green,"[QCS::setVelDiff] zdu="<<zdu);}

‚àÄ cells sumCrnrForce @ 7.0 {
  const ‚Ñï N = nbNode;
  ‚Ñù¬≥ p[4]; ‚àÄ face p[#]=sfp;
  ‚Ñù¬≥ q[4]; ‚àÄ face q[#]=sfq;
  ‚Ñù¬≥ t[4]; ‚àÄ face t[#]=sft;
  ‚àÄ node {
    const ‚Ñï i=(#+N-1)%N; // previous
    //dbc(white,"[Hydro::sumCrnrForce] s="<<#<<", s3="<<i);
    //dbc(white,"[Hydro::sumCrnrForce] sf[s]="<<p[#]<<", sf2[s]="<<q[#]<<", sf3[s]="<<t[#]);
    cftot = (p[#] + q[#] + t[#]) - (p[i] + q[i] + t[i]);
    dbc(white,"[QCS::sumCrnrForce] cftot["<<(uid*4+n)<<"]="<<cftot);
  }
}

‚àÄ nodes sumCornerMassesToPoints @ 8.0{
  pmaswt=0;
  ‚àÄ cell pmaswt+=cmaswt;
  dbc(yellow,"[sumCornerMassesToPoints] pmaswt="<<pmaswt);
}

‚àÄ nodes sumCornerForcesToPoints @ 8.1{
  pf=0;
  //dbc(green,"[sumCornerForcesToPoints] node #"<<n);
  ‚àÄ cell {
/*    dbc(green,"[sumCornerForcesToPoints] "<<
      " xs_node_cell="<<xs_node_cell[NABLA_NODE_PER_CELL*(n<<WARP_BIT)+c]<<
      " xs_node_cell_corner="<<xs_node_cell_corner[NABLA_NODE_PER_CELL*(n<<WARP_BIT)+c]<<
      " gathered_cell_cftot="<<gathered_cell_cftot
      );*/
    pf+=cftot;
  }
  dbc(yellow,"[sumCornerForcesToPoints] pf="<<pf);
}
 
// 4a. apply boundary conditions
‚àÄ /*outer*/ nodes applyFixedBC_X @ 9.0 {
  if (px.x!=0.0 && px.x!=LENGTH) continue;
  //dbc(white,"[applyFixedBC] X p="<<n);
  const ‚Ñù¬≥ vfixx = ‚Ñù¬≥(1.,0.,0.);
  pu = project(pu, vfixx);
  pf = project(pf, vfixx);
}
‚àÄ /*outer*/ nodes applyFixedBC_Y @ 9.1 {
  if (px.y!=0.0 && px.y!=LENGTH) continue;
  //dbc(white,"[applyFixedBC] Y p="<<n);
  const ‚Ñù¬≥ vfixy = ‚Ñù¬≥(0.,1.,0.);
  pu = project(pu, vfixy);
  pf = project(pf, vfixy);
} 

‚àÄ nodes calcAccel @ 10.0 {
  const double fuzz = 1.e-99;
  pap = pf / max(pmaswt, fuzz);
  dbc(white,"[calcAccel] pap="<<pap);
}

// ===== Corrector step =====
// 6. advance mesh to end of time step
‚àÄ nodes advPosFull @ 11.0 {
  pu = pu0 + pap * dt;
  //dbc(white,"[Hydro::advPosFull] pu0="<<pu0);
  //dbc(white,"[Hydro::advPosFull] pu="<<pu);
  px = px0 + ¬Ω * (pu + pu0) * dt;
  //dbc(white,"[Hydro::advPosFull] px="<<px);
}

resetDtHydro @ 12.0 { dtrec = 1.e99; }

// 6a. compute new mesh geometry
‚àÄ cells computeNewMeshGeometry @ 13.0 {
  zx=0.0;
  ‚àÄ node zx+=px;
  zx /= nbNode;
  dbc(yellow,"[computeNewMeshGeometry] zx["<<c<<"]="<<zx);
}
‚àÄ faces computeExpBis @ 13.1 {
  ex = 0.0;
  ‚àÄ node ex += px;
  ex /= nbNode;
  assert(nbNode==2);
  //dbc(yellow,"[computeExpBis] ex["<<uid<<"]="<<ex);
}
‚àÄ cells calcVolsBis @ 13.2 { 
  const int N = nbNode;
  ‚Ñù¬≥ X[4]; ‚àÄ node X[#]=px;
  zvol=0;
  zarea=0; 
  ‚àÄ node {
    const ‚Ñï i=#;
    const ‚Ñï j=(#+1)%N;
    sarea = ¬Ω * cross2D(X[j]-X[i],zx-X[i]);
    svol = ‚Öì* sarea * (X[i].x+X[j].x+zx.x);
    zarea += sarea;
    zvol  += svol;
    //dbc(white,"[calcVolsBis] sarea["<<uid<<","<<n<<"]="<<sarea);
  }
  dbc(yellow,"[calcVolsBis] zvol="<<zvol);
}

// 7. compute work
‚àÄ cells calcWork @ 14.0 { // sfp, sfq, pu0, pu, pxp, dt, zw, zetot,
  zw=0; 
  const int N = nbNode;
  const ‚Ñù dth = ¬Ω * dt;
  //dbc(white,"[calcWork] dth="<<dth);
  ‚Ñù¬≥ _pu[4]; ‚àÄ node _pu[#]=pu;
  ‚Ñù¬≥ _pu0[4]; ‚àÄ node _pu0[#]=pu0;
  const ‚Ñù _xp[4] = {pxp[0].x,pxp[1].x,pxp[2].x,pxp[3].x};
  ‚àÄ face { 
    const ‚Ñï j=(#);
    const ‚Ñï k=(#+1)%N;
    const ‚Ñù¬≥ sftot = sfp + sfq;
    const ‚Ñù sd1 = dot2D( sftot, (_pu0[j] + _pu[j]));
    const ‚Ñù sd2 = dot2D(-sftot, (_pu0[k] + _pu[k]));
    const ‚Ñù dwork = -dth * (sd1 * _xp[j] + sd2 * _xp[k]);
    zetot += dwork;
    zw += dwork;
  }
  dbc(white,"[calcWork] zw="<<zw);
}

// 7a. compute work rate
‚àÄ cells calcWorkRate @ 15.0 { //(zvol0, zvol, zw, zp, dt, zwrate, zfirst, zlast);
  const ‚Ñù dtinv = 1. / dt;
  const ‚Ñù dvol = zvol - zvol0;
  zwrate = (zw + zp * dvol) * dtinv;
  dbc(white,"[calcWorkRate] zwrate="<<zwrate);
}

// 8. update state variables
‚àÄ cells calcEnergy @ 16.0 { //(zetot, zm, ze, zfirst, zlast);
  const ‚Ñù fuzz = 1.e-99;
  ze = zetot / (zm + fuzz);
  dbc(white,"[Hydro::calcEnergy] ze="<<ze);
}

‚àÄ cells calcRho @ 17.0 { //(zm, zvol, zr, zfirst, zlast);
  zr = zm / zvol;
  dbc(white,"[calcRho] zr="<<zr);
}

// 9.  compute timestep for next cycle

‚àÄ cells calcDtCourant @ 19.0 {
  const ‚Ñù fuzz = 1.e-99;
  ‚Ñù dtnew = 1.e99;
  const ‚Ñù cdu = max(zdu, max(zss, fuzz));
  const ‚Ñù zdthyd = zdl * cfl / cdu;
  dtnew = (zdthyd < dtnew ? zdthyd : dtnew);
  //dbc(white,"[Hydro::calcDtCourant] dtnew="<<dtnew);
  if (dtnew < dtrec){
    //dbc(white,"[calcDtCourant] dtrec="<<dtrec);
    dtrec = dtnew;
  }
}
calcDtCourantDump @ 19.1 {
  dbc(white,"[Hydro::calcDtCourant] dtrec="<<dtrec);
}

calcDtVolumeIni @ 20.0 {
  dvovmax = 1.e-99;
}
‚àÄ cells calcDtVolume @ 20.0 {
  const ‚Ñù zdvov = fabs((zvol - zvol0) / zvol0);
  dvovmax = (zdvov > dvovmax ? zdvov : dvovmax);
  dbc(white,"[Hydro::calcDtVolume] dvovmax="<<dvovmax);
}
calcDtVolumeTst @ 20.1 {
  const ‚Ñù dtnew = dt * cflv / dvovmax;
  //dbc(white,"[Hydro::calcDtVolume] dt="<<dt);
  //dbc(white,"[Hydro::calcDtVolume] cflv="<<cflv);
  //dbc(white,"[Hydro::calcDtVolume] dvovmax="<<dvovmax);
  dbc(white,"[Hydro::calcDtVolume] dtnew="<<dtnew);
  if (dtnew < dtrec){
    //dbc(white,"[calcDtVolume] dtrec="<<dtrec);
    dtrec = dtnew;
  }
}

calcDtHydro @ 20.2 {
  dbc(white,"[calcDtHydro] dtrec="<<dtrec);
}

// End of Hydro::doCycle

incTime @ 30.0 {
  time += dt;
  cout<<"[35mEnd cycle "<<cycle
      <<", time = "<<time<<", dt = "<<dt<<"[m"<<endl;
}

tstExit @ 40.0 {
  if (cycle < cstop && time < tstop) return;
  exit;
}
