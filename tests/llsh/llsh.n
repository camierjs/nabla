///////////////////////////////////////////////////////////////////////////////
// NABLA - a Numerical Analysis Based LAnguage                               //
//                                                                           //
// Copyright (C) 2014~2017 CEA/DAM/DIF                                       //
// IDDN.FR.001.520002.000.S.P.2014.000.10500                                 //
//                                                                           //
// Contributor(s): CAMIER Jean-Sylvain - Jean-Sylvain.Camier@cea.fr          //
//                                                                           //
// This software is a computer program whose purpose is to translate         //
// numerical-analysis specific sources and to generate optimized code        //
// for different targets and architectures.                                  //
//                                                                           //
// This software is governed by the CeCILL license under French law and      //
// abiding by the rules of distribution of free software. You can  use,      //
// modify and/or redistribute the software under the terms of the CeCILL     //
// license as circulated by CEA, CNRS and INRIA at the following URL:        //
// "http://www.cecill.info".                                                 //
//                                                                           //
// The CeCILL is a free software license, explicitly compatible with         //
// the GNU GPL.                                                              //
//                                                                           //
// As a counterpart to the access to the source code and rights to copy,     //
// modify and redistribute granted by the license, users are provided only   //
// with a limited warranty and the software's author, the holder of the      //
// economic rights, and the successive licensors have only limited liability.//
//                                                                           //
// In this respect, the user's attention is drawn to the risks associated    //
// with loading, using, modifying and/or developing or reproducing the       //
// software by the user in light of its specific status of free software,    //
// that may mean that it is complicated to manipulate, and that also         //
// therefore means that it is reserved for developers and experienced        //
// professionals having in-depth computer knowledge. Users are therefore     //
// encouraged to load and test the software's suitability as regards their   //
// requirements in conditions enabling the security of their systems and/or  //
// data to be ensured and, more generally, to use and operate it in the      //
// same conditions as regards security.                                      //
//                                                                           //
// The fact that you are presently reading this means that you have had      //
// knowledge of the CeCILL license and that you accept its terms.            //
//                                                                           //
// See the LICENSE file for details.                                         //
///////////////////////////////////////////////////////////////////////////////

// This NABLA port is an implementation of the benchmark LULESH:
// the Livermore Unstructured Lagrangian Explicit Shock Hydrodynamics
// (see https://computation.llnl.gov/casc/ShockHydro/ for details)

with cartesian;

//#include "assert.h"

// ****************************************************************************
// * Defines
// ****************************************************************************
#define XI_M        0x003
#define XI_M_SYMM   0x001
#define XI_M_FREE   0x002
#define XI_P        0x00C
#define XI_P_SYMM   0x004
#define XI_P_FREE   0x008
#define ETA_M       0x030
#define ETA_M_SYMM  0x010
#define ETA_M_FREE  0x020
#define ETA_P       0x0C0
#define ETA_P_SYMM  0x040
#define ETA_P_FREE  0x080
#define ZETA_M      0x300
#define ZETA_M_SYMM 0x100
#define ZETA_M_FREE 0x200
#define ZETA_P      0xC00
#define ZETA_P_SYMM 0x400
#define ZETA_P_FREE 0x800


// ****************************************************************************
// * Options
// ****************************************************************************
options{
  ‚Ñù LENGTH                    = 1.125;
  ‚Ñï X_EDGE_ELEMS              = 8;
  ‚Ñï Y_EDGE_ELEMS              = 8;
  ‚Ñï Z_EDGE_ELEMS              = 8;

  ‚Ñù option_dtfixed            = -1.0e-7;  // fixed time increment
  ‚Ñù option_Œ¥t_initial         = 1.0e-7;   // variable time increment
  ‚Ñù option_Œ¥t_courant         = 1.0e+20;
  ‚Ñù option_Œ¥t_hydro           = 1.0e+20;
  ‚Ñù option_Œ¥t_mult_lower_b    = 1.1;
  ‚Ñù option_Œ¥t_mult_upper_b    = 1.2;
  ‚Ñù option_initial_energy     = 3.948746e+7;
  ‚Ñù option_stoptime           = 1.0e-2;   // end time for simulation
  ‚Ñù option_hgcoef             = 3.0;      // hourglass control
  ‚Ñù option_qstop              = 1.0e+12;  // excessive q indicator
  ‚Ñù option_monoq_max_slope    = 1.0;
  ‚Ñù option_monoq_limiter_mult = 2.0;
  ‚Ñù option_e_cut              = 1.0e-7;   // energy tolerance
  ‚Ñù option_p_cut              = 1.0e-7;   // pressure tolerance
  ‚Ñù option_q_cut              = 1.0e-7;   // q tolerance
  ‚Ñù option_u_cut              = 1.0e-7;   // node velocity cut-off value
  ‚Ñù option_v_cut              = 1.0e-10;  // relative volume tolerance
  ‚Ñù option_qlc_monoq          = 0.5;      // linear term coef for q
  ‚Ñù option_qqc_monoq          = 0.6666666666667;//666666; // quadratic term coef for q
  ‚Ñù option_qqc                = 2.0;
  ‚Ñù option_eosvmax            = 1.0e+9;
  ‚Ñù option_eosvmin            = 1.0e-9;
  ‚Ñù option_pmin               = 0.0;      // pressure floor
  ‚Ñù option_emin               = -1.0e+15; // energy floor
  ‚Ñù option_dvovmax            = 0.1;      // maximum allowable volume change
  ‚Ñù option_refdens            = 1.0;      // reference density
  ‚Ñù option_dtmax              = 1.0e-2;   // maximum allowable time increment
  ‚Ñæ option_chaos              = false;
  ‚Ñù option_chaos_seed         = 1.1234567890123;//456789;
  ‚Ñï option_max_iterations     = 128;
};


// ****************************************************************************
// * Node Variables
// ****************************************************************************
nodes{
  ‚Ñù¬≥ ùúïx,ùúïùúïx;    // Velocity vector, Acceleration vector
  ‚Ñù¬≥ nForce;   // Force vector
  ‚Ñù nodalMass; // Nodal mass
};


// ****************************************************************************
// * Element Variables
// ****************************************************************************
cells{
  ‚Ñù p,e,q; // pressure,internal energy, artificial viscosity, relative volume
  ‚Ñù v,calc_volume,vdov; // instant and relative volume
  ‚Ñù delv,volo; // relative volume change, reference (initial) volume
  ‚Ñù arealg; // characteristic length
  ‚Ñù¬≥ Œµ; // diagonal terms of deviatoric strain  dxx(),dyy(),dzz()
  ‚Ñù ql,qq; // artificial viscosity linear and quadratic term
  ‚Ñù¬≥ cForce[nodes];
  // Temporaries
  ‚Ñù delv_xi, delv_eta, delv_zeta; // velocity gradient
  ‚Ñù delx_xi, delx_eta, delx_zeta; // coordinate gradient
  ‚Ñù phixi, phieta, phizeta;
  ‚Ñù vnew; // new relative volume
  ‚Ñù elemMass; // mass
  // EoS
  ‚Ñù e_old,p_old,q_old;
  ‚Ñù delvc;
  ‚Ñù compression;
  ‚Ñù compHalfStep;
  ‚Ñù work;
  ‚Ñù p_new,e_new,q_new;
  ‚Ñù bvc,pbvc;
  ‚Ñù vnewc;
  ‚Ñù pHalfStep;
  ‚Ñù sound_speed;
  // Boundary Conditions Flags
  ‚Ñï elemBC; // symmetry/free-surface flags for each elem face
  // Reductions
  ‚Ñù Œ¥t_cell_hydro;
  ‚Ñù Œ¥t_cell_courant;
};


// ****************************************************************************
// * Global Variables
// ****************************************************************************
global{
  ‚Ñù Œ¥t_courant; // Courant time constraint
  ‚Ñù Œ¥t_hydro;   // Hydro time constraint
};


// ****************************************************************************
// * Initialization Part @ ]-‚àû,-0.0[
// ****************************************************************************
void ini(void) @ -10.0{
  Œ¥t=(option_chaos)?option_Œ¥t_initial*option_chaos_seed:0.0;
  Œ¥t_hydro=option_Œ¥t_hydro;
  Œ¥t_courant=option_Œ¥t_courant;
}

‚àÄ nodes @ -12.0 {
  coord *= (option_chaos)?option_chaos_seed:1.0;
}

// ****************************************************************************
// * Set up boundary condition information
// * Set up elemement connectivity information
// ****************************************************************************
‚àÄ cells @ -9.5{
  const ‚Ñù zero = 0.0;
  const ‚Ñù maxBoundaryX = LENGTH;//X_EDGE_TICK*X_EDGE_ELEMS;
  const ‚Ñù maxBoundaryY = LENGTH;//Y_EDGE_TICK*Y_EDGE_ELEMS;
  const ‚Ñù maxBoundaryZ = LENGTH;//Z_EDGE_TICK*Z_EDGE_ELEMS;
  elemBC=0;
  ‚àÄ node{
    elemBC |= (coord.x==zero)?XI_M_SYMM;
    elemBC |= (coord.y==zero)?ETA_M_SYMM;
    elemBC |= (coord.z==zero)?ZETA_M_SYMM;
    elemBC |= (coord.x==maxBoundaryX)?XI_P_FREE;
    elemBC |= (coord.y==maxBoundaryY)?ETA_P_FREE;
    elemBC |= (coord.z==maxBoundaryZ)?ZETA_P_FREE;
  }
}

// ****************************************************************************
// * Cells initialization
// ****************************************************************************
‚àÄ cells @ -8.0{
  ‚Ñù¬≥ X[8];
  const ‚Ñù chaos = (((‚Ñù)uid)+1.0)*option_chaos_seed;
  v=1.0;
  ‚àÄ node X[n]=coord;
  e=(option_chaos)?chaos:(uid==0)?option_initial_energy:0.0;
  sound_speed=p=q=(option_chaos)?chaos;
  volo=elemMass=calc_volume=computeElemVolume(X);
}

‚àÄ nodes @ -6.9{
  nodalMass=0.0;
  ‚àÄ cell{
    nodalMass+=calc_volume/8.0;
  }
}

// ****************************************************************************
// * Compute part @ ]+0,+‚àû[
// ****************************************************************************

// ****************************************************************************
// * timeIncrement
// * This routine computes the time increment Œ¥tn for the
// * current timestep loop iteration. We aim for a "target" value of t_final-tn
// * for Œ¥tn . However, the actual time increment is allowed to grow by a
// * certain prescribed amount from the value used in the previous step and is
// * subject to the constraints Œ¥t_Courant and Œ¥t_hydro described in Section 1.5.3.
// ****************************************************************************
void timeIncrement(void) @ 0.1 {
  const ‚Ñù target_Œ¥t = option_stoptime - time;
  const ‚Ñù max_Œ¥t = 1.0e+20;
  const ‚Ñù new_Œ¥t_courant = (Œ¥t_courant < max_Œ¥t)?¬Ω*Œ¥t_courant:max_Œ¥t;
  const ‚Ñù new_Œ¥t_courant_hydro = (Œ¥t_hydro < new_Œ¥t_courant)?Œ¥t_hydro*2.0/3.0:new_Œ¥t_courant;
  const ‚Ñù now_Œ¥t = new_Œ¥t_courant_hydro ;
  const ‚Ñù old_Œ¥t = (iteration==1)?option_Œ¥t_initial:Œ¥t;
  const ‚Ñù ratio = now_Œ¥t / old_Œ¥t ;
  const ‚Ñù up_new_Œ¥t = (ratio >= 1.0)?(ratio < option_Œ¥t_mult_lower_b)?old_Œ¥t:now_Œ¥t:now_Œ¥t;
  const ‚Ñù dw_new_Œ¥t = (ratio >= 1.0)?(ratio > option_Œ¥t_mult_upper_b)?old_Œ¥t*option_Œ¥t_mult_upper_b:up_new_Œ¥t:up_new_Œ¥t;
  const ‚Ñù new_Œ¥t = (dw_new_Œ¥t > option_dtmax)?option_dtmax:dw_new_Œ¥t;
  const ‚Ñù Œ¥œÑ = (option_dtfixed <= 0.0)?(iteration != 1)?new_Œ¥t:old_Œ¥t:old_Œ¥t;
  const ‚Ñù scaled_target_Œ¥t = (target_Œ¥t>Œ¥œÑ)?((target_Œ¥t<(4.0*Œ¥œÑ/3.0))?2.0*Œ¥œÑ/3.0:target_Œ¥t):target_Œ¥t;
  const ‚Ñù scaled_Œ¥t = (scaled_target_Œ¥t < Œ¥œÑ)?scaled_target_Œ¥t:Œ¥œÑ;
  Œ¥t = scaled_Œ¥t ;
  if (((time+Œ¥t)==option_stoptime)?true:false)
    assert(X_EDGE_ELEMS==8 && Y_EDGE_ELEMS==8 && Z_EDGE_ELEMS==8 && iteration==470);
  if (iteration >= option_max_iterations) exit;
}

// ****************************************************************************
// * Sum contributions to total stress tensor
// * pull in the stresses appropriate to the hydro integration
// * Initialize stress terms for each element. Recall that our assumption of
// * an inviscid isotropic stress tensor implies that the three principal
// * stress components are equal, and the shear stresses are zero.
// * Thus, we initialize the diagonal terms of the stress tensor to
// * -(p + q) in each element.
// ****************************************************************************
‚àÄ cells @ 0.3 {
  const ‚Ñù chaos = (((‚Ñù)0.0)+1.0)*option_chaos_seed;
  const ‚Ñù sig = (option_chaos)?chaos:-p-q;
  ‚Ñù¬≥ fNormals,dj,x[8],B[8];
  ‚àÄ node x[n] = coord;
  Œµ = dj = -¬º*((x[0]+x[1]+x[5]+x[4])-(x[3]+x[2]+x[6]+x[7]));
  calcElemShapeFunctionDerivatives(x,B);
  ‚àÄ node B[n]=0.0;
  Œ£_FaceNormal(B,0,1,2,3,x);
  Œ£_FaceNormal(B,0,4,5,1,x);
  Œ£_FaceNormal(B,1,5,6,2,x);
  Œ£_FaceNormal(B,2,6,7,3,x);
  Œ£_FaceNormal(B,3,7,4,0,x);
  Œ£_FaceNormal(B,4,7,6,5,x);
  ‚àÄ node cForce = -sig*B[n];
}

‚àÄ nodes @ 0.301 {
  ‚Ñù¬≥ Œ£=0.0;
  ‚àÄ cell Œ£+=cForce;
  nForce=Œ£;
}

// ****************************************************************************
// * calcFBHourglassForceForElems
// * Calculates the Flanagan-Belytschko anti-hourglass force
// * calcFBHourglassForceForElems
// ****************************************************************************
‚àÄ cells @ 1.3{
  const ‚Ñù Œ≥[4][8]={{ 1., 1.,-1.,-1.,-1.,-1., 1., 1.},
                      { 1.,-1.,-1., 1.,-1., 1., 1.,-1.},
                      { 1.,-1., 1.,-1., 1.,-1., 1.,-1.},
                      {-1., 1.,-1., 1., 1.,-1., 1.,-1.}};
  ‚Ñù Œ∑0[4],Œ∑1[4],Œ∑2[4],Œ∑3[4] ;
  ‚Ñù Œ∑4[4],Œ∑5[4],Œ∑6[4],Œ∑7[4];
  ‚Ñù¬≥ x[8],xd[8],dvd[8],Œ∑[8];
  const ‚Ñù hourg=option_hgcoef;
  const ‚Ñù œÑv = volo*v;
  const ‚Ñù volume13=‚àõ(œÑv);
  const ‚Ñù Œ∏ = -hourg*0.01*sound_speed*elemMass/volume13;
  const ‚Ñù determ = œÑv;
  //const ‚Ñù chaos = (((‚Ñù)uid)+1.0)*option_chaos_seed;
  ‚àÄ node x[n] = coord;
  //‚àÄ node xd[n] = (option_chaos)?chaos:ùúïx;  
  ‚àÄ node xd[n] = ùúïx;
  dvd[0]=ùúïVolume(x[1],x[2],x[3],x[4],x[5],x[7]);
  dvd[3]=ùúïVolume(x[0],x[1],x[2],x[7],x[4],x[6]);
  dvd[2]=ùúïVolume(x[3],x[0],x[1],x[6],x[7],x[5]);
  dvd[1]=ùúïVolume(x[2],x[3],x[0],x[5],x[6],x[4]);
  dvd[4]=ùúïVolume(x[7],x[6],x[5],x[0],x[3],x[1]);
  dvd[5]=ùúïVolume(x[4],x[7],x[6],x[1],x[0],x[2]);
  dvd[6]=ùúïVolume(x[5],x[4],x[7],x[2],x[1],x[3]);
  dvd[7]=ùúïVolume(x[6],x[5],x[4],x[3],x[2],x[0]);
  cHourglassModes(0,determ,dvd,Œ≥,x,Œ∑0,Œ∑1,Œ∑2,Œ∑3,Œ∑4,Œ∑5,Œ∑6,Œ∑7);
  cHourglassModes(1,determ,dvd,Œ≥,x,Œ∑0,Œ∑1,Œ∑2,Œ∑3,Œ∑4,Œ∑5,Œ∑6,Œ∑7);
  cHourglassModes(2,determ,dvd,Œ≥,x,Œ∑0,Œ∑1,Œ∑2,Œ∑3,Œ∑4,Œ∑5,Œ∑6,Œ∑7);
  cHourglassModes(3,determ,dvd,Œ≥,x,Œ∑0,Œ∑1,Œ∑2,Œ∑3,Œ∑4,Œ∑5,Œ∑6,Œ∑7);
  calcElemFBHourglassForce(xd,Œ∑0,Œ∑1,Œ∑2,Œ∑3,Œ∑4,Œ∑5,Œ∑6,Œ∑7,Œ∏,Œ∑);
  ‚àÄ node cForce = Œ∑[n];
}

‚àÄ nodes @ 1.4 {
  ‚Ñù¬≥ Œ£=0.0;
  ‚àÄ cell Œ£+=cForce;
  nForce+=Œ£;
}

// ****************************************************************************
// * The routine CalcAccelerationForNodes() calculates a three-dimensional
// * acceleration vector A at each mesh node from F.
// * The acceleration is computed using Newton's Second Law of Motion,
// * F = m0 A, where m0 is the mass at the node.
// * Note that since the mass in each element is constant in time for our calculations,
// * the mass at each node is also constant in time.
// * The nodal mass values are set during the problem set up.
// ****************************************************************************
‚àÄ nodes @ 2.8{
  ùúïùúïx = nForce/nodalMass;
}

// ****************************************************************************
// * The routine ApplyAccelerationBoundaryConditions() applies symmetry boundary
// * conditions at nodes on the boundaries of the mesh where these were specified
// * during problem set up. A symmetry boundary condition sets the normal
// * component of A at the boundary to zero.
// * This implies that the normal component of the velocity vector U will
// * remain constant in time.
// ****************************************************************************
‚àÄ outer nodes @ 2.9 {
  ùúïùúïx.x=(coord.x==0.0)?0.0;
  ùúïùúïx.y=(coord.y==0.0)?0.0;
  ùúïùúïx.z=(coord.z==0.0)?0.0;
}

// ****************************************************************************
// * The routine CalcVelocityForNodes() integrates the acceleration at each node
// * to advance the velocity at the node to tn+1.
// * Note that this routine also applies a cut-off to each velocity vector value.
// * Specifically, if a value is below some prescribed value, that term is set to zero.
// * The reason for this cutoff is to prevent spurious mesh motion which may arise
// * due to floating point roundoff error when the velocity is near zero.
// ****************************************************************************
‚àÄ nodes @ 3.0{
  ùúïx += ùúïùúïx*Œ¥t ;
  ùúïx.x = (norm(ùúïx.x)<option_u_cut)?0.0;
  ùúïx.y = (norm(ùúïx.y)<option_u_cut)?0.0;
  ùúïx.z = (norm(ùúïx.z)<option_u_cut)?0.0;
}

// ****************************************************************************
// * The routine CalcPositionForNodes() performs the last step in the nodal
// * advance portion of the algorithm by integrating the velocity at each node
// * to advance the position of the node to tn+1.
// ****************************************************************************
‚àÄ nodes @ 3.1 { coord += ùúïx*Œ¥t; }

// ****************************************************************************
// * calcElemVolume
// ****************************************************************************
‚àÄ cells @ 4.0{
  const ‚Ñù dt2= ¬Ω*Œ¥t;
  const ‚Ñù Œ¥ = 1.e-36;
  ‚Ñù¬≥ B[8],X[8],Xd[8];
  ‚Ñù DetJ,volume,œÅVolume;
  ‚àÄ node X[n]=coord;
  ‚àÄ node Xd[n]=ùúïx;
  volume = calc_volume = computeElemVolume(X);  
  vnew = œÅVolume = volume/volo;
  delv = œÅVolume - v;
  arealg = calcElemCharacteristicLength(X,volume);
  const ‚Ñù vol = volo*vnew;
  const ‚Ñù nrm = 1.0/(vol+Œ¥);
  const ‚Ñù¬≥ di =  ¬º*((X[1]+X[2]+X[6]+X[5])-(X[0]+X[3]+X[7]+X[4]));
  const ‚Ñù¬≥ dj = -¬º*((X[0]+X[1]+X[5]+X[4])-(X[3]+X[2]+X[6]+X[7]));
  const ‚Ñù¬≥ dk =  ¬º*((X[4]+X[5]+X[6]+X[7])-(X[0]+X[1]+X[2]+X[3]));
  const ‚Ñù¬≥ a_xi = (dj‚®Ødk);
  const ‚Ñù¬≥ a_eta = (dk‚®Ødi);
  const ‚Ñù¬≥ a_zeta = (di‚®Ødj);
  const ‚Ñù¬≥ dv_xi  =  ¬º*((Xd[1]+Xd[2]+Xd[6]+Xd[5])-(Xd[0]+Xd[3]+Xd[7]+Xd[4]));
  const ‚Ñù¬≥ dv_eta = -¬º*((Xd[0]+Xd[1]+Xd[5]+Xd[4])-(Xd[3]+Xd[2]+Xd[6]+Xd[7]));
  const ‚Ñù¬≥ dv_zeta = ¬º*((Xd[4]+Xd[5]+Xd[6]+Xd[7])-(Xd[0]+Xd[1]+Xd[2]+Xd[3]));
  delx_xi = vol/‚àö(a_xi‚ãÖa_xi+Œ¥);
  delx_eta = vol/‚àö(a_eta‚ãÖa_eta+Œ¥);
  delx_zeta = vol/‚àö(a_zeta‚ãÖa_zeta+Œ¥);
  delv_zeta = (a_zeta*nrm)‚ãÖdv_zeta;     
  delv_xi = (a_xi*nrm)‚ãÖdv_xi;
  delv_eta = (a_eta*nrm)‚ãÖdv_eta;
  ‚àÄ node X[n] -= dt2*Xd[n];
  DetJ=calcElemShapeFunctionDerivatives(X,B);
  Œµ=calcElemVelocityGradient(Xd,B,DetJ);
  vdov = Œµ.x+Œµ.y+Œµ.z;
  Œµ -= ‚Öì*vdov;
}

// ****************************************************************************
// * This routine performs the second part of the q calculation.
// ****************************************************************************
‚àÄ cells @ 4.7{
  const ‚Ñù monoq_limiter_mult = option_monoq_limiter_mult;
  const ‚Ñù monoq_max_slope = option_monoq_max_slope;
  ‚Ñ§ bcSwitch;
  ‚Ñù delvm=0.0;
  ‚Ñù delvp=0.0;
  const ‚Ñù ptiny = 1.e-36;
  const ‚Ñù nrm = 1./(delv_xi+ptiny);
  bcSwitch = elemBC & XI_M;
  delvm = (bcSwitch == 0)?delv_xi[prevCellX];
  delvm = (bcSwitch == XI_M_SYMM)?delv_xi;
  delvm = (bcSwitch == XI_M_FREE)?0.0;
  delvm = delvm * nrm ;
  bcSwitch = elemBC & XI_P;
  delvp = (bcSwitch == 0)?delv_xi[nextCellX];
  delvp = (bcSwitch == XI_P_SYMM)?delv_xi;
  delvp = (bcSwitch == XI_P_FREE)?0.0;
  delvp = delvp * nrm ;
  phixi = ¬Ω * (delvm + delvp) ;
  delvm *= monoq_limiter_mult ;
  delvp *= monoq_limiter_mult ;
  phixi = (delvm < phixi)?delvm;
  phixi = (delvp < phixi)?delvp;
  phixi = (phixi < 0.)?0.0;
  phixi = (phixi > monoq_max_slope)?monoq_max_slope;
}

‚àÄ cells @ 4.7 {
  const ‚Ñù monoq_limiter_mult = option_monoq_limiter_mult;
  const ‚Ñù monoq_max_slope = option_monoq_max_slope;
  ‚Ñ§ register bcSwitch;
  ‚Ñù register delvm=0.;
  ‚Ñù register delvp=0.;
  const ‚Ñù ptiny = 1.e-36;
  const ‚Ñù nrm = 1./(delv_eta+ptiny);
  bcSwitch = elemBC & ETA_M;
  delvm = (bcSwitch == 0)?delv_eta[prevCellY];
  delvm = (bcSwitch == ETA_M_SYMM)?delv_eta;
  delvm = (bcSwitch == ETA_M_FREE)?0.0;
  delvm = delvm * nrm ;
  bcSwitch = elemBC & ETA_P;
  delvp = (bcSwitch == 0)?delv_eta[nextCellY];
  delvp = (bcSwitch == ETA_P_SYMM)?delv_eta;
  delvp = (bcSwitch == ETA_P_FREE)?0.0;
  delvp = delvp * nrm ;
  phieta = ¬Ω*(delvm + delvp) ;
  delvm *= monoq_limiter_mult ;
  delvp *= monoq_limiter_mult ;
  phieta = (delvm  < phieta)?delvm;
  phieta = (delvp  < phieta)?delvp;
  phieta = (phieta < 0.0)?0.0;
  phieta = (phieta > monoq_max_slope)?monoq_max_slope;
}

‚àÄ cells @ 4.7 {
  const ‚Ñù monoq_limiter_mult = option_monoq_limiter_mult;
  const ‚Ñù monoq_max_slope = option_monoq_max_slope;
  ‚Ñ§ bcSwitch;
  ‚Ñù delvm=0.;
  ‚Ñù delvp=0.;
  const ‚Ñù ptiny = 1.e-36;
  const ‚Ñù nrm = 1./(delv_zeta+ptiny) ;
  bcSwitch = elemBC & ZETA_M;
  delvm = (bcSwitch == 0)?delv_zeta[prevCellZ];
  delvm = (bcSwitch == ZETA_M_SYMM)?delv_zeta;
  delvm = (bcSwitch == ZETA_M_FREE)?0.0;
  delvm = delvm * nrm ;
  bcSwitch = elemBC & ZETA_P;
  delvp = (bcSwitch == 0)?delv_zeta[nextCellZ];
  delvp = (bcSwitch == ZETA_P_SYMM)?delv_zeta;
  delvp = (bcSwitch == ZETA_P_FREE)?0.0;
  delvp = delvp * nrm ;
  phizeta = ¬Ω*(delvm+delvp);
  delvm *= monoq_limiter_mult ;
  delvp *= monoq_limiter_mult ;
  phizeta = (delvm < phizeta )?delvm;
  phizeta = (delvp < phizeta )?delvp;
  phizeta = (phizeta < 0.0)?0.0;
  phizeta = (phizeta > monoq_max_slope )?monoq_max_slope;
}


‚àÄ cells @ 4.72{
  const ‚Ñù rho = elemMass/(volo*vnew);
  const ‚Ñù qlc_monoq = option_qlc_monoq;
  const ‚Ñù qqc_monoq = option_qqc_monoq;
  const ‚Ñù delvxxi   = delv_xi*delx_xi;
  const ‚Ñù delvxeta  = delv_eta*delx_eta;
  const ‚Ñù delvxzeta = delv_zeta*delx_zeta;
  const ‚Ñù delvxxit  = (delvxxi>0.0)?0.0:delvxxi;
  const ‚Ñù delvxetat = (delvxeta>0.0)?0.0:delvxeta;
  const ‚Ñù delvxzetat= (delvxzeta>0.0)?0.0:delvxzeta;
  const ‚Ñù qlin = -qlc_monoq*rho*(delvxxit*(1.0-phixi)+
                                    delvxetat*(1.0-phieta)+
                                    delvxzetat*(1.0-phizeta));
  const ‚Ñù qquad = qqc_monoq*rho*(delvxxit*delvxxit*(1.0-phixi*phixi) +
                                    delvxetat*delvxetat*(1.0-phieta*phieta) +
                                    delvxzetat*delvxzetat*(1.0-phizeta*phizeta));
  const ‚Ñù qlint  = (vdov>0.0)?0.0:qlin; 
  const ‚Ñù qquadt = (vdov>0.0)?0.0:qquad;
  qq = qquadt;
  ql = qlint;
}

// ****************************************************************************
// * The routine ApplyMaterialPropertiesForElems() updates the pressure and
// * internal energy variables to their values at the new time, p_n+1 and e_n+1.
// * The routine first initializes a temporary array with the values of Vn+1 for
// * each element that was computed earlier. Then, upper and lower cut-off
// * values are applied to each array value to keep the relative volumes
// * within a prescribed range (not too close to zero and not too large).
// * Next, the routine EvalEOSForElems() is called and the array of modified
// * relative element volumes is passed to it.
// ****************************************************************************
‚àÄ cells @ 5.0{
  vnewc = vnew ;
  vnewc = (vnewc < option_eosvmin)?option_eosvmin;
  vnewc = (vnewc > option_eosvmax)?option_eosvmax;
}


// ****************************************************************************
// * The routine EvalEOSForElems() calculates updated values for pressure p_n+1
// * and internal energy e_n+1.
// * The computation involves several loops over elements to pack various mesh
// * element arrays (e.g., p, e, q, etc.) into local temporary arrays.
// * Several other quantities are computed and stored in element length
// * temporary arrays also.
// * The temporary arrays are needed because the routine CalcEnergyForElems()
// * calculates p_n+1 and e_n+1 in each element in an iterative process that
// * requires knowledge of those variables at time tn while it computes the
// * new time values.
// ****************************************************************************
‚àÄ cells @ 6.0{
  const ‚Ñù vchalf = vnewc - ( ¬Ω*delv);
  work = 0.0; 
  e_old = e;
  delvc = delv;
  p_old = p;
  q_old = q ;
  compression = (1.0/vnewc) - 1.0;
  compHalfStep = (1.0/vchalf)-1.0;
}

‚àÄ cells @ 6.1 {
  compHalfStep = (vnewc <= option_eosvmin)?compression;
}

‚àÄ cells @ 6.6 {
  p_old = (vnewc < option_eosvmax)?p_old:0.0;
  compression =(vnewc < option_eosvmax)?compression:0.0;
  compHalfStep = (vnewc < option_eosvmax)?compHalfStep:0.0;
}

// ****************************************************************************
// * The routine CalcEnergyForElems() calls CalcPressureForElems() repeatedly.
// * The function CalcPressureForElems() is the Equation of State model
// * for a "gamma law" gas.
// * The value c1s passed to the routine is defined to be Œ≥ - 1.
// * The Equation of State calculation is a core part of any hydrocode.
// * In a production code, one of any number of Equation of State functions
// * may be called to generate a pressure that is needed to close the system
// * of equations and generate a unique solution.
// ****************************************************************************
// @ 7.1   calcEnergyForElems1
‚àÄ cells @ 7.1{
  e_new = e_old - ¬Ω*delvc*(p_old + q_old) + ¬Ω*work;
  e_new = (e_new < option_emin)?option_emin;
}

// ****************************************************************************
// * calcPressureForElems
// * p_new => pHalfStep
// * compression => compHalfStep
// * e_old => e_new
// ****************************************************************************
‚àÄ cells @ 7.2{
  const ‚Ñù c1s = 2.0/3.0;
  bvc = c1s*(compHalfStep+1.0);
  pbvc = c1s;
  pHalfStep = bvc*e_new ;
  pHalfStep=(rabs(pHalfStep)<option_p_cut)?0.0;
  pHalfStep = (vnewc >= option_eosvmax )?0.0;
  pHalfStep = (pHalfStep < option_pmin)?option_pmin;
}

inline ‚Ñù computeSoundSpeed(const ‚Ñù c, const ‚Ñù energy, const ‚Ñù volume,
                           const ‚Ñù b, const ‚Ñù pressure, const ‚Ñù rho,
                           const ‚Ñù _ql, const ‚Ñù _qq){
  const ‚Ñù pe = c*energy;
  const ‚Ñù vvbp=volume*volume*b*pressure;
  const ‚Ñù ssc = (pe + vvbp)/rho;
  const ‚Ñù ssct = (ssc <= 0.111111e-36)?0.333333e-18:‚àö(ssc);
  const ‚Ñù sscq = ssct*_ql;
  const ‚Ñù sscqt = sscq+_qq;
  return sscqt;
}

inline ‚Ñù computeSoundSpeed(const ‚Ñù c, const ‚Ñù energy, const ‚Ñù volume,
                           const ‚Ñù b, const ‚Ñù pressure, const ‚Ñù rho){
  const ‚Ñù pe = c*energy;
  const ‚Ñù vvbp=volume*volume*b*pressure;
  const ‚Ñù ssc = (pe + vvbp)/rho;
  const ‚Ñù ssct = (ssc <= 0.111111e-36)?0.333333e-18:‚àö(ssc);
  return ssct;
}

‚àÄ cells @ 7.3 {
  const ‚Ñù vhalf = 1.0/(1.0+compHalfStep);
  const ‚Ñù ssc = computeSoundSpeed(pbvc,e_new,vhalf,bvc,pHalfStep,option_refdens,ql,qq);
  q_new = (delvc>0.0)?0.0:ssc;
  e_new = e_new + ¬Ω*delvc*(3.0*(p_old+q_old)-4.0*(pHalfStep+q_new));
}

‚àÄ cells @ 7.4{
  e_new += ¬Ω*work;
  e_new = (rabs(e_new) < option_e_cut)?0.0;
  e_new = (e_new<option_emin)?option_emin;
}

‚àÄ cells @ 7.5,7.7{
  const ‚Ñù c1s = 2.0/3.0;
  bvc = c1s*(compression + 1.0);
  pbvc = c1s;
  p_new = bvc*e_new ;
  p_new = (rabs(p_new) < option_p_cut)?0.0;
  p_new = (vnewc >= option_eosvmax )?0.0;
  p_new = (p_new < option_pmin)?option_pmin;
}

‚àÄ cells @ 7.6{
  const ‚Ñù sixth = 1.0/6.0;
  const ‚Ñù ssc = computeSoundSpeed(pbvc,e_new,vnewc,bvc,p_new,option_refdens,ql,qq);
  const ‚Ñù q_tilde = (delvc > 0.)?0.0:ssc;
  e_new = e_new - (7.0*(p_old + q_old)
                   - (8.0)*(pHalfStep + q_new)
                   + (p_new + q_tilde)) * delvc*sixth;
  e_new = (rabs(e_new) < option_e_cut)?0.0;
  e_new = (e_new < option_emin)?option_emin;
}

‚àÄ cells @ 7.8{
  const ‚Ñù qnw = computeSoundSpeed(pbvc,e_new,vnewc,bvc,p_new,option_refdens,ql,qq);
  const ‚Ñù qnwt = (rabs(qnw) < option_q_cut)?0.0:qnw;
  q_new = (delvc <= 0.)?qnwt;
}

‚àÄ cells @ 8.0{
  p = p_new;
  e = e_new;
  q = q_new;
}

// ****************************************************************************
// * Lastly, the routine CalcSoundSpeedForElems() calculates the sound speed
// * sound_speed in each element using p_n+1 and e_n+1.
// * The maximum value of sound_speed is used to calculate constraints on t_n+1
// * which will be used for the next time advance step.
// ****************************************************************************
‚àÄ cells @ 9.0{
  const ‚Ñù ssTmpt = computeSoundSpeed(pbvc,e_new,vnewc,bvc,p_new,option_refdens);
  sound_speed = ssTmpt;
}

// ****************************************************************************
// * The routine UpdateVolumesForElems() updates the relative volume to V_n+1.
// * This routine basically resets the current volume V_n in each element to
// * the new volume V_n+1 so the simulation can continue to the next time
// * increment.
// * Note that this routine applies a cut-off to the relative volume V in
// * each element. Specifically, if V is sufficiently close to one (a
// * prescribed tolerance), then V is set to one.
// * The reason for this cutoff is to prevent spurious deviations of volume
// * from their initial values which may arise due to floating point roundoff
// * error.
// ****************************************************************************
‚àÄ cells @ 10.0{
  const ‚Ñù ŒΩ = vnew;
  const ‚Ñù ŒΩt = (rabs(ŒΩ-1.0)<option_v_cut)?1.0:ŒΩ;
  v = ŒΩt;
}

// ****************************************************************************
// * The routine CalcCourantConstraintForElems() calculates the Courant timestep
// * constraint Œ¥t_Courant. This constraint is calculated only in elements
// * whose volumes are changing that is, dV/V!=0.
// * If all element volumes remain the same, there is no Courant constraint
// * applied during the subsequent Œ¥t calculation.
// ****************************************************************************
‚àÄ cells @ 12.1{
  const ‚Ñù arg_max_courant=1.0e+20;
  Œ¥t_cell_courant=arg_max_courant;
  const ‚Ñù qqc2 = 64.0 * option_qqc * option_qqc ;
  const ‚Ñù Œ¥f = sound_speed[m] * sound_speed[m];
  const ‚Ñù Œ¥ft=(vdov[m]<0.0)?qqc2*arealg[m]*arealg[m]*vdov[m]*vdov[m]:0.0;
  const ‚Ñù Œ¥fpp = Œ¥f+Œ¥ft;
  const ‚Ñù Œ¥fp = ‚àö(Œ¥fpp);
  const ‚Ñù aŒ¥fp = arealg[m]/Œ¥fp;
  Œ¥t_cell_courant=(vdov!=0.0)?min(arg_max_courant,aŒ¥fp);
} 

// ****************************************************************************
// * The routine CalcHydroConstraintForElems() calculates the hydro timestep
// * constraint. Similar to Œ¥t_Courant, Œ¥t_hydro is calculated only in elements
// * whose volumes are changing. When an element is undergoing volume change,
// * Œ¥t_hydro for the element is some maximum allowable element volume change
// * (prescribed) divided by dV/V in the element.
// ****************************************************************************
‚àÄ cells @ 12.2{
  const ‚Ñù arg_max_hydro=1.0e+20;
  Œ¥t_cell_hydro=arg_max_hydro;
  const ‚Ñù Œ¥dv = rabs(vdov[m]);
  const ‚Ñù Œ¥dve = Œ¥dv+1.e-20;
  const ‚Ñù Œ¥dvov = option_dvovmax/Œ¥dve;
  const ‚Ñù Œ¥hdr = min(arg_max_hydro,Œ¥dvov);
  Œ¥t_cell_hydro=(vdov!=0.0)?Œ¥hdr;
}

// ****************************************************************************
// * After all solution variables are advanced to t_n+1, the constraints Œ¥tCourant
// * and Œ¥thydro for the next time increment t_n+1 are calculated in this routine.
// * Each constraint is computed in each element and then the final constraint value
// * is the minimum over all element values.
// * The constraints are applied during the computation of Œ¥t for the next time step.
// ****************************************************************************

// Cells min reduction
‚àÄ cells Œ¥t_courant <?= Œ¥t_cell_courant @ 12.11;
‚àÄ cells Œ¥t_hydro   <?= Œ¥t_cell_hydro   @ 12.22;
