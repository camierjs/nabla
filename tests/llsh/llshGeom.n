///////////////////////////////////////////////////////////////////////////////
// NABLA - a Numerical Analysis Based LAnguage                               //
//                                                                           //
// Copyright (C) 2014~2016 CEA/DAM/DIF                                       //
// IDDN.FR.001.520002.000.S.P.2014.000.10500                                 //
//                                                                           //
// Contributor(s): CAMIER Jean-Sylvain - Jean-Sylvain.Camier@cea.fr          //
//                                                                           //
// This software is a computer program whose purpose is to translate         //
// numerical-analysis specific sources and to generate optimized code        //
// for different targets and architectures.                                  //
//                                                                           //
// This software is governed by the CeCILL license under French law and      //
// abiding by the rules of distribution of free software. You can  use,      //
// modify and/or redistribute the software under the terms of the CeCILL     //
// license as circulated by CEA, CNRS and INRIA at the following URL:        //
// "http://www.cecill.info".                                                 //
//                                                                           //
// The CeCILL is a free software license, explicitly compatible with         //
// the GNU GPL.                                                              //
//                                                                           //
// As a counterpart to the access to the source code and rights to copy,     //
// modify and redistribute granted by the license, users are provided only   //
// with a limited warranty and the software's author, the holder of the      //
// economic rights, and the successive licensors have only limited liability.//
//                                                                           //
// In this respect, the user's attention is drawn to the risks associated    //
// with loading, using, modifying and/or developing or reproducing the       //
// software by the user in light of its specific status of free software,    //
// that may mean that it is complicated to manipulate, and that also         //
// therefore means that it is reserved for developers and experienced        //
// professionals having in-depth computer knowledge. Users are therefore     //
// encouraged to load and test the software's suitability as regards their   //
// requirements in conditions enabling the security of their systems and/or  //
// data to be ensured and, more generally, to use and operate it in the      //
// same conditions as regards security.                                      //
//                                                                           //
// The fact that you are presently reading this means that you have had      //
// knowledge of the CeCILL license and that you accept its terms.            //
//                                                                           //
// See the LICENSE file for details.                                         //
///////////////////////////////////////////////////////////////////////////////

// This NABLA port is an implementation of the benchmark LULESH:
// the Livermore Unstructured Lagrangian Explicit Shock Hydrodynamics
// (see https://computation.llnl.gov/casc/ShockHydro/ for details)

// ****************************************************************************
// * Geometrics functions
// ****************************************************************************


// ****************************************************************************
// * calcElemShapeFunctionDerivatives
// ****************************************************************************
Real calcElemShapeFunctionDerivatives(const Real3* restrict X, Real3* restrict Œ≤){
  const Real3 fjxi = ‚Öõ*((X[6]-X[0])+(X[5]-X[3])-(X[7]-X[1])-(X[4]-X[2]));
  const Real3 fjet = ‚Öõ*((X[6]-X[0])-(X[5]-X[3])+(X[7]-X[1])-(X[4]-X[2]));
  const Real3 fjze = ‚Öõ*((X[6]-X[0])+(X[5]-X[3])+(X[7]-X[1])+(X[4]-X[2]));
  // compute cofactors
  const Real3 cjxi =  (fjet‚®Øfjze);
  const Real3 cjet = -(fjxi‚®Øfjze);
  const Real3 cjze =  (fjxi‚®Øfjet);
  // calculate partials: this need only be done for 0,1,2,3
  // since, by symmetry, (6,7,4,5) = - (0,1,2,3)
  Œ≤[0] = - cjxi-cjet-cjze;
  Œ≤[1] =   cjxi-cjet-cjze;
  Œ≤[2] =   cjxi+cjet-cjze;
  Œ≤[3] = - cjxi+cjet-cjze;
  Œ≤[4] = -Œ≤[2];
  Œ≤[5] = -Œ≤[3];
  Œ≤[6] = -Œ≤[0];
  Œ≤[7] = -Œ≤[1];
  // calculate jacobian determinant (volume)
  return 8.0*(fjet‚ãÖcjet);
}


// ****************************************************************************
// * calcElemVelocityGradient
// ****************************************************************************
Real3 calcElemVelocityGradient(const Real3* restrict œÖ,
                               const Real3* restrict B,
                               const Real detJ){
  const Real inv_detJ=1.0/detJ;
  const Real3 œÖ06=œÖ[0]-œÖ[6];
  const Real3 œÖ17=œÖ[1]-œÖ[7];
  const Real3 œÖ24=œÖ[2]-œÖ[4];
  const Real3 œÖ35=œÖ[3]-œÖ[5];
  return inv_detJ*(B[0]*œÖ06+B[1]*œÖ17+B[2]*œÖ24+B[3]*œÖ35);
}


// ****************************************************************************
// * computeElemVolume
// ****************************************************************************
Real computeElemVolume(const Real3* restrict X){
  const Real twelveth = 1.0/12.0;  
  const Real3 d31=X[3]-X[1];
  const Real3 d72=X[7]-X[2];
  const Real3 d63=X[6]-X[3];
  const Real3 d20=X[2]-X[0];
  const Real3 d43=X[4]-X[3];
  const Real3 d57=X[5]-X[7];
  const Real3 d64=X[6]-X[4];
  const Real3 d70=X[7]-X[0];
  
  const Real3 d14=X[1]-X[4];
  const Real3 d25=X[2]-X[5];
  const Real3 d61=X[6]-X[1];
  const Real3 d50=X[5]-X[0];

  const Real tp1 = (d31+d72)‚ãÖ(d63‚®Ød20);
  const Real tp2 = (d43+d57)‚ãÖ(d64‚®Ød70);
  const Real tp3 = (d14+d25)‚ãÖ(d61‚®Ød50);
  return twelveth*(tp1+tp2+tp3);
}


// ****************************************************************************
// * AreaFace
// ****************************************************************************
Real AreaFace(const Real3 X0, const Real3 X1, const Real3 X2, const Real3 X3){
  const Real3 f=(X2-X0)-(X3-X1);
  const Real3 g=(X2-X0)+(X3-X1);
  return (f‚ãÖf)*(g‚ãÖg)-(f‚ãÖg)*(f‚ãÖg);
}


// ****************************************************************************
// * calcElemCharacteristicLength
// ****************************************************************************
Real calcElemCharacteristicLength(const Real3 X[8], const Real ŒΩ){
  Real œá=0.0;
  œá=max(AreaFace(X[0],X[1],X[2],X[3]),œá);
  œá=max(AreaFace(X[4],X[5],X[6],X[7]),œá);
  œá=max(AreaFace(X[0],X[1],X[5],X[4]),œá);
  œá=max(AreaFace(X[1],X[2],X[6],X[5]),œá);
  œá=max(AreaFace(X[2],X[3],X[7],X[6]),œá);
  œá=max(AreaFace(X[3],X[0],X[4],X[7]),œá);
  return 4.0*ŒΩ/‚àö(œá);
}


// ****************************************************************************
// * Œ£_FaceNormal
// ****************************************************************************
void Œ£_FaceNormal(Real3* restrict Œ≤,
                  const int ia, const int ib,
                  const int ic, const int id,
                  const Real3* X){
  const Real3 bisect0 = ¬Ω*(X[id]+X[ic]-X[ib]-X[ia]);
  const Real3 bisect1 = ¬Ω*(X[ic]+X[ib]-X[id]-X[ia]);
  const Real3 Œ± = ¬º*(bisect0‚®Øbisect1);
  Œ≤[ia] += Œ±; Œ≤[ib] += Œ±;  
  Œ≤[ic] += Œ±; Œ≤[id] += Œ±;  
}


// ****************************************************************************
// * calcElemVolumeDerivative
// * We keep the next one to allow sequential binary reproductibility
// ****************************************************************************
Real3 ùúïVolumeUnReproductible(const Real3 Œß0, const Real3 Œß1, const Real3 Œß2,
              const Real3 Œß3, const Real3 Œß4, const Real3 Œß5){
  const Real3 v01 = Œß0+Œß1;
  const Real3 v12 = Œß1+Œß2;
  const Real3 v25 = Œß2+Œß5;
  const Real3 v04 = Œß0+Œß4;
  const Real3 v34 = Œß3+Œß4;
  const Real3 v35 = Œß3+Œß5;
  return (1.0/12.0)*((v12‚®Øv01)+(v04‚®Øv34)-(v25‚®Øv35));
}

Real3 ùúïVolume(const Real3 Œß0, const Real3 Œß1, const Real3 Œß2,
              const Real3 Œß3, const Real3 Œß4, const Real3 Œß5){
  const Real x0=Œß0.x; const Real x1=Œß1.x;
  const Real x2=Œß2.x; const Real x3=Œß3.x;
  const Real x4=Œß4.x; const Real x5=Œß5.x;
  const Real y0=Œß0.y; const Real y1=Œß1.y;
  const Real y2=Œß2.y; const Real y3=Œß3.y;
  const Real y4=Œß4.y; const Real y5=Œß5.y;
  const Real z0=Œß0.z; const Real z1=Œß1.z;
  const Real z2=Œß2.z; const Real z3=Œß3.z;
  const Real z4=Œß4.z; const Real z5=Œß5.z;
  const Real x = (y1+y2)*(z0+z1)-(y0+y1)*(z1+z2)+(y0+y4)*(z3+z4)
    -(y3+y4)*(z0+z4)-(y2+y5)*(z3+z5)+(y3+y5)*(z2+z5);
  const Real y =-(x1+x2)*(z0+z1)+(x0+x1)*(z1+z2)-(x0+x4)*(z3+z4)
    +(x3+x4)*(z0+z4)+(x2+x5)*(z3+z5)-(x3+x5)*(z2+z5);
  const Real z =-(y1+y2)*(x0+x1)+(y0+y1)*(x1+x2)-(y0+y4)*(x3+x4)
    +(y3+y4)*(x0+x4)+(y2+y5)*(x3+x5)-(y3+y5)*(x2+x5);
  return (1.0/12.0)*Real3(x,y,z);
}


// ****************************************************************************
// * calcElemFBHourglassForce
// ****************************************************************************
void calcElemFBHourglassForce(const Real3* restrict xd,
                              const Real* restrict h0, const Real* restrict h1,
                              const Real* restrict h2, const Real* restrict h3,
                              const Real* restrict h4, const Real* restrict h5,
                              const Real* restrict h6, const Real* restrict h7,
                              const Real Œ∏, Real3* restrict Œ∑){
  const Real3 h00=h0[0]*xd[0] + h1[0]*xd[1] + h2[0]*xd[2] + h3[0]*xd[3] +h4[0]*xd[4] + h5[0]*xd[5] + h6[0]*xd[6] +h7[0]*xd[7];
  const Real3 h01=h0[1]*xd[0]+h1[1]*xd[1]+h2[1]*xd[2]+h3[1]*xd[3]+h4[1]*xd[4]+h5[1]*xd[5]+h6[1]*xd[6]+h7[1]*xd[7];
  const Real3 h02=h0[2]*xd[0]+h1[2]*xd[1]+h2[2]*xd[2]+h3[2]*xd[3]+h4[2]*xd[4]+h5[2]*xd[5]+h6[2]*xd[6]+h7[2]*xd[7];
  const Real3 h03=h0[3]*xd[0]+h1[3]*xd[1]+h2[3]*xd[2]+h3[3]*xd[3]+h4[3]*xd[4]+h5[3]*xd[5]+h6[3]*xd[6]+h7[3]*xd[7];
  
  Œ∑[0]=Œ∏*((h0[0]*h00)+(h0[1]*h01)+(h0[2]*h02)+(h0[3]*h03));
  Œ∑[1]=Œ∏*((h1[0]*h00)+(h1[1]*h01)+(h1[2]*h02)+(h1[3]*h03));
  Œ∑[2]=Œ∏*((h2[0]*h00)+(h2[1]*h01)+(h2[2]*h02)+(h2[3]*h03));
  Œ∑[3]=Œ∏*((h3[0]*h00)+(h3[1]*h01)+(h3[2]*h02)+(h3[3]*h03));
  Œ∑[4]=Œ∏*((h4[0]*h00)+(h4[1]*h01)+(h4[2]*h02)+(h4[3]*h03));
  Œ∑[5]=Œ∏*((h5[0]*h00)+(h5[1]*h01)+(h5[2]*h02)+(h5[3]*h03));
  Œ∑[6]=Œ∏*((h6[0]*h00)+(h6[1]*h01)+(h6[2]*h02)+(h6[3]*h03));
  Œ∑[7]=Œ∏*((h7[0]*h00)+(h7[1]*h01)+(h7[2]*h02)+(h7[3]*h03));
}


// ****************************************************************************
// * compute the hourglass modes
// ****************************************************************************
void cHourglassModes(const int i, const Real Œ¥,
                     const Real3 *Œî, const Real Œ≥[4][8],
                     const Real3 *œá,
                     Real* restrict h0, Real* restrict h1,
                     Real* restrict h2, Real* restrict h3,
                     Real* restrict h4, Real* restrict h5,
                     Real* restrict h6, Real* restrict h7){
  const Real œÖ=1.0/Œ¥;
  const Real3 Œ∑ = œá[0]*Œ≥[i][0]+œá[1]*Œ≥[i][1]+œá[2]*Œ≥[i][2]+œá[3]*Œ≥[i][3]+
    œá[4]*Œ≥[i][4]+œá[5]*Œ≥[i][5]+œá[6]*Œ≥[i][6]+œá[7]*Œ≥[i][7];
  h0[i] = Œ≥[i][0]-œÖ*(Œî[0]‚ãÖŒ∑);
  h1[i] = Œ≥[i][1]-œÖ*(Œî[1]‚ãÖŒ∑);
  h2[i] = Œ≥[i][2]-œÖ*(Œî[2]‚ãÖŒ∑);
  h3[i] = Œ≥[i][3]-œÖ*(Œî[3]‚ãÖŒ∑);
  h4[i] = Œ≥[i][4]-œÖ*(Œî[4]‚ãÖŒ∑);
  h5[i] = Œ≥[i][5]-œÖ*(Œî[5]‚ãÖŒ∑);
  h6[i] = Œ≥[i][6]-œÖ*(Œî[6]‚ãÖŒ∑);
  h7[i] = Œ≥[i][7]-œÖ*(Œî[7]‚ãÖŒ∑);
}

