
// ****************************************************************************
// * Initialisation de la partie AlgÃ¨bre LinÃ©aire
// ****************************************************************************

void rhsInit(void) @ 10.0{
  alephInitialize();
  â„µ rhs reset;
  â„µ lhs reset;
}


// ****************************************************************************
// * RHS, cotÃ© Primal
// ****************************************************************************
own cells void setRhsCellValues(void) @ 11.0{
  const Real value=cell_area*f(cell_mass_center);
  if (option_hole) assert(value>=0.0);
  â„µ rhs addValue(cell_Î¸,this, value);
}

own outer faces void setRhsðœ•Î©CellValues(void) @ 11.0{
  const Real value=boundary_primal_d_sp;
  if (!cell(0).isOwn()) continue;
  assert(value>=0.0);
  â„µ rhs addValue(cell_Î¸,cell(0), value);
}

// ****************************************************************************
// * RHS, cotÃ© Dual
// ****************************************************************************
own nodes void setRhsAllNodeValues(void) @ 11.0{
  Real h=node_is_on_ðœ•Î©?g(coord):node_area*f(coord);
  if (option_hole) assert(h>=0.0);
  â„µ rhs addValue(node_Î¸,this, h);
}


// ****************************************************************************
// * Remplissage MATRICE, cotÃ© Primal
// ****************************************************************************

// Diagonale outer: SsðžŠðœ•Pp et ðœ•Î©
outer faces void alephOuterCells(void) @ 12.0{
  const Real value = boundary_primal_c_sp;
  if (!cell(0).isOwn()) continue;
  assert(value>0.0);
  â„µ matrix addValue(cell_Î¸,cell(0), cell_Î¸,cell(0), value);
}


// ****************************************************************************
// Diag+extra inner: SsðžŠðœ•Pp sans ðœ•Î©
// ****************************************************************************
inner faces void alephInnerCells(void) @ 12.0{
  const Real pvalue = interior_primal_c_sp;
  const Real qvalue = interior_primal_c_sq;
  // On laisse le >= vs > pour les cas oÃ¹ les bords sont Ã  0.0
  assert(pvalue>=0.0 && qvalue>=0.0);
  if (backCell.isOwn()){
    â„µ matrix addValue(cell_Î¸,backCell, cell_Î¸,backCell,  +pvalue);
    â„µ matrix addValue(cell_Î¸,backCell, cell_Î¸,frontCell, -qvalue);
  }
  if (frontCell.isOwn()){
    â„µ matrix addValue(cell_Î¸,frontCell, cell_Î¸,frontCell, +qvalue);
    â„µ matrix addValue(cell_Î¸,frontCell, cell_Î¸,backCell,  -pvalue);
  }
}


// ****************************************************************************
// * On reboucle pour trouver la bonne face 'tournÃ©e'
// ****************************************************************************
Face loopOnThisNodeToFindPositiveDualFaceCells(Node nd,
                                               int face_uid,
                                               Bool swap,
                                               Cell *back, Cell *front){
  foreach nd face{
    if (face_uid!=fnd->uniqueId()) continue;
    *back=swap?fnd->backCell():fnd->frontCell();
    *front=swap?fnd->frontCell():fnd->backCell();
    return *fnd;
  }
  fatal("loopOnThisNodeToFindPositiveDualFaceCells");
}


// ****************************************************************************
// * Conditions de Dirichlet
// ****************************************************************************
own outer nodes void dirichletNodes(void) @ 17.0{
  â„µ matrix addValue(node_Î¸,this, node_Î¸,this, +1.0);
}

// ****************************************************************************
// * Aleph Solve
// ****************************************************************************
void assembleAndSolve(void) @ 18.0{ â„µ solve; }


// ****************************************************************************
// * RÃ©cupÃ©ration des rÃ©sultats
// ****************************************************************************
own cells void getCellResults(void) @ 20.0{
  const Real cell_Î¸_kp1=â„µ lhs getValue(cell_Î¸,this);
  assert(cell_Î¸_kp1>=0.0);
  cell_Î¸_kp1mk=fabs(cell_Î¸_kp1-cell_Î¸);
  if (GlobalIteration==1.0) cell_Î¸_1m0=cell_Î¸_kp1mk;
  cell_Î¸=cell_Î¸_kp1;
}
own nodes void getNodeResults(void) @ 20.0{
  const Real node_Î¸_kp1=â„µ lhs getValue(node_Î¸,this);
  if (node_Î¸_kp1<0.0)
    info()<<"\t\33[33m[getNodeResults] node_theta="<< node_Î¸_kp1 <<"\33[m";
  assert(node_Î¸_kp1>=0.0);
  if (GlobalIteration==1.0) node_Î¸_1m0=node_Î¸_kp1mk;
  node_Î¸_kp1mk=fabs(node_Î¸_kp1-node_Î¸);
  node_Î¸=node_Î¸_kp1;
}

// ****************************************************************************
// * RÃ©cupÃ©ration & CritÃ¨re de sortie des itÃ©rations de Picard
// ****************************************************************************
own cells Real maxCellError(Real mx){  mx=max(mx,cell_Î¸_kp1mk); return mx;}
own cells Real maxCellError0(Real mx){ mx=max(mx,cell_Î¸_1m0); return mx;}
own nodes Real maxNodeError(Real mx){  mx=max(mx,node_Î¸_kp1mk); return mx;}
own nodes Real maxNodeError0(Real mx){ mx=max(mx,node_Î¸_1m0); return mx;}
void stopIterations(void) @ 30.0{
  const Real mxÎµ = mpi_reduce(ReduceMax, max(maxCellError(0.0), maxNodeError(0.0)));
  const Real mx0 = mpi_reduce(ReduceMax, max(maxCellError0(0.0), maxNodeError0(0.0)));
  assert(mx0!=0.0);
  if (GlobalIteration>1.0 && mxÎµ<(option_picard_Îµ*mx0)){
    info()<<"\t\33[7m[stopIterations] mxÎµ="<<mxÎµ<<"\33[m";
    if (option_dag) dagIt();
    if (option_quit_when_finish) exit;
    //assert(fabs(eh2-0.000715252152895967)<10.0*__DBL_EPSILON__);
  }
  info()<<"\t[stopIterations] Picard @ "<<mxÎµ;
  debug()<<"\t[stopIterations] mx0="<<mx0;
}
