// ****************************************************************************
// * Benchmarks and Metrics
// * This standard configuration runs in 1495 iterations of the main loop.
// * We expect that a UHPC system should be able to run a calculation containing
// * more than one billion mesh elements and potentially more than that,
// * depending on available memory.
// ****************************************************************************
with cartesian;


// ****************************************************************************
// * Inlined geometrics functions
// ****************************************************************************
#define sum4(a,b,c,d) (a+b+c+d)

#define tripleProduct(x1,y1,z1,x2,y2,z2,x3,y3,z3)\
  ((x1)*((y2)*(z3)-(z2)*(y3))+(x2)*((z1)*(y3)-(y1)*(z3))+(x3)*((y1)*(z2)-(z1)*(y2)))

#define VoluDer(x0,x1,x2,x3,x4,x5,y0,y1,y2,y3,y4,y5,z0,z1,z2,z3,z4,z5,_dvdx,_dvdy,_dvdz){ \
    _dvdx =                                                            \
      (y1 + y2) * (z0 + z1) - (y0 + y1) * (z1 + z2) +                   \
      (y0 + y4) * (z3 + z4) - (y3 + y4) * (z0 + z4) -                   \
      (y2 + y5) * (z3 + z5) + (y3 + y5) * (z2 + z5);                    \
    _dvdy =- (x1 + x2) * (z0 + z1) + (x0 + x1) * (z1 + z2) -           \
      (x0 + x4) * (z3 + z4) + (x3 + x4) * (z0 + z4) +                   \
      (x2 + x5) * (z3 + z5) - (x3 + x5) * (z2 + z5);                    \
    _dvdz =- (y1 + y2) * (x0 + x1) + (y0 + y1) * (x1 + x2) -           \
      (y0 + y4) * (x3 + x4) + (y3 + y4) * (x0 + x4) +                   \
      (y2 + y5) * (x3 + x5) - (y3 + y5) * (x2 + x5);                    \
    _dvdx *= twelfth;                                                  \
    _dvdy *= twelfth;                                                  \
    _dvdz *= twelfth;                                                  \
  }


// ****************************************************************************
// * Defines
// ****************************************************************************
#define XI_M        0x003
#define XI_M_SYMM   0x001
#define XI_M_FREE   0x002
#define XI_P        0x00C
#define XI_P_SYMM   0x004
#define XI_P_FREE   0x008
#define ETA_M       0x030
#define ETA_M_SYMM  0x010
#define ETA_M_FREE  0x020
#define ETA_P       0x0C0
#define ETA_P_SYMM  0x040
#define ETA_P_FREE  0x080
#define ZETA_M      0x300
#define ZETA_M_SYMM 0x100
#define ZETA_M_FREE 0x200
#define ZETA_P      0xC00
#define ZETA_P_SYMM 0x400
#define ZETA_P_FREE 0x800


// ****************************************************************************
// * Options
// ****************************************************************************
options{
  Real option_dtfixed            = -1.0e-7;  // fixed time increment
  Real option_δt_initial         = 1.0e-7;   // variable time increment
  Real option_δt_courant         = 1.0e+20;
  Real option_δt_hydro           = 1.0e+20;
  Real option_δt_mult_lower_b    = 1.1;
  Real option_δt_mult_upper_b    = 1.2;
  Real option_initial_energy     = 3.948746e+7;
  Real option_stoptime           = 1.0e-2;   // 1.0e-2: end time for simulation
  Real option_hgcoef             = 3.0;      // hourglass control
  Real option_qstop              = 1.0e+12;  // excessive q indicator
  Real option_monoq_max_slope    = 1.0;
  Real option_monoq_limiter_mult = 2.0;
  Real option_e_cut              = 1.0e-7;   // energy tolerance
  Real option_p_cut              = 1.0e-7;   // pressure tolerance
  Real option_q_cut              = 1.0e-7;   // q tolerance
  Real option_u_cut              = 1.0e-7;   // node velocity cut-off value
  Real option_v_cut              = 1.0e-10;  // relative volume tolerance
  Real option_qlc_monoq          = 0.5;      // linear term coef for q
  Real option_qqc_monoq          = 0.66666666666666666;  // quadratic term coef for q
  Real option_qqc                = 2.0;
  Real option_eosvmax            = 1.0e+9;
  Real option_eosvmin            = 1.0e-9;
  Real option_pmin               = 0.0;      // pressure floor
  Real option_emin               = -1.0e+15; // energy floor
  Real option_dvovmax            = 0.1;      // maximum allowable volume change
  Real option_refdens            = 1.0;      // reference density
  Real option_dtmax              = 1.0e-2;   // maximum allowable time increment
  Integer option_max_iterations  = 100;
};


// ****************************************************************************
// * Node Variables
// ****************************************************************************
nodes{
  Real nVelocityx;Real nVelocityy;Real nVelocityz;
  Real nAccelerationx;Real nAccelerationy;Real nAccelerationz;
  Real nForcex; Real nForcey; Real nForcez;
  Real nodalMass;
};


// ****************************************************************************
// * Element Variables
// ****************************************************************************
cells{
  // Table 1.2 Element Variables  ////////////////
  Real p;              // pressure
  Real e;              // internal energy, (to synchronize)
  Real q;              // artificial viscosity
  Real v;              // relative volume
  Real calc_volume;    // instant relative volume
  Real vdov;           // relative volume change per volume
  Real delv;           // relative volume change
  Real volo;           // reference (initial) volume
  Real arealg;         // characteristic length
  Real εx;Real εy;Real εz;
  Real ql;             // artificial viscosity linear term, (to synchronize)
  Real qq;             // artificial viscosity quadratic term, (to synchronize)
  Real sigx;  Real sigy;  Real sigz;
  Real determ;         // element volume
  // Temporaries /////////////////////////////////
  Real delv_xi;        // velocity gradient
  Real delv_eta;
  Real delv_zeta;
  Real delx_xi;        // coordinate gradient
  Real delx_eta;
  Real delx_zeta;
  Real phixi;
  Real phieta;
  Real phizeta;
  Real vnew;           // new relative volume
  Real elemMass;       // mass
  // EoS /////////////////////////////////////////
  Real e_old;
  Real delvc;
  Real p_old;
  Real q_old;
  Real compression;
  Real compHalfStep;
  Real work;
  Real p_new;
  Real e_new;
  Real q_new;
  Real bvc;
  Real pbvc;
  Real vnewc;
  Real pHalfStep;
  Real sound_speed;
  ////////////////////////////////////////////////
  Integer elemBC;          // symmetry/free-surface flags for each elem face
};


// ****************************************************************************
// * Global Variables
// ****************************************************************************
global{
  Real δt_courant;         // Courant time constraint
  Real δt_hydro;           // Hydro time constraint
};


///////////////////////////////////////////////////////////////////////////////
// Partie d'initialisation ]-oo,-0[
///////////////////////////////////////////////////////////////////////////////


// ****************************************************************************
// * ini
// ****************************************************************************
void ini(void) @ -10.0{
  δt=0.0;
  δt_hydro=option_δt_hydro;
  δt_courant=option_δt_courant;
  if (option_eosvmax==0.) fatal("ini", "option_eosvmax==0.");
  if (option_eosvmin==0.) fatal("ini", "option_eosvmin==0.");
}



// ****************************************************************************
// * Set up boundary condition information
// * Set up elemement connectivity information
// ****************************************************************************
cells void iniCellBC(void) in (node coordx, node coordy, node coordz) out (cell elemBC) @ -9.5{
  const Real zero = 0.0;
  const Real maxBoundaryX = X_EDGE_TICK*X_EDGE_ELEMS;
  const Real maxBoundaryY = Y_EDGE_TICK*Y_EDGE_ELEMS;
  const Real maxBoundaryZ = Z_EDGE_TICK*Z_EDGE_ELEMS;
  elemBC=0; // clear BCs by default
  foreach node{
    elemBC |= (coordx==0.0)?XI_M_SYMM:0;
    elemBC |= (coordy==zero)?ETA_M_SYMM:0;
    elemBC |= (coordz==zero)?ZETA_M_SYMM:0; 
    elemBC |= (coordx==maxBoundaryX)?XI_P_FREE:0;
    elemBC |= (coordy==maxBoundaryY)?ETA_P_FREE:0;
    elemBC |= (coordz==maxBoundaryZ)?ZETA_P_FREE:0;
  }
}


// ****************************************************************************
// * iniElemVolume for iniVolume
// ****************************************************************************
cells void iniElemVolume(void)
  in (node coordx, node coordy, node coordz) out (cell calc_volume) @ -8.0{
  aligned Real x[8];
  aligned Real y[8];
  aligned Real z[8];
  foreach node x[n]=coordx;
  foreach node y[n]=coordy;
  foreach node z[n]=coordz;
  calc_volume = _calcElemVolume(x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7],
                                y[0], y[1], y[2], y[3], y[4], y[5], y[6], y[7],
                                z[0], z[1], z[2], z[3], z[4], z[5], z[6], z[7]);
}


// ****************************************************************************
// * iniVolume
// ****************************************************************************
cells void iniVolume(void) in (cell calc_volume)
  out (cell volo, cell elemMass, node nodalMass) @ -7.0{
  volo=elemMass=calc_volume;
  foreach node nodalMass += volo / 8.0;
}


// ****************************************************************************
// * depositEnergy
// ****************************************************************************
cells void iniCellStateAndDepositEnergy(void) out (cell e, cell v) @ -2.0{
  v=1.0;
  e=(uid==0)?option_initial_energy:0.0;
}



///////////////////////////////////////////////////////////////////////////////
// Partie de calcul ]+0,+oo[ = timestep to solution
//    initialize nodal coordinates
//    embed hexehedral elements in nodal point lattice
//    Create a material IndexSet (entire domain same material for now)
//    initialize field data
//    volume calculations
//    set up symmetry nodesets
//    set up elemement connectivity information
//    set up boundary condition information
//    faces on "external" boundaries will be symmetry plane or free surface BCs
//    timestep to solution
///////////////////////////////////////////////////////////////////////////////


  
// ****************************************************************************
// * timeIncrement
// * The routine CalcTimeIncrement() computes the time increment δtn for the
// * current timestep loop iteration. We aim for a "target" value of t_final-tn
// * for δtn . However, the actual time increment is allowed to grow by a
// * certain prescribed amount from the value used in the previous step and is
// * subject to the constraints δt_Courant and δt_hydro described in Section 1.5.3.
// ****************************************************************************
void timeIncrement(void) @ 0.1 {
  const Real max_δt = 1.0e+20;
  const Real target_δt = option_stoptime - time;
  const Real old_δt = (GlobalIteration==1)?option_δt_initial:δt;
  const Real new_δt_courant = (δt_courant < max_δt)?½*δt_courant:max_δt;
  const Real new_δt_courant_hydro = (δt_hydro < new_δt_courant)?δt_hydro*2.0/3.0:new_δt_courant;
  const Real now_δt = new_δt_courant_hydro ;
  const Real ratio = now_δt / old_δt ;
  const Real up_new_δt = (ratio >= 1.0)?(ratio < option_δt_mult_lower_b)?old_δt:now_δt:now_δt;
  const Real dw_new_δt = (ratio >= 1.0)?(ratio > option_δt_mult_upper_b)?old_δt*option_δt_mult_upper_b:up_new_δt:up_new_δt;
  const Real new_δt = (dw_new_δt > option_dtmax)?option_dtmax:dw_new_δt;
  δt = (option_dtfixed <= 0.0)?(GlobalIteration != 1)?new_δt:old_δt:old_δt;
  {
    // Try to prevent very small scaling on the next cycle
    const Real scaled_target_δt = (target_δt>δt)?((target_δt<(4.0*δt/3.0))?2.0*δt/3.0:target_δt):target_δt;
    δt = (scaled_target_δt < δt)?scaled_target_δt:δt;
    δt=mpi_reduce(ReduceMin, δt);
  }
  // Cuda
  δt=option_δt_initial;
  //info()<< "\t\t[timeIncrement] δt="<<δt;
  //if (ReduceMinToDouble(δt) == 0.) exit;
  //if (GlobalIteration == option_max_iterations) exit;
  }




nodes void calcForceForNodesIni(void) out (node nForcex, node nForcey, node nForcez) @ 0.1 {
  nForcex=nForcey=nForcez=0.0;
}




// Start of LagrangeNodal
// Start of CalcVolumeForceForElems

// ********************************************************
// IntegrateStressForElems
// ********************************************************
cells void integrateStressForElems(void)
  in (node coordx, node coordy, node coordz, cell p, cell q, cell determ)
  out (cell sigx,cell sigy,cell sigz,
       cell εx, cell εy, cell εz,
       node nForcex, node nForcey, node nForcez) @ 0.2{
  Real Bx[8],By[8],Bz[8]; // shape function derivatives
  Real x[8],y[8],z[8];
  foreach node x[n]=coordx;
  foreach node y[n]=coordy;
  foreach node z[n]=coordz;
    //Bx[n]=By[n]=Bz[n]=0.0;  
  calcElemShapeFunctionDerivatives(x,y,z,Bx,By,Bz,&determ);
  
  {
    const Real djx = -¼*((x[0]+x[1]+x[5]+x[4]) - (x[3]+x[2]+x[6]+x[7])) ;
    const Real djy = -¼*((y[0]+y[1]+y[5]+y[4]) - (y[3]+y[2]+y[6]+y[7])) ;
    const Real djz = -¼*((z[0]+z[1]+z[5]+z[4]) - (z[3]+z[2]+z[6]+z[7])) ;
    εx=djx;
    εy=djy;
    εz=djz;
  }

  // InitStressTermsForElems
  sigx = sigy = sigz = -p-q;

  sumElemFaceNormal(&Bx[0],&By[0],&Bz[0],&Bx[1],&By[1],&Bz[1],&Bx[2],&By[2],&Bz[2],&Bx[3],&By[3],&Bz[3],0,1,2,3,&x[0],&y[0],&z[0]);
  sumElemFaceNormal(&Bx[0],&By[0],&Bz[0],&Bx[4],&By[4],&Bz[4],&Bx[5],&By[5],&Bz[5],&Bx[1],&By[1],&Bz[1],0,4,5,1,&x[0],&y[0],&z[0]);
  sumElemFaceNormal(&Bx[1],&By[1],&Bz[1],&Bx[5],&By[5],&Bz[5],&Bx[6],&By[6],&Bz[6],&Bx[2],&By[2],&Bz[2],1,5,6,2,&x[0],&y[0],&z[0]);
  sumElemFaceNormal(&Bx[2],&By[2],&Bz[2],&Bx[6],&By[6],&Bz[6],&Bx[7],&By[7],&Bz[7],&Bx[3],&By[3],&Bz[3],2,6,7,3,&x[0],&y[0],&z[0]);
  sumElemFaceNormal(&Bx[3],&By[3],&Bz[3],&Bx[7],&By[7],&Bz[7],&Bx[4],&By[4],&Bz[4],&Bx[0],&By[0],&Bz[0],3,7,4,0,&x[0],&y[0],&z[0]);
  sumElemFaceNormal(&Bx[4],&By[4],&Bz[4],&Bx[7],&By[7],&Bz[7],&Bx[6],&By[6],&Bz[6],&Bx[5],&By[5],&Bz[5],4,7,6,5,&x[0],&y[0],&z[0]);

  foreach node nForcex += -sigx*Bx[n];
  foreach node nForcey += -sigy*By[n];
  foreach node nForcez += -sigz*Bz[n];
}



// ****************************************************************************
// * calcFBHourglassForceForElems
// * Calculates the Flanagan-Belytschko anti-hourglass force
// ****************************************************************************
cells void calcFBHourglassForceForElems(void)
  in (node coordx, node coordy, node coordz, cell volo, cell v,
      cell determ, cell sound_speed, cell elemMass,
      node nVelocityx, node nVelocityy, node nVelocityz)
  out (node nForcex, node nForcey, node nForcez)  @ 1.3{
  const Real twelfth =1.0/12.0;
  const Real gamma[4][8]={{ 1., 1.,-1.,-1.,-1.,-1., 1., 1.},
                          { 1.,-1.,-1., 1.,-1., 1., 1.,-1.},
                          { 1.,-1., 1.,-1., 1.,-1., 1.,-1.},
                          {-1., 1.,-1., 1., 1.,-1., 1.,-1.}};
  const Real hourg=option_hgcoef;
  aligned Real x[8];
  aligned Real y[8];
  aligned Real z[8];
  aligned Real xd[8];
  aligned Real yd[8];
  aligned Real zd[8];
  aligned Real dvdx[8];
  aligned Real dvdy[8];
  aligned Real dvdz[8];
  aligned Real hourgam0[4];
  aligned Real hourgam1[4];
  aligned Real hourgam2[4];
  aligned Real hourgam3[4];
  aligned Real hourgam4[4];
  aligned Real hourgam5[4];
  aligned Real hourgam6[4];
  aligned Real hourgam7[4];
  aligned Real hgfx[8];
  aligned Real hgfy[8];
  aligned Real hgfz[8];
  
  foreach node x[n]=coordx;
  foreach node y[n]=coordy;
  foreach node z[n]=coordz;
  
//#warning This is the first
  VoluDer(x[1], x[2], x[3], x[4], x[5], x[7],
          y[1], y[2], y[3], y[4], y[5], y[7],
          z[1], z[2], z[3], z[4], z[5], z[7],
          dvdx[0], dvdy[0], dvdz[0]);
  VoluDer(x[0], x[1], x[2], x[7], x[4], x[6],
          y[0], y[1], y[2], y[7], y[4], y[6],
          z[0], z[1], z[2], z[7], z[4], z[6],
          dvdx[3], dvdy[3], dvdz[3]);
  VoluDer(x[3], x[0], x[1], x[6], x[7], x[5],
          y[3], y[0], y[1], y[6], y[7], y[5],
          z[3], z[0], z[1], z[6], z[7], z[5],
          dvdx[2], dvdy[2], dvdz[2]);
  VoluDer(x[2], x[3], x[0], x[5], x[6], x[4],
          y[2], y[3], y[0], y[5], y[6], y[4],
          z[2], z[3], z[0], z[5], z[6], z[4],
          dvdx[1], dvdy[1], dvdz[1]);
  VoluDer(x[7], x[6], x[5], x[0], x[3], x[1],
          y[7], y[6], y[5], y[0], y[3], y[1],
          z[7], z[6], z[5], z[0], z[3], z[1],
          dvdx[4], dvdy[4], dvdz[4]);
  VoluDer(x[4], x[7], x[6], x[1], x[0], x[2],
          y[4], y[7], y[6], y[1], y[0], y[2],
          z[4], z[7], z[6], z[1], z[0], z[2],
          dvdx[5], dvdy[5], dvdz[5]);
  VoluDer(x[5], x[4], x[7], x[2], x[1], x[3],
          y[5], y[4], y[7], y[2], y[1], y[3],
          z[5], z[4], z[7], z[2], z[1], z[3],
          dvdx[6], dvdy[6], dvdz[6]);
  VoluDer(x[6], x[5], x[4], x[3], x[2], x[0],
          y[6], y[5], y[4], y[3], y[2], y[0],
          z[6], z[5], z[4], z[3], z[2], z[0],
          dvdx[7], dvdy[7], dvdz[7]);
  determ = volo * v;
  
  _computeHourglassModes(0, determ, dvdx, dvdy, dvdz, gamma, x,y,z, hourgam0,hourgam1,hourgam2,hourgam3,hourgam4,hourgam5,hourgam6,hourgam7);
  _computeHourglassModes(1, determ, dvdx, dvdy, dvdz, gamma, x,y,z, hourgam0,hourgam1,hourgam2,hourgam3,hourgam4,hourgam5,hourgam6,hourgam7);
  _computeHourglassModes(2, determ, dvdx, dvdy, dvdz, gamma, x,y,z, hourgam0,hourgam1,hourgam2,hourgam3,hourgam4,hourgam5,hourgam6,hourgam7);
  _computeHourglassModes(3, determ, dvdx, dvdy, dvdz, gamma, x,y,z, hourgam0,hourgam1,hourgam2,hourgam3,hourgam4,hourgam5,hourgam6,hourgam7);
  {
    const Real volume13=∛(determ);
    const Real coefficient = -0.01*hourg*sound_speed*elemMass/volume13;
    foreach node xd[n] = nVelocityx;
    foreach node yd[n] = nVelocityy;
    foreach node zd[n] = nVelocityz;
    //#warning This is the second
    calcElemFBHourglassForce(xd,yd,zd, hourgam0,hourgam1,hourgam2,hourgam3, hourgam4,hourgam5,hourgam6,hourgam7, coefficient, hgfx, hgfy, hgfz);
  }
  foreach node nForcex += hgfx[n];
  foreach node nForcey += hgfy[n];
  foreach node nForcez += hgfz[n];  
}

// end of CalcVolumeForceForElems





// ****************************************************************************
// * The routine CalcAccelerationForNodes() calculates a three-dimensional
// * acceleration vector A at each mesh node from F.
// * The acceleration is computed using Newton's Second Law of Motion,
// * F = m0 A, where m0 is the mass at the node.
// * Note that since the mass in each element is constant in time for our calculations,
// * the mass at each node is also constant in time.
// * The nodal mass values are set during the problem set up.
// ****************************************************************************
nodes void calcAccelerationForNodes(void)
  in (node nForcex,node nForcey,node nForcez, node nodalMass)
  out (node nAccelerationx, node nAccelerationy, node nAccelerationz) @ 2.8{
  nAccelerationx = nForcex / nodalMass;
  nAccelerationy = nForcey / nodalMass;
  nAccelerationz = nForcez / nodalMass;
}


// ****************************************************************************
// * The routine ApplyAccelerationBoundaryConditions() applies symmetry boundary
// * conditions at nodes on the boundaries of the mesh where these were specified
// * during problem set up. A symmetry boundary condition sets the normal
// * component of A at the boundary to zero.
// * This implies that the normal component of the velocity vector U will
// * remain constant in time.
// ****************************************************************************
outer nodes void applyAccelerationBoundaryConditionsForNodes(void)
  out (node nAccelerationx, node nAccelerationy, node nAccelerationz) @ 2.9 {
  const Real maxBoundaryX = X_EDGE_TICK*X_EDGE_ELEMS;
  const Real maxBoundaryY = Y_EDGE_TICK*Y_EDGE_ELEMS;
  const Real maxBoundaryZ = Z_EDGE_TICK*Z_EDGE_ELEMS;
  // MIN boundaries
  nAccelerationx=(coordx==0.0)?0.0:nAccelerationx;
  nAccelerationy=(coordy==0.0)?0.0:nAccelerationy;
  nAccelerationz=(coordz==0.0)?0.0:nAccelerationz;
  // MAX boundaries
  nAccelerationx=(coordx==maxBoundaryX)?0.0:nAccelerationx;
  nAccelerationy=(coordy==maxBoundaryY)?0.0:nAccelerationy;
  nAccelerationz=(coordz==maxBoundaryZ)?0.0:nAccelerationz;
}


// ****************************************************************************
// * The routine CalcVelocityForNodes() integrates the acceleration at each node
// * to advance the velocity at the node to tn+1.
// * Note that this routine also applies a cut-off to each velocity vector value.
// * Specifically, if a value is below some prescribed value, that term is set to zero.
// * The reason for this cutoff is to prevent spurious mesh motion which may arise
// * due to floating point roundoff error when the velocity is near zero.
// ****************************************************************************
nodes void calcVelocityForNodes(void)
  in (node nAccelerationx, node nAccelerationy, node nAccelerationz)
  inout (node nVelocityx, node nVelocityy, node nVelocityz) @ 3.0{
  const Real velocityx = nVelocityx + nAccelerationx * δt ;
  const Real velocityy = nVelocityy + nAccelerationy * δt ;
  const Real velocityz = nVelocityz + nAccelerationz * δt ;
  nVelocityx = (norm(velocityx) < option_u_cut )?0.0:velocityx;
  nVelocityy = (norm(velocityy) < option_u_cut )?0.0:velocityy;
  nVelocityz = (norm(velocityz) < option_u_cut )?0.0:velocityz;
}


// ****************************************************************************
// * The routine CalcPositionForNodes() performs the last step in the nodal
// * advance portion of the algorithm by integrating the velocity at each node
// * to advance the position of the node to tn+1.
// ****************************************************************************
nodes void calcPositionForNodes(void)
  in (node nVelocityx, node nVelocityy, node nVelocityz) @ 3.1{
  coordx += δt * nVelocityx;
  coordy += δt * nVelocityy;
  coordz += δt * nVelocityz;
}

// End of LagrangeNodal




// ****************************************************************************
// * LagrangeElements
// ****************************************************************************
cells void LagrangeElements(void)
  in (cell v, cell volo,
      node coordx, node coordy, node coordz,
      node nVelocityx, node nVelocityy, node nVelocityz)
  inout (cell vnew)
  out (cell vnew, cell delv, cell arealg, cell calc_volume, cell εx,cell εy,cell εz, cell vdov,
       cell delx_xi, cell delv_xi,
      cell delx_eta, cell delv_eta,
      cell delx_zeta, cell delv_zeta) @ 4.0{
  const Real ptiny = 1.e-36;
  aligned Real x[8];
  aligned Real xtmp[8];
  aligned Real y[8];
  aligned Real ytmp[8];
  aligned Real z[8];
  aligned Real ztmp[8];
  aligned Real xd[8] ;
  aligned Real yd[8] ;
  aligned Real zd[8] ;
  
  foreach node x[n]=xtmp[n]=coordx;
  foreach node y[n]=ytmp[n]=coordy;
  foreach node z[n]=ztmp[n]=coordz;
 
  calc_volume = _calcElemVolume(x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7],
                                y[0], y[1], y[2], y[3], y[4], y[5], y[6], y[7],
                                z[0], z[1], z[2], z[3], z[4], z[5], z[6], z[7]);

  {
    const Real volume=calc_volume;
    const Real relativeVolume = volume/volo;
    vnew = relativeVolume ;
    delv = relativeVolume - v;
    arealg = calcElemCharacteristicLength(x, y, z, volume);
  }
  {
    Real DetJ=0.0;
    Real D[6] ;
    Real B[3][8] ; // shape function derivatives
    const Real dt2= ½*δt;
    foreach node xd[n] = nVelocityx;
    foreach node yd[n] = nVelocityy;
    foreach node zd[n] = nVelocityz;
    
    foreach node {
      xtmp[n] -= dt2*xd[n];
      ytmp[n] -= dt2*yd[n];
      ztmp[n] -= dt2*zd[n];
    }
    calcElemShapeFunctionDerivatives(xtmp,ytmp,ztmp,B[0],B[1],B[2], &DetJ);
    CalcElemVelocityGradient(xd,yd,zd,B,DetJ,D);
    εx = D[0];
    εy = D[1];
    εz = D[2];
  }
  vdov = εx+εy+εz;
  εx -= ⅓*vdov;
  εy -= ⅓*vdov;
  εz -= ⅓*vdov;

  {
    const Real vol = volo*vnew;
    const Real nrm = 1.0/( vol + ptiny ) ;
    const Real dxj = -¼*(sum4(x[0],x[1],x[5],x[4]) - sum4(x[3],x[2],x[6],x[7])) ;
    const Real dyj = -¼*(sum4(y[0],y[1],y[5],y[4]) - sum4(y[3],y[2],y[6],y[7])) ;
    const Real dzj = -¼*(sum4(z[0],z[1],z[5],z[4]) - sum4(z[3],z[2],z[6],z[7])) ;
    
    const Real dxi =  ¼*(sum4(x[1],x[2],x[6],x[5]) - sum4(x[0],x[3],x[7],x[4])) ;
    const Real dyi =  ¼*(sum4(y[1],y[2],y[6],y[5]) - sum4(y[0],y[3],y[7],y[4])) ;
    const Real dzi =  ¼*(sum4(z[1],z[2],z[6],z[5]) - sum4(z[0],z[3],z[7],z[4])) ;
    
    const Real dxk =  ¼*(sum4(x[4],x[5],x[6],x[7]) - sum4(x[0],x[1],x[2],x[3])) ;
    const Real dyk =  ¼*(sum4(y[4],y[5],y[6],y[7]) - sum4(y[0],y[1],y[2],y[3])) ;
    const Real dzk =  ¼*(sum4(z[4],z[5],z[6],z[7]) - sum4(z[0],z[1],z[2],z[3])) ;
    {
      // find delvk and delxk ( i cross j )
      const Real a_zetax=dyi*dzj - dzi*dyj ;//(di⨯dj);
      const Real a_zetay=dzi*dxj - dxi*dzj ;//(di⨯dj);
      const Real a_zetaz=dxi*dyj - dyi*dxj ;//(di⨯dj);
      const Real dv_zetax = ¼*(sum4(xd[4],xd[5],xd[6],xd[7]) -sum4(xd[0],xd[1],xd[2],xd[3]));
      const Real dv_zetay = ¼*(sum4(yd[4],yd[5],yd[6],yd[7]) -sum4(yd[0],yd[1],yd[2],yd[3]));
      const Real dv_zetaz = ¼*(sum4(zd[4],zd[5],zd[6],zd[7]) -sum4(zd[0],zd[1],zd[2],zd[3]));
      delx_zeta = vol/√((a_zetax*a_zetax+a_zetay*a_zetay+a_zetaz*a_zetaz) + ptiny) ;
      delv_zeta = (a_zetax*nrm)*dv_zetax+(a_zetay*nrm)*dv_zetay+(a_zetaz*nrm)*dv_zetaz;
      //debug()<<"calcMonotonicQGradientsForElems delv_z="<<delv_zeta;
    }
    {
      // find delxi and delvi ( j cross k )
      const Real a_xix= dyj*dzk - dzj*dyk ;//(dj⨯dk);
      const Real a_xiy= dzj*dxk - dxj*dzk ;//(dj⨯dk);
      const Real a_xiz= dxj*dyk - dyj*dxk ;//(dj⨯dk);
      const Real dv_xix = ¼*(sum4(xd[1],xd[2],xd[6],xd[5]) - sum4(xd[0],xd[3],xd[7],xd[4])) ;
      const Real dv_xiy = ¼*(sum4(yd[1],yd[2],yd[6],yd[5]) - sum4(yd[0],yd[3],yd[7],yd[4])) ;
      const Real dv_xiz = ¼*(sum4(zd[1],zd[2],zd[6],zd[5]) - sum4(zd[0],zd[3],zd[7],zd[4])) ;
      delx_xi = vol/√((a_xix*a_xix+a_xiy*a_xiy+a_xiz*a_xiz) + ptiny) ;
      delv_xi = (a_xix*nrm)*dv_xix+(a_xiy*nrm)*dv_xiy+(a_xiz*nrm)*dv_xiz;
      //debug()<<"calcMonotonicQGradientsForElems delv_x="<<delv_xi;
    }
    {
      // find delxj and delvj ( k cross i )
      const Real a_etax =dyk*dzi - dzk*dyi ;//(dk⨯di);
      const Real a_etay =dzk*dxi - dxk*dzi ;//(dk⨯di);
      const Real a_etaz =dxk*dyi - dyk*dxi ;//(dk⨯di);
      const Real dv_etax = -¼*(sum4(xd[0],xd[1],xd[5],xd[4]) - sum4(xd[3],xd[2],xd[6],xd[7])) ;
      const Real dv_etay = -¼*(sum4(yd[0],yd[1],yd[5],yd[4]) - sum4(yd[3],yd[2],yd[6],yd[7])) ;
      const Real dv_etaz = -¼*(sum4(zd[0],zd[1],zd[5],zd[4]) - sum4(zd[3],zd[2],zd[6],zd[7])) ;
      delx_eta = vol/√(a_etax*a_etax+a_etay*a_etay+a_etaz*a_etaz + ptiny) ;
      delv_eta = (a_etax*nrm)*dv_etax+(a_etay*nrm)*dv_etay+(a_etaz*nrm)*dv_etaz;
      //debug()<<"calcMonotonicQGradientsForElems delv_e="<<delv_eta;
    }
  }
}





// ****************************************************************************
// * The routine CalcMonotonicQForElems() (==CalcMonotonicQRegionForElems)
// * performs the second part of the q calculation.
// * This routine calls CalcMonotonicQRegionForElems() which uses the spatial
// * gradient information computed earlier to compute linear and quadratic
// * terms for q, qlin and qquad, respectively.
// * The actual element values of q are calculated during the application of
// * material properties in each element.
// ****************************************************************************
cells void calcMonotonicQForElemsByDirectionX(xyz direction)
  in (cell elemBC, cell delv_xi, cell phixi){
  const Real monoq_limiter_mult = option_monoq_limiter_mult;
  const Real monoq_max_slope = option_monoq_max_slope;
  Integer bcSwitch;
  aligned Real register delvm=0.0;
  aligned Real register delvp=0.0;
  const Real ptiny = 1.e-36;
  const Real nrm = 1./(delv_xi+ptiny);
  {
    bcSwitch = elemBC & XI_M;
    delvm = (bcSwitch == 0)?delv_xi[prevCell];//lxim
    delvm = (bcSwitch == XI_M_SYMM)?delv_xi;
    delvm = (bcSwitch == XI_M_FREE)?0.0;
    delvm = delvm * nrm ;
  }
  {
    bcSwitch = elemBC & XI_P;
    delvp = (bcSwitch == 0)?delv_xi[nextCell];//lxip
    delvp = (bcSwitch == XI_P_SYMM)?delv_xi;
    delvp = (bcSwitch == XI_P_FREE)?0.0;
    delvp = delvp * nrm ;
  }
  {
    phixi = ½ * (delvm + delvp) ;
    delvm *= monoq_limiter_mult ;
    delvp *= monoq_limiter_mult ;
    phixi = (delvm < phixi)?delvm;
    phixi = (delvp < phixi)?delvp;
    phixi = (phixi < 0.)?0.0;
    phixi = (phixi > monoq_max_slope)?monoq_max_slope;
  }
}

cells void calcMonotonicQForElemsByDirectionY(xyz direction)
  in (cell elemBC, cell delv_eta, cell phieta){
  const Real monoq_limiter_mult = option_monoq_limiter_mult;
  const Real monoq_max_slope = option_monoq_max_slope;
  Integer register bcSwitch;
  aligned Real register delvm=0.;
  aligned Real register delvp=0.;
  const Real ptiny = 1.e-36;
  const Real nrm = 1./(delv_eta+ptiny);
  {
    bcSwitch = elemBC & ETA_M;
    delvm = (bcSwitch == 0)?delv_eta[prevCell];//letam
    delvm = (bcSwitch == ETA_M_SYMM)?delv_eta;
    delvm = (bcSwitch == ETA_M_FREE)?0.0;
    delvm = delvm * nrm ;
  }
  {
    bcSwitch = elemBC & ETA_P;
    delvp = (bcSwitch == 0)?delv_eta[nextCell];//letap
    delvp = (bcSwitch == ETA_P_SYMM)?delv_eta;
    delvp = (bcSwitch == ETA_P_FREE)?0.0;
    delvp = delvp * nrm ;
  }
  phieta = ½*(delvm + delvp) ;
  delvm *= monoq_limiter_mult ;
  delvp *= monoq_limiter_mult ;
  phieta = (delvm  < phieta)?delvm;
  phieta = (delvp  < phieta)?delvp;
  phieta = (phieta < 0.0)?0.0;
  phieta = (phieta > monoq_max_slope)?monoq_max_slope;
}

cells void calcMonotonicQForElemsByDirectionZ(xyz direction)
  in (cell elemBC, cell delv_zeta, cell phizeta){
  const Real monoq_limiter_mult = option_monoq_limiter_mult;
  const Real monoq_max_slope = option_monoq_max_slope;
  Integer bcSwitch;
  aligned Real delvm=0.;
  aligned Real delvp=0.;
  const Real ptiny = 1.e-36;
  const Real nrm = 1./(delv_zeta+ptiny) ;
  {
    bcSwitch = elemBC & ZETA_M;
    delvm = (bcSwitch == 0)?delv_zeta[prevCell];//lzetam
    delvm = (bcSwitch == ZETA_M_SYMM)?delv_zeta;
    delvm = (bcSwitch == ZETA_M_FREE)?0.0;
    delvm = delvm * nrm ;
  }
  {
    bcSwitch = elemBC & ZETA_P;
    delvp = (bcSwitch == 0)?delv_zeta[nextCell];//lzetap
    delvp = (bcSwitch == ZETA_P_SYMM)?delv_zeta;
    delvp = (bcSwitch == ZETA_P_FREE)?0.0;
    delvp = delvp * nrm ;
  }
  phizeta = ½*(delvm+delvp);
  delvm *= monoq_limiter_mult ;
  delvp *= monoq_limiter_mult ;
  phizeta = (delvm < phizeta )?delvm;
  phizeta = (delvp < phizeta )?delvp;
  phizeta = (phizeta < 0.0)?0.0;
  phizeta = (phizeta > monoq_max_slope )?monoq_max_slope;
}


void calcMonotonicQForElems(void) @ 4.7{
  calcMonotonicQForElemsByDirectionX(MD_DirX);
  calcMonotonicQForElemsByDirectionY(MD_DirY);
  calcMonotonicQForElemsByDirectionZ(MD_DirZ);
}


cells void calcMonotonicQForElemsQQQL(void)
  in (cell vdov, cell elemMass, cell volo, cell vnew,
      cell  delx_xi, cell delv_eta, cell delx_eta,
      cell delv_zeta, cell delx_zeta, cell delv_xi,
      cell phixi, cell phieta, cell phizeta)
  out(cell qq, cell ql)@ 4.72{
  const Real qlc_monoq = option_qlc_monoq;
  const Real qqc_monoq = option_qqc_monoq;
  const Real rho = elemMass/(volo*vnew);
  const Real delvxxi   = delv_xi   * delx_xi   ;
  const Real delvxeta  = delv_eta  * delx_eta  ;
  const Real delvxzeta = delv_zeta * delx_zeta ;
  const Real delvxxit   = ( delvxxi   > 0.)?0.:delvxxi;
  const Real delvxetat  = ( delvxeta  > 0.)?0.:delvxeta;
  const Real delvxzetat = ( delvxzeta > 0.)?0.:delvxzeta;
  const Real qlin = -qlc_monoq * rho * (delvxxit*(1.0-phixi)
                                        +delvxetat*(1.0-phieta)
                                        +delvxzetat*(1.0-phizeta));
  const Real qquad = qqc_monoq * rho *
    ( delvxxit*delvxxit     * (1.0 - phixi*phixi) +
      delvxetat*delvxetat   * (1.0 - phieta*phieta) +
      delvxzetat*delvxzetat * (1.0 - phizeta*phizeta)  ) ;
  // Remove length scale
  const Real qlint  = ( vdov > 0.)?0.:qlin;
  const Real qquadt = ( vdov > 0.)?0.:qquad;
  qq = qquadt ;
  ql = qlint  ;
  //debug()<<"calcMonotonicQForElems ql="<<ql<<", qq="<<qq;
}






// ****************************************************************************
// * The routine ApplyMaterialPropertiesForElems() updates the pressure and
// * internal energy variables to their values at the new time, p_n+1 and e_n+1.
// * The routine first initializes a temporary array with the values of Vn+1 for
// * each element that was computed earlier. Then, upper and lower cut-off
// * values are applied to each array value to keep the relative volumes
// * within a prescribed range (not too close to zero and not too large).
// * Next, the routine EvalEOSForElems() is called and the array of modified
// * relative element volumes is passed to it.
// ****************************************************************************
cells void applyMaterialPropertiesForElems0(void)
  in (cell vnew) out(cell vnewc)@ 5.0{
  vnewc = vnew ;
}
cells void applyMaterialPropertiesForElems1(void)
  inout(cell vnewc) @ 5.1{
  vnewc = (vnewc < option_eosvmin)?option_eosvmin;
}
cells void applyMaterialPropertiesForElems2(void)
  inout (cell vnewc)@ 5.2{
  vnewc = (vnewc > option_eosvmax)?option_eosvmax;
}
cells void applyMaterialPropertiesForElems3(void) in (cell v) @ 5.3{
  Real vc = v ;
  vc = (vc < option_eosvmin)?option_eosvmin;
  vc = (vc > option_eosvmax)?option_eosvmax;
}


// ****************************************************************************
// * The routine EvalEOSForElems() calculates updated values for pressure p_n+1
// * and internal energy e_n+1.
// * The computation involves several loops over elements to pack various mesh
// * element arrays (e.g., p, e, q, etc.) into local temporary arrays.
// * Several other quantities are computed and stored in element length
// * temporary arrays also.
// * The temporary arrays are needed because the routine CalcEnergyForElems()
// * calculates p_n+1 and e_n+1 in each element in an iterative process that
// * requires knowledge of those variables at time tn while it computes the
// * new time values.
// ****************************************************************************
cells void evalEOSForElems0(void)
  in (cell e, cell delv, cell p, cell q, cell vnewc)
  out(cell e_old, cell delvc, cell p_old, cell q_old,
      cell compression, cell compHalfStep) @ 6.02{
  e_old = e;
  delvc = delv;
  p_old = p;
  q_old = q ;
  compression = (1.0/vnewc) - 1.0;
  {
    const Real vchalf = vnewc - ( ½*delvc);
    compHalfStep = (1.0/vchalf)-1.0;
  }
}
cells void evalEOSForElems1(void)
  in (cell vnewc, cell compression)
  out(cell compHalfStep)@ 6.1 {
  compHalfStep = (vnewc <= option_eosvmin)?compression;
}
cells void evalEOSForElems6(void)
  in (cell vnewc, cell compHalfStep)
  out(cell p_old, cell compression) @ 6.6 {
  p_old = (vnewc < option_eosvmax)?p_old:0.0;
  compression =(vnewc < option_eosvmax)?compression:0.0;
  compHalfStep = (vnewc < option_eosvmax)?compHalfStep:0.0;
}
cells void evalEOSForElems7(void) out(cell work)@ 6.7 {
  work = 0.0; 
}



// ****************************************************************************
// * The routine CalcEnergyForElems() calls CalcPressureForElems() repeatedly.
// * The function CalcPressureForElems() is the Equation of State model
// * for a "gamma law" gas.
// * The value c1s passed to the routine is defined to be γ - 1.
// * The Equation of State calculation is a core part of any hydrocode.
// * In a production code, one of any number of Equation of State functions
// * may be called to generate a pressure that is needed to close the system
// * of equations and generate a unique solution.
// ****************************************************************************
// @ 7.1   calcEnergyForElems1
cells void calcEnergyForElems1(void)
  in (cell e_old, cell delvc, cell p_old, cell q_old, cell work)
  inout (cell e_new)@ 7.1{
  e_new = e_old - ½*delvc*(p_old + q_old) + ½*work;
  e_new = (e_new < option_emin)?option_emin;
}


// ****************************************************************************
// * calcPressureForElems
// * p_new => pHalfStep
// * compression => compHalfStep
// * e_old => e_new
// ****************************************************************************
// @ 7.2   calcPressureForElemspHalfStepcompHalfStep
cells void calcPressureForElemspHalfStepcompHalfStep(void)
  in (cell compHalfStep, cell bvc, cell e_new, cell vnewc)
  inout(cell pHalfStep)
  out (cell pbvc)@ 7.2{
  const Real c1s = 2.0/3.0;
  bvc = c1s*(compHalfStep+1.0);
  pbvc = c1s;
  pHalfStep = bvc*e_new ;
  pHalfStep=(rabs(pHalfStep)<option_p_cut)?0.0;
  pHalfStep = (vnewc >= option_eosvmax )?0.0; // impossible condition here?
  pHalfStep = (pHalfStep < option_pmin)?option_pmin;
}


// @ 7.3   calcEnergyForElems3
cells void calcEnergyForElems3(void)
  in (cell compHalfStep, cell delvc, cell pbvc, cell ql, cell qq,
      cell bvc, cell pHalfStep, cell p_old, cell q_old)
  out (cell q_new)
  inout (cell e_new)@ 7.3{
  const Real vhalf = 1.0/(1.0+compHalfStep);
  const Real ssc = ( pbvc*e_new + vhalf*vhalf*bvc*pHalfStep)/option_refdens ;
  const Real ssct = (ssc<=0.0)?0.333333e-36:√(ssc);
  q_new = (delvc > 0. )?0.0:(ssct*ql + qq);
  e_new = e_new + ½*delvc*(3.0*(p_old+q_old)-4.0*(pHalfStep+q_new)) ;
}

// @ 7.4   calcEnergyForElems4
cells void calcEnergyForElems4(void) in (cell work)
  inout (cell e_new)@ 7.4{
  e_new += ½*work;
  e_new = (rabs(e_new) < option_e_cut)?0.0;
  e_new = (e_new<option_emin)?option_emin;
}

// @ 7.5 CalcPressureForElems
cells void calcPressureForElemsPNewCompression(void)
  in (cell compression,
      cell bvc,
      cell e_new, cell vnewc)
  inout (cell pbvc, cell p_new) @ 7.5,7.7{
  const Real c1s = 2.0/3.0;
  bvc = c1s*(compression + 1.0);
  pbvc = c1s;
  p_new = bvc*e_new ;
  p_new = (rabs(p_new) < option_p_cut)?0.0;
  p_new = (vnewc >= option_eosvmax )?0.0;
  p_new = (p_new < option_pmin)?option_pmin;

}

// @ 7.6   calcEnergyForElems6
cells void calcEnergyForElems6(void)
  in (cell delvc, cell bvc, cell pbvc, cell vnewc, cell p_new, cell ql, cell qq,
      cell p_old, cell q_old, cell pHalfStep, cell q_new)
  inout(cell e_new)@ 7.6{
  const Real sixth = 1.0/6.0;
  const Real ssc = ( pbvc * e_new + vnewc * vnewc * bvc * p_new)/option_refdens;
  const Real ssct = (ssc <= 0.0)?0.333333e-36:√(ssc);
  const Real q_tilde = (delvc > 0.)?0.0:(ssct*ql + qq);
  e_new = e_new - (  7.0*(p_old + q_old)
                     - (8.0)*(pHalfStep + q_new)
                     + (p_new + q_tilde)) * delvc*sixth ;
  e_new = (rabs(e_new) < option_e_cut)?0.0;
  e_new = (e_new < option_emin)?option_emin;
}

// @ 7.7 CalcPressureForElems;
cells void calcEnergyForElems8(void)
  in (cell delvc, cell bvc, cell pbvc, cell e_new, cell vnewc, cell p_new, cell ql, cell qq)
  inout(cell q_new)@ 7.8{
  const Real ssc = (pbvc*e_new + vnewc*vnewc*bvc*p_new)/option_refdens;
  const Real ssct = (ssc <= 0.0)?0.333333e-36:√(ssc);
  const Real qnw = (ssct*ql+qq);
  const Real qnwt = (rabs(qnw) < option_q_cut)?0.0:qnw;
  q_new = (delvc <= 0.)?qnwt;
}

cells void evalEOSForElems8(void)
  in (cell p_new, cell e_new, cell q_new)
  out(cell p, cell e, cell q)@ 8.0{
  p = p_new;
  e = e_new;
  q = q_new;
}


// ****************************************************************************
// * Lastly, the routine CalcSoundSpeedForElems() calculates the sound speed
// * sound_speed in each element using p_n+1 and e_n+1.
// * The maximum value of sound_speed is used to calculate constraints on t_n+1
// * which will be used for the next time advance step.
// ****************************************************************************
//   CalcSoundSpeedForElems(vnewc, rho0, e_new, p_new, pbvc, bvc, ss4o3, length) ;
cells void calcSoundSpeedForElems(void)
  in (cell bvc, cell pbvc, cell e_new, cell vnewc, cell p_new)
  out (cell sound_speed) @ 9.0{
  const Real ssTmp = (pbvc*e_new + vnewc*vnewc*bvc*p_new)/option_refdens;
  const Real ssTmpt = (ssTmp <= 1.111111e-36)?1.111111e-36:ssTmp;
  sound_speed = √(ssTmpt);
}



// ****************************************************************************
// * The routine UpdateVolumesForElems() updates the relative volume to V_n+1.
// * This routine basically resets the current volume V_n in each element to
// * the new volume V_n+1 so the simulation can continue to the next time
// * increment.
// * Note that this routine applies a cut-off to the relative volume V in
// * each element. Specifically, if V is sufficiently close to one (a
// * prescribed tolerance), then V is set to one.
// * The reason for this cutoff is to prevent spurious deviations of volume
// * from their initial values which may arise due to floating point roundoff
// * error.
// ****************************************************************************
cells void updateVolumesForElems(void)
  in (cell vnew) out (cell v) @ 10.0{
  const Real tmpV = vnew;
  const Real tmpVt = (rabs(tmpV-1.0) < option_v_cut)?1.0:tmpV;
  v = tmpVt ;
}

/*

// ****************************************************************************
// * The routine CalcCourantConstraintForElems() calculates the Courant timestep
// * constraint δt_Courant. This constraint is calculated only in elements
// * whose volumes are changing that is, dV/V!=0.
// * If all element volumes remain the same, there is no Courant constraint
// * applied during the subsequent δt calculation.
// ****************************************************************************
cells Real calcCourantConstraintForElems(Real dtcourant)
  in (cell sound_speed, cell arealg, cell vdov) {
  const Real qqc2 = 64.0 * option_qqc * option_qqc ;
  const Real dtf = sound_speed * sound_speed ;
  const Real dtfp = √(dtf+((vdov<0.0)?qqc2*arealg*arealg*vdov*vdov:0.0));
  const Real adtfp = arealg/dtfp;
  dtcourant=(vdov!=0.0)?min(dtcourant,adtfp):dtcourant;
  return dtcourant;
}          


// ****************************************************************************
// * The routine CalcHydroConstraintForElems() calculates the hydro timestep
// * constraint. Similar to δt_Courant, δt_hydro is calculated only in elements
// * whose volumes are changing. When an element is undergoing volume change,
// * δt_hydro for the element is some maximum allowable element volume change
// * (prescribed) divided by dV/V in the element.
// ****************************************************************************
cells Real calcHydroConstraintForElems(Real dthydro) in (cell vdov){
  const Real denom = 1.e-20+rabs(vdov);
  const Real dtdvov = option_dvovmax / denom;
  const Real dthdr = ( dthydro > dtdvov )?dtdvov:dthydro;
  dthydro=(vdov!=0.0)?dthdr;
  return dthydro;
}


// ****************************************************************************
// * After all solution variables are advanced to t_n+1, the constraints δtCourant
// * and δthydro for the next time increment t_n+1 are calculated in this routine.
// * Each constraint is computed in each element and then the final constraint value
// * is the minimum over all element values.
// * The constraints are applied during the computation of δt for the next time step.
// ****************************************************************************
void calcTimeConstraintsForElems(void) @ 12.1{
  const Real hdr=calcHydroConstraintForElems(1.0e+20);
  const Real crnt=calcCourantConstraintForElems(1.0e+20);
  δt_courant=mpi_reduce(ReduceMin, crnt);
  δt_hydro=mpi_reduce(ReduceMin, hdr);
  //info()<<"\t\tδt_courant="<<ReduceMinToDouble(δt_courant);
  //info()<<"\t\tδt_hydro  ="<<ReduceMinToDouble(δt_hydro);
}
*/
