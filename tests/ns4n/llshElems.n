///////////////////////////////////////////////////////////////////////////////
// NABLA - a Numerical Analysis Based LAnguage                               //
//                                                                           //
// Copyright (C) 2014~2017 CEA/DAM/DIF                                       //
// IDDN.FR.001.520002.000.S.P.2014.000.10500                                 //
//                                                                           //
// Contributor(s): CAMIER Jean-Sylvain - Jean-Sylvain.Camier@cea.fr          //
//                                                                           //
// This software is a computer program whose purpose is to translate         //
// numerical-analysis specific sources and to generate optimized code        //
// for different targets and architectures.                                  //
//                                                                           //
// This software is governed by the CeCILL license under French law and      //
// abiding by the rules of distribution of free software. You can  use,      //
// modify and/or redistribute the software under the terms of the CeCILL     //
// license as circulated by CEA, CNRS and INRIA at the following URL:        //
// "http://www.cecill.info".                                                 //
//                                                                           //
// The CeCILL is a free software license, explicitly compatible with         //
// the GNU GPL.                                                              //
//                                                                           //
// As a counterpart to the access to the source code and rights to copy,     //
// modify and redistribute granted by the license, users are provided only   //
// with a limited warranty and the software's author, the holder of the      //
// economic rights, and the successive licensors have only limited liability.//
//                                                                           //
// In this respect, the user's attention is drawn to the risks associated    //
// with loading, using, modifying and/or developing or reproducing the       //
// software by the user in light of its specific status of free software,    //
// that may mean that it is complicated to manipulate, and that also         //
// therefore means that it is reserved for developers and experienced        //
// professionals having in-depth computer knowledge. Users are therefore     //
// encouraged to load and test the software's suitability as regards their   //
// requirements in conditions enabling the security of their systems and/or  //
// data to be ensured and, more generally, to use and operate it in the      //
// same conditions as regards security.                                      //
//                                                                           //
// The fact that you are presently reading this means that you have had      //
// knowledge of the CeCILL license and that you accept its terms.            //
//                                                                           //
// See the LICENSE file for details.                                         //
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// * Defines
// ****************************************************************************
#define XI_M        0x003
#define XI_M_SYMM   0x001
#define XI_M_FREE   0x002
#define XI_P        0x00C
#define XI_P_SYMM   0x004
#define XI_P_FREE   0x008
#define ETA_M       0x030
#define ETA_M_SYMM  0x010
#define ETA_M_FREE  0x020
#define ETA_P       0x0C0
#define ETA_P_SYMM  0x040
#define ETA_P_FREE  0x080
#define ZETA_M      0x300
#define ZETA_M_SYMM 0x100
#define ZETA_M_FREE 0x200
#define ZETA_P      0xC00
#define ZETA_P_SYMM 0x400
#define ZETA_P_FREE 0x800


// ****************************************************************************
// * Set up boundary condition information
// * Set up elemement connectivity information
// ****************************************************************************
‚àÄ cells @ -9.5{
  const ‚Ñù zero = 0.0;
  const ‚Ñù maxBoundaryX = LENGTH;//X_EDGE_TICK*X_EDGE_ELEMS;
  const ‚Ñù maxBoundaryY = LENGTH;//Y_EDGE_TICK*Y_EDGE_ELEMS;
  const ‚Ñù maxBoundaryZ = LENGTH;//Z_EDGE_TICK*Z_EDGE_ELEMS;
  elemBC=0;
  ‚àÄ node{
    elemBC |= (coord.x==zero)?XI_M_SYMM;
    elemBC |= (coord.y==zero)?ETA_M_SYMM;
    elemBC |= (coord.z==zero)?ZETA_M_SYMM;
    elemBC |= (coord.x==maxBoundaryX)?XI_P_FREE;
    elemBC |= (coord.y==maxBoundaryY)?ETA_P_FREE;
    elemBC |= (coord.z==maxBoundaryZ)?ZETA_P_FREE;
  }
}

// ****************************************************************************
// * Cells initialization
// ****************************************************************************
‚àÄ cells @ -8.0{
  ‚Ñù¬≥ X[8];
  const ‚Ñù chaos = (((‚Ñù)uid)+1.0)*option_chaos_seed;
  v=1.0;
  ‚àÄ node X[n]=coord;
  e=(option_chaos)?chaos:(uid==0)?option_initial_energy:0.0;
  sound_speed=p=q=(option_chaos)?chaos;
  volo=elemMass=calc_volume=computeElemVolume(X);
}

// ****************************************************************************
// * Sum contributions to total stress tensor
// * pull in the stresses appropriate to the hydro integration
// * Initialize stress terms for each element. Recall that our assumption of
// * an inviscid isotropic stress tensor implies that the three principal
// * stress components are equal, and the shear stresses are zero.
// * Thus, we initialize the diagonal terms of the stress tensor to
// * -(p + q) in each element.
// ****************************************************************************
‚àÄ cells @ 0.3 {
  const ‚Ñù chaos = (((‚Ñù)0.0)+1.0)*option_chaos_seed;
  const ‚Ñù sig = (option_chaos)?chaos:-p-q;
  ‚Ñù¬≥ fNormals,dj,x[8],B[8];
  ‚àÄ node x[n] = coord;
  Œµ = dj = -¬º*((x[0]+x[1]+x[5]+x[4])-(x[3]+x[2]+x[6]+x[7]));
  calcElemShapeFunctionDerivatives(x,B);
  ‚àÄ node B[n]=0.0;
  Œ£_FaceNormal(B,0,1,2,3,x);
  Œ£_FaceNormal(B,0,4,5,1,x);
  Œ£_FaceNormal(B,1,5,6,2,x);
  Œ£_FaceNormal(B,2,6,7,3,x);
  Œ£_FaceNormal(B,3,7,4,0,x);
  Œ£_FaceNormal(B,4,7,6,5,x);
  ‚àÄ node cForce = -sig*B[n];
}

// ****************************************************************************
// * calcFBHourglassForceForElems
// * Calculates the Flanagan-Belytschko anti-hourglass force
// * calcFBHourglassForceForElems
// ****************************************************************************
‚àÄ cells @ 1.3{
  const ‚Ñù Œ≥[4][8]={{ 1., 1.,-1.,-1.,-1.,-1., 1., 1.},
                      { 1.,-1.,-1., 1.,-1., 1., 1.,-1.},
                      { 1.,-1., 1.,-1., 1.,-1., 1.,-1.},
                      {-1., 1.,-1., 1., 1.,-1., 1.,-1.}};
  ‚Ñù Œ∑0[4],Œ∑1[4],Œ∑2[4],Œ∑3[4] ;
  ‚Ñù Œ∑4[4],Œ∑5[4],Œ∑6[4],Œ∑7[4];
  ‚Ñù¬≥ x[8],xd[8],dvd[8],Œ∑[8];
  const ‚Ñù hourg=option_hgcoef;
  const ‚Ñù œÑv = volo*v;
  const ‚Ñù volume13=‚àõ(œÑv);
  const ‚Ñù Œ∏ = -hourg*0.01*sound_speed*elemMass/volume13;
  const ‚Ñù determ = œÑv;
  //const ‚Ñù chaos = (((‚Ñù)uid)+1.0)*option_chaos_seed;
  ‚àÄ node x[n] = coord;
  //‚àÄ node xd[n] = (option_chaos)?chaos:ùúïx;  
  ‚àÄ node xd[n] = ùúïx;
  dvd[0]=ùúïVolume(x[1],x[2],x[3],x[4],x[5],x[7]);
  dvd[3]=ùúïVolume(x[0],x[1],x[2],x[7],x[4],x[6]);
  dvd[2]=ùúïVolume(x[3],x[0],x[1],x[6],x[7],x[5]);
  dvd[1]=ùúïVolume(x[2],x[3],x[0],x[5],x[6],x[4]);
  dvd[4]=ùúïVolume(x[7],x[6],x[5],x[0],x[3],x[1]);
  dvd[5]=ùúïVolume(x[4],x[7],x[6],x[1],x[0],x[2]);
  dvd[6]=ùúïVolume(x[5],x[4],x[7],x[2],x[1],x[3]);
  dvd[7]=ùúïVolume(x[6],x[5],x[4],x[3],x[2],x[0]);
  cHourglassModes(0,determ,dvd,Œ≥,x,Œ∑0,Œ∑1,Œ∑2,Œ∑3,Œ∑4,Œ∑5,Œ∑6,Œ∑7);
  cHourglassModes(1,determ,dvd,Œ≥,x,Œ∑0,Œ∑1,Œ∑2,Œ∑3,Œ∑4,Œ∑5,Œ∑6,Œ∑7);
  cHourglassModes(2,determ,dvd,Œ≥,x,Œ∑0,Œ∑1,Œ∑2,Œ∑3,Œ∑4,Œ∑5,Œ∑6,Œ∑7);
  cHourglassModes(3,determ,dvd,Œ≥,x,Œ∑0,Œ∑1,Œ∑2,Œ∑3,Œ∑4,Œ∑5,Œ∑6,Œ∑7);
  calcElemFBHourglassForce(xd,Œ∑0,Œ∑1,Œ∑2,Œ∑3,Œ∑4,Œ∑5,Œ∑6,Œ∑7,Œ∏,Œ∑);
  ‚àÄ node cForce = Œ∑[n];
}

// ****************************************************************************
// * calcElemVolume
// ****************************************************************************
‚àÄ cells @ 4.0{
  const ‚Ñù dt2= ¬Ω*Œ¥t;
  const ‚Ñù Œ¥ = 1.e-36;
  ‚Ñù¬≥ B[8],X[8],Xd[8];
  ‚Ñù DetJ,volume,œÅVolume;
  ‚àÄ node X[n]=coord;
  ‚àÄ node Xd[n]=ùúïx;
  volume = calc_volume = computeElemVolume(X);  
  vnew = œÅVolume = volume/volo;
  delv = œÅVolume - v;
  arealg = calcElemCharacteristicLength(X,volume);
  const ‚Ñù vol = volo*vnew;
  const ‚Ñù nrm = 1.0/(vol+Œ¥);
  const ‚Ñù¬≥ di =  ¬º*((X[1]+X[2]+X[6]+X[5])-(X[0]+X[3]+X[7]+X[4]));
  const ‚Ñù¬≥ dj = -¬º*((X[0]+X[1]+X[5]+X[4])-(X[3]+X[2]+X[6]+X[7]));
  const ‚Ñù¬≥ dk =  ¬º*((X[4]+X[5]+X[6]+X[7])-(X[0]+X[1]+X[2]+X[3]));
  const ‚Ñù¬≥ a_xi = (dj‚®Ødk);
  const ‚Ñù¬≥ a_eta = (dk‚®Ødi);
  const ‚Ñù¬≥ a_zeta = (di‚®Ødj);
  const ‚Ñù¬≥ dv_xi  =  ¬º*((Xd[1]+Xd[2]+Xd[6]+Xd[5])-(Xd[0]+Xd[3]+Xd[7]+Xd[4]));
  const ‚Ñù¬≥ dv_eta = -¬º*((Xd[0]+Xd[1]+Xd[5]+Xd[4])-(Xd[3]+Xd[2]+Xd[6]+Xd[7]));
  const ‚Ñù¬≥ dv_zeta = ¬º*((Xd[4]+Xd[5]+Xd[6]+Xd[7])-(Xd[0]+Xd[1]+Xd[2]+Xd[3]));
  delx_xi = vol/‚àö(a_xi‚ãÖa_xi+Œ¥);
  delx_eta = vol/‚àö(a_eta‚ãÖa_eta+Œ¥);
  delx_zeta = vol/‚àö(a_zeta‚ãÖa_zeta+Œ¥);
  delv_zeta = (a_zeta*nrm)‚ãÖdv_zeta;     
  delv_xi = (a_xi*nrm)‚ãÖdv_xi;
  delv_eta = (a_eta*nrm)‚ãÖdv_eta;
  ‚àÄ node X[n] -= dt2*Xd[n];
  DetJ=calcElemShapeFunctionDerivatives(X,B);
  Œµ=calcElemVelocityGradient(Xd,B,DetJ);
  vdov = Œµ.x+Œµ.y+Œµ.z;
  Œµ -= ‚Öì*vdov;
}

// ****************************************************************************
// * This routine performs the second part of the q calculation.
// ****************************************************************************
‚àÄ cells @ 4.7{
  const ‚Ñù monoq_limiter_mult = option_monoq_limiter_mult;
  const ‚Ñù monoq_max_slope = option_monoq_max_slope;
  ‚Ñ§ bcSwitch;
  ‚Ñù delvm=0.0;
  ‚Ñù delvp=0.0;
  const ‚Ñù ptiny = 1.e-36;
  const ‚Ñù nrm = 1./(delv_xi+ptiny);
  bcSwitch = elemBC & XI_M;
  delvm = (bcSwitch == 0)?delv_xi[prevCellX];
  delvm = (bcSwitch == XI_M_SYMM)?delv_xi;
  delvm = (bcSwitch == XI_M_FREE)?0.0;
  delvm = delvm * nrm ;
  bcSwitch = elemBC & XI_P;
  delvp = (bcSwitch == 0)?delv_xi[nextCellX];
  delvp = (bcSwitch == XI_P_SYMM)?delv_xi;
  delvp = (bcSwitch == XI_P_FREE)?0.0;
  delvp = delvp * nrm ;
  phixi = ¬Ω * (delvm + delvp) ;
  delvm *= monoq_limiter_mult ;
  delvp *= monoq_limiter_mult ;
  phixi = (delvm < phixi)?delvm;
  phixi = (delvp < phixi)?delvp;
  phixi = (phixi < 0.)?0.0;
  phixi = (phixi > monoq_max_slope)?monoq_max_slope;
}

‚àÄ cells @ 4.7 {
  const ‚Ñù monoq_limiter_mult = option_monoq_limiter_mult;
  const ‚Ñù monoq_max_slope = option_monoq_max_slope;
  ‚Ñ§ register bcSwitch;
  ‚Ñù register delvm=0.;
  ‚Ñù register delvp=0.;
  const ‚Ñù ptiny = 1.e-36;
  const ‚Ñù nrm = 1./(delv_eta+ptiny);
  bcSwitch = elemBC & ETA_M;
  delvm = (bcSwitch == 0)?delv_eta[prevCellY];
  delvm = (bcSwitch == ETA_M_SYMM)?delv_eta;
  delvm = (bcSwitch == ETA_M_FREE)?0.0;
  delvm = delvm * nrm ;
  bcSwitch = elemBC & ETA_P;
  delvp = (bcSwitch == 0)?delv_eta[nextCellY];
  delvp = (bcSwitch == ETA_P_SYMM)?delv_eta;
  delvp = (bcSwitch == ETA_P_FREE)?0.0;
  delvp = delvp * nrm ;
  phieta = ¬Ω*(delvm + delvp) ;
  delvm *= monoq_limiter_mult ;
  delvp *= monoq_limiter_mult ;
  phieta = (delvm  < phieta)?delvm;
  phieta = (delvp  < phieta)?delvp;
  phieta = (phieta < 0.0)?0.0;
  phieta = (phieta > monoq_max_slope)?monoq_max_slope;
}

‚àÄ cells @ 4.7 {
  const ‚Ñù monoq_limiter_mult = option_monoq_limiter_mult;
  const ‚Ñù monoq_max_slope = option_monoq_max_slope;
  ‚Ñ§ bcSwitch;
  ‚Ñù delvm=0.;
  ‚Ñù delvp=0.;
  const ‚Ñù ptiny = 1.e-36;
  const ‚Ñù nrm = 1./(delv_zeta+ptiny) ;
  bcSwitch = elemBC & ZETA_M;
  delvm = (bcSwitch == 0)?delv_zeta[prevCellZ];
  delvm = (bcSwitch == ZETA_M_SYMM)?delv_zeta;
  delvm = (bcSwitch == ZETA_M_FREE)?0.0;
  delvm = delvm * nrm ;
  bcSwitch = elemBC & ZETA_P;
  delvp = (bcSwitch == 0)?delv_zeta[nextCellZ];
  delvp = (bcSwitch == ZETA_P_SYMM)?delv_zeta;
  delvp = (bcSwitch == ZETA_P_FREE)?0.0;
  delvp = delvp * nrm ;
  phizeta = ¬Ω*(delvm+delvp);
  delvm *= monoq_limiter_mult ;
  delvp *= monoq_limiter_mult ;
  phizeta = (delvm < phizeta )?delvm;
  phizeta = (delvp < phizeta )?delvp;
  phizeta = (phizeta < 0.0)?0.0;
  phizeta = (phizeta > monoq_max_slope )?monoq_max_slope;
}


‚àÄ cells @ 4.72{
  const ‚Ñù rho = elemMass/(volo*vnew);
  const ‚Ñù qlc_monoq = option_qlc_monoq;
  const ‚Ñù qqc_monoq = option_qqc_monoq;
  const ‚Ñù delvxxi   = delv_xi*delx_xi;
  const ‚Ñù delvxeta  = delv_eta*delx_eta;
  const ‚Ñù delvxzeta = delv_zeta*delx_zeta;
  const ‚Ñù delvxxit  = (delvxxi>0.0)?0.0:delvxxi;
  const ‚Ñù delvxetat = (delvxeta>0.0)?0.0:delvxeta;
  const ‚Ñù delvxzetat= (delvxzeta>0.0)?0.0:delvxzeta;
  const ‚Ñù qlin = -qlc_monoq*rho*(delvxxit*(1.0-phixi)+
                                    delvxetat*(1.0-phieta)+
                                    delvxzetat*(1.0-phizeta));
  const ‚Ñù qquad = qqc_monoq*rho*(delvxxit*delvxxit*(1.0-phixi*phixi) +
                                    delvxetat*delvxetat*(1.0-phieta*phieta) +
                                    delvxzetat*delvxzetat*(1.0-phizeta*phizeta));
  const ‚Ñù qlint  = (vdov>0.0)?0.0:qlin; 
  const ‚Ñù qquadt = (vdov>0.0)?0.0:qquad;
  qq = qquadt;
  ql = qlint;
}

// ****************************************************************************
// * The routine ApplyMaterialPropertiesForElems() updates the pressure and
// * internal energy variables to their values at the new time, p_n+1 and e_n+1.
// * The routine first initializes a temporary array with the values of Vn+1 for
// * each element that was computed earlier. Then, upper and lower cut-off
// * values are applied to each array value to keep the relative volumes
// * within a prescribed range (not too close to zero and not too large).
// * Next, the routine EvalEOSForElems() is called and the array of modified
// * relative element volumes is passed to it.
// ****************************************************************************
‚àÄ cells @ 5.0{
  vnewc = vnew ;
  vnewc = (vnewc < option_eosvmin)?option_eosvmin;
  vnewc = (vnewc > option_eosvmax)?option_eosvmax;
}


// ****************************************************************************
// * The routine EvalEOSForElems() calculates updated values for pressure p_n+1
// * and internal energy e_n+1.
// * The computation involves several loops over elements to pack various mesh
// * element arrays (e.g., p, e, q, etc.) into local temporary arrays.
// * Several other quantities are computed and stored in element length
// * temporary arrays also.
// * The temporary arrays are needed because the routine CalcEnergyForElems()
// * calculates p_n+1 and e_n+1 in each element in an iterative process that
// * requires knowledge of those variables at time tn while it computes the
// * new time values.
// ****************************************************************************
‚àÄ cells @ 6.0{
  const ‚Ñù vchalf = vnewc - ( ¬Ω*delv);
  work = 0.0; 
  e_old = e;
  delvc = delv;
  p_old = p;
  q_old = q ;
  compression = (1.0/vnewc) - 1.0;
  compHalfStep = (1.0/vchalf)-1.0;
}

‚àÄ cells @ 6.1 {
  compHalfStep = (vnewc <= option_eosvmin)?compression;
}

‚àÄ cells @ 6.6 {
  p_old = (vnewc < option_eosvmax)?p_old:0.0;
  compression =(vnewc < option_eosvmax)?compression:0.0;
  compHalfStep = (vnewc < option_eosvmax)?compHalfStep:0.0;
}

// ****************************************************************************
// * The routine CalcEnergyForElems() calls CalcPressureForElems() repeatedly.
// * The function CalcPressureForElems() is the Equation of State model
// * for a "gamma law" gas.
// * The value c1s passed to the routine is defined to be Œ≥ - 1.
// * The Equation of State calculation is a core part of any hydrocode.
// * In a production code, one of any number of Equation of State functions
// * may be called to generate a pressure that is needed to close the system
// * of equations and generate a unique solution.
// ****************************************************************************
// @ 7.1   calcEnergyForElems1
‚àÄ cells @ 7.1{
  e_new = e_old - ¬Ω*delvc*(p_old + q_old) + ¬Ω*work;
  e_new = (e_new < option_emin)?option_emin;
}

// ****************************************************************************
// * calcPressureForElems
// * p_new => pHalfStep
// * compression => compHalfStep
// * e_old => e_new
// ****************************************************************************
‚àÄ cells @ 7.2{
  const ‚Ñù c1s = 2.0/3.0;
  bvc = c1s*(compHalfStep+1.0);
  pbvc = c1s;
  pHalfStep = bvc*e_new ;
  pHalfStep=(rabs(pHalfStep)<option_p_cut)?0.0;
  pHalfStep = (vnewc >= option_eosvmax )?0.0;
  pHalfStep = (pHalfStep < option_pmin)?option_pmin;
}

inline ‚Ñù computeSoundSpeed(const ‚Ñù c, const ‚Ñù energy, const ‚Ñù volume,
                           const ‚Ñù b, const ‚Ñù pressure, const ‚Ñù rho,
                           const ‚Ñù _ql, const ‚Ñù _qq){
  const ‚Ñù pe = c*energy;
  const ‚Ñù vvbp=volume*volume*b*pressure;
  const ‚Ñù ssc = (pe + vvbp)/rho;
  const ‚Ñù ssct = (ssc <= 0.111111e-36)?0.333333e-18:‚àö(ssc);
  const ‚Ñù sscq = ssct*_ql;
  const ‚Ñù sscqt = sscq+_qq;
  return sscqt;
}

inline ‚Ñù computeSoundSpeed(const ‚Ñù c, const ‚Ñù energy, const ‚Ñù volume,
                           const ‚Ñù b, const ‚Ñù pressure, const ‚Ñù rho){
  const ‚Ñù pe = c*energy;
  const ‚Ñù vvbp=volume*volume*b*pressure;
  const ‚Ñù ssc = (pe + vvbp)/rho;
  const ‚Ñù ssct = (ssc <= 0.111111e-36)?0.333333e-18:‚àö(ssc);
  return ssct;
}

‚àÄ cells @ 7.3 {
  const ‚Ñù vhalf = 1.0/(1.0+compHalfStep);
  const ‚Ñù ssc = computeSoundSpeed(pbvc,e_new,vhalf,bvc,pHalfStep,option_refdens,ql,qq);
  q_new = (delvc>0.0)?0.0:ssc;
  e_new = e_new + ¬Ω*delvc*(3.0*(p_old+q_old)-4.0*(pHalfStep+q_new));
}

‚àÄ cells @ 7.4{
  e_new += ¬Ω*work;
  e_new = (rabs(e_new) < option_e_cut)?0.0;
  e_new = (e_new<option_emin)?option_emin;
}

‚àÄ cells @ 7.5,7.7{
  const ‚Ñù c1s = 2.0/3.0;
  bvc = c1s*(compression + 1.0);
  pbvc = c1s;
  p_new = bvc*e_new ;
  p_new = (rabs(p_new) < option_p_cut)?0.0;
  p_new = (vnewc >= option_eosvmax )?0.0;
  p_new = (p_new < option_pmin)?option_pmin;
}

‚àÄ cells @ 7.6{
  const ‚Ñù sixth = 1.0/6.0;
  const ‚Ñù ssc = computeSoundSpeed(pbvc,e_new,vnewc,bvc,p_new,option_refdens,ql,qq);
  const ‚Ñù q_tilde = (delvc > 0.)?0.0:ssc;
  e_new = e_new - (7.0*(p_old + q_old)
                   - (8.0)*(pHalfStep + q_new)
                   + (p_new + q_tilde)) * delvc*sixth;
  e_new = (rabs(e_new) < option_e_cut)?0.0;
  e_new = (e_new < option_emin)?option_emin;
}

‚àÄ cells @ 7.8{
  const ‚Ñù qnw = computeSoundSpeed(pbvc,e_new,vnewc,bvc,p_new,option_refdens,ql,qq);
  const ‚Ñù qnwt = (rabs(qnw) < option_q_cut)?0.0:qnw;
  q_new = (delvc <= 0.)?qnwt;
}

‚àÄ cells @ 8.0{
  p = p_new;
  e = e_new;
  q = q_new;
}

// ****************************************************************************
// * Lastly, the routine CalcSoundSpeedForElems() calculates the sound speed
// * sound_speed in each element using p_n+1 and e_n+1.
// * The maximum value of sound_speed is used to calculate constraints on t_n+1
// * which will be used for the next time advance step.
// ****************************************************************************
‚àÄ cells @ 9.0{
  const ‚Ñù ssTmpt = computeSoundSpeed(pbvc,e_new,vnewc,bvc,p_new,option_refdens);
  sound_speed = ssTmpt;
}

// ****************************************************************************
// * The routine UpdateVolumesForElems() updates the relative volume to V_n+1.
// * This routine basically resets the current volume V_n in each element to
// * the new volume V_n+1 so the simulation can continue to the next time
// * increment.
// * Note that this routine applies a cut-off to the relative volume V in
// * each element. Specifically, if V is sufficiently close to one (a
// * prescribed tolerance), then V is set to one.
// * The reason for this cutoff is to prevent spurious deviations of volume
// * from their initial values which may arise due to floating point roundoff
// * error.
// ****************************************************************************
‚àÄ cells @ 10.0{
  const ‚Ñù ŒΩ = vnew;
  const ‚Ñù ŒΩt = (rabs(ŒΩ-1.0)<option_v_cut)?1.0:ŒΩ;
  v = ŒΩt;
}

// ****************************************************************************
// * The routine CalcCourantConstraintForElems() calculates the Courant timestep
// * constraint Œ¥t_Courant. This constraint is calculated only in elements
// * whose volumes are changing that is, dV/V!=0.
// * If all element volumes remain the same, there is no Courant constraint
// * applied during the subsequent Œ¥t calculation.
// ****************************************************************************
‚àÄ cells @ 12.1{
  const ‚Ñù arg_max_courant=1.0e+20;
  Œ¥t_cell_courant=arg_max_courant;
  const ‚Ñù qqc2 = 64.0 * option_qqc * option_qqc ;
  const ‚Ñù Œ¥f = sound_speed[m] * sound_speed[m];
  const ‚Ñù Œ¥ft=(vdov[m]<0.0)?qqc2*arealg[m]*arealg[m]*vdov[m]*vdov[m]:0.0;
  const ‚Ñù Œ¥fpp = Œ¥f+Œ¥ft;
  const ‚Ñù Œ¥fp = ‚àö(Œ¥fpp);
  const ‚Ñù aŒ¥fp = arealg[m]/Œ¥fp;
  Œ¥t_cell_courant=(vdov!=0.0)?min(arg_max_courant,aŒ¥fp);
} 

// ****************************************************************************
// * The routine CalcHydroConstraintForElems() calculates the hydro timestep
// * constraint. Similar to Œ¥t_Courant, Œ¥t_hydro is calculated only in elements
// * whose volumes are changing. When an element is undergoing volume change,
// * Œ¥t_hydro for the element is some maximum allowable element volume change
// * (prescribed) divided by dV/V in the element.
// ****************************************************************************
‚àÄ cells @ 12.2{
  const ‚Ñù arg_max_hydro=1.0e+20;
  Œ¥t_cell_hydro=arg_max_hydro;
  const ‚Ñù Œ¥dv = rabs(vdov[m]);
  const ‚Ñù Œ¥dve = Œ¥dv+1.e-20;
  const ‚Ñù Œ¥dvov = option_dvovmax/Œ¥dve;
  const ‚Ñù Œ¥hdr = min(arg_max_hydro,Œ¥dvov);
  Œ¥t_cell_hydro=(vdov!=0.0)?Œ¥hdr;
}

// ****************************************************************************
// * After all solution variables are advanced to t_n+1, the constraints Œ¥tCourant
// * and Œ¥thydro for the next time increment t_n+1 are calculated in this routine.
// * Each constraint is computed in each element and then the final constraint value
// * is the minimum over all element values.
// * The constraints are applied during the computation of Œ¥t for the next time step.
// ****************************************************************************

// Cells min reduction
‚àÄ cells Œ¥t_courant <?= Œ¥t_cell_courant @ 12.11;
‚àÄ cells Œ¥t_hydro   <?= Œ¥t_cell_hydro   @ 12.22;
