///////////////////////////////////////////////////////////////////////////////
// NABLA - a Numerical Analysis Based LAnguage                               //
//                                                                           //
// Copyright (C) 2014~2017 CEA/DAM/DIF                                       //
// IDDN.FR.001.520002.000.S.P.2014.000.10500                                 //
//                                                                           //
// Contributor(s): CAMIER Jean-Sylvain - Jean-Sylvain.Camier@cea.fr          //
//                                                                           //
// This software is a computer program whose purpose is to translate         //
// numerical-analysis specific sources and to generate optimized code        //
// for different targets and architectures.                                  //
//                                                                           //
// This software is governed by the CeCILL license under French law and      //
// abiding by the rules of distribution of free software. You can  use,      //
// modify and/or redistribute the software under the terms of the CeCILL     //
// license as circulated by CEA, CNRS and INRIA at the following URL:        //
// "http://www.cecill.info".                                                 //
//                                                                           //
// The CeCILL is a free software license, explicitly compatible with         //
// the GNU GPL.                                                              //
//                                                                           //
// As a counterpart to the access to the source code and rights to copy,     //
// modify and redistribute granted by the license, users are provided only   //
// with a limited warranty and the software's author, the holder of the      //
// economic rights, and the successive licensors have only limited liability.//
//                                                                           //
// In this respect, the user's attention is drawn to the risks associated    //
// with loading, using, modifying and/or developing or reproducing the       //
// software by the user in light of its specific status of free software,    //
// that may mean that it is complicated to manipulate, and that also         //
// therefore means that it is reserved for developers and experienced        //
// professionals having in-depth computer knowledge. Users are therefore     //
// encouraged to load and test the software's suitability as regards their   //
// requirements in conditions enabling the security of their systems and/or  //
// data to be ensured and, more generally, to use and operate it in the      //
// same conditions as regards security.                                      //
//                                                                           //
// The fact that you are presently reading this means that you have had      //
// knowledge of the CeCILL license and that you accept its terms.            //
//                                                                           //
// See the LICENSE file for details.                                         //
///////////////////////////////////////////////////////////////////////////////

// *************************************************************
// * Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏ‚ÏƒÏ„Ï…Ï†Ï‡ÏˆÏ‰Î‘Î’Î“Î”Î•Î–Î—Î˜Î™ÎšÎ›ÎœÎÎÎŸÎ Î¡Î£Î¤Î¥Î¦Î§Î¨Î©
// * âˆ€ â„â„•â„¤â„¾ âˆšâˆ› Â½â…“Â¼â…› ğœ•â„µâˆ‚ âˆâ†’âˆ…âˆ©âˆªâˆˆ â‹…â¨¯â¤«âŠ—â¨‚âŠ›
// * â°Â¹Â²Â³â´âµâ¶â·â¸â¹âºâ»â¼â½â¾â¿ áµƒáµ‡á¶œáµˆáµ‰á¶ áµÊ°â±Ê²áµË¡áµâ¿áµ’áµ–Ê³Ë¢áµ—áµ˜áµ›Ê·Ë£Ê¸á¶»
// * â‚€â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚‡â‚ˆâ‚‰â‚Šâ‚‹â‚Œâ‚â‚ â‚â‚‘â‚•áµ¢â±¼â‚–â‚—â‚˜â‚™â‚’â‚šáµ£â‚›â‚œáµ¤áµ¥â‚“ áµ¦áµ§áµ¨áµ©áµª
// * á´¬á´® á´°á´± á´³á´´á´µá´¶á´·á´¸á´¹á´ºá´¼á´¾á´¿ áµ€áµâ±½áµ‚ áµáµáµŸáµ Ë áµ¡á¶¥á¶°á¶¿
// *************************************************************
ğ’â‚€ â‰¡ cells;
ğ’â‚ â‰¡ cells;
ğ’©â‚€ â‰¡ nodes;
ğ’©â‚ â‰¡ nodes;
ğ“• â‰¡ faces;
âˆ‚ğ“•â‰¡ outer faces;
âˆ‚ğ’©â‰¡ outer nodes;

options{
  â„ Î³ = 1.4;
  â„ option_x_min = 0.0;
  â„ option_x_interface = 0.5;
  â„ option_x_max = 1.0;
  â„ option_y_min = 0.0;
  â„ option_y_max = 4.0;
  â„ option_Î´t_ini = 0.00001;
  â„ option_Î´t_min = 1e-12;
  â„ option_Î´t_max = 0.01;
  â„ option_Î´t_end = 0.2;
  â„ option_Î´t_control = 0.15;
  â„ option_Î´t_min_variation = 0.99;
  â„ option_Î´t_max_variation = 0.10;
  â„¾ option_Î´t_last_exact = true;
  â„• option_max_iterations = 32768;
  â„ option_ini_zg_Ï = 1.0;
  â„ option_ini_zd_Ï = 0.125;
  â„ option_ini_zg_p = 1.0; 
  â„ option_ini_zd_p = 0.1;
};

nodes{
  â„Â³ Î§â°,Î§;  // Position
  â„Â³ uâ‚™,bâ‚™; // Vitesse nodale du maillage & Second membre aux sommets
  â„Â³â¨¯â„Â³ Uâ‚™; // Matrice aux sommets pour le calcul de la vitesse
};

cells{  
  â„ c,m,pâ°,p,Ïâ°,Ï,Vâ°,V;   // Masse, Pression, DensitÃ©s, Volume
  â„ ÏÎ•,Î¹Î•;                // Ã‰nergie massique & interne
  â„ glace_Î´t;
  â„Â³ u;                   // Vitesse moyenne
  â„Â³ Î©â°;
  â„ total_energy_fluxes_Î£;
  â„Â³ momentum_fluxes_Î£;
  â„ pÌ…[nodes];             // Pressions reconstruites
  â„Â³ uÌ…[nodes];            // Vitesses reconstruites
  â„Â³ CQs[nodes];          // RÃ©sultantes aux sommets
  â„ absCQs[nodes];
  â„Â³â¨¯â„Â³ AQs[nodes];       // Matrices de contributions aux sommets
};


// *************************************************************
// * Globals
// *************************************************************
global{
  â„ Î´t;
  â„ time;
  â„ Î´t_next;
  â„ reduced_Î´t;
};

// *************************************************************
// * Conditions initiales: Î©â°,Ïâ°,pâ°,Vâ° & m
// *************************************************************
âˆ€ cells {
  Î©â°=0.0;
  âˆ€ nodes Î©â°+=coordâ°;
  Î©â°*=Â¼;
}
âˆ€ cells{
  if (Î©â°.x < option_x_interface)){
    Ïâ°=option_ini_zg_Ï;
    pâ°=option_ini_zg_p;
  }else{
    Ïâ°=option_ini_zd_Ï;
    pâ°=option_ini_zd_p;
  }
}
âˆ€ cells {
  â„Â³[4] coords;
  âˆ€ nodes coords[#]=coordâ°;
  Vâ°=quadVolume(coords);
}
âˆ€ cells m = Ïâ°*Vâ°;

// *************************************************************
// * RÃ¨gles EOS standards
// *************************************************************
âˆ€ cells c = âˆš(Î³*p/Ï);
âˆ€ cells p = (Î³-1.0)*Ï*Î¹Î•;
âˆ€ cells Ï = m/V;
âˆ€ cells Î¹Î• = ÏÎ•-Â½*norm(u)Â²;
âˆ€ cells ÏÎ•â¿â¼â° = pâ°/((Î³-1.0)*Ïâ°);
âˆ€ cells ÏÎ•â¿âºÂ¹ = ÏÎ•â¿ + Î´tâ¿*total_energy_fluxes_Î£â¿/mâ¿;

// *************************************************************
// * RÃ¨gles schÃ©ma GLACE standards
// *************************************************************
âˆ€ cells {
  const â„ Ïc = Ï*c;
  âˆ€ node{
    AQs = CQsâŠ—CQs;
    AQs *= Ïc/absCQs;
  }
}

âˆ€ cells { âˆ€ node pÌ…=p; }
âˆ€ cells { âˆ€ node uÌ…=u; }

âˆ€ nodes {
  Uâ‚™=0;
  Uâ‚™.z.z=1;
}
âˆ€ cells { âˆ€ node Uâ‚™ += AQs; }
 
âˆ€ nodes bâ‚™=0;
âˆ€ cells { âˆ€ node bâ‚™ += CQs*pÌ… + AQsâ¨‚uÌ…; }

âˆ€ nodes{
  const â„ d = matrixDeterminant(Uâ‚™);
  Uâ‚™ = inverseMatrix(Uâ‚™,d);
  uâ‚™ = Uâ‚™â¨‚bâ‚™;
  uâ‚™.z=0;
}

âˆ€ outer faces {
  const â„Â³â¨¯â„Â³ I = matrix3x3Id();
  const â„Â³ normaleY={0,1,0};
  âˆ€ node{
    if ((coord.y==option_y_min)||(coord.y==option_y_max)){
      const â„ orientation = (coord.y==option_y_min)?-1.0:1.0;
      const â„Â³ normal = orientation*normaleY;
      const â„Â³â¨¯â„Â³ nxn = normalâŠ—normal;
      const â„Â³â¨¯â„Â³ P = I-nxn;
      Uâ‚™ = Uâ‚™ âŠ› P; 
      Uâ‚™ = P âŠ› Uâ‚™;
      Uâ‚™ += nxn*(Uâ‚™.x.x+Uâ‚™.y.y +Uâ‚™.z.z );
      bâ‚™ = P â¨‚ bâ‚™;
    }
  }
}
âˆ€ outer faces {
  âˆ€ node{
    if (!((coord.x==option_x_min) ||
          (coord.x==option_x_max))) continue;
    Uâ‚™ = matrix3x3Id();
    bâ‚™ = option_u_ini;
  }
}

âˆ€ nodes Î§â¿â¼â° = Î§â°;
âˆ€ nodes Î§â¿âºÂ¹ = Î§â¿ + Î´tâ¿*uâ‚™â¿;

âˆ€ cells {
  momentum_fluxes_Î£=total_energy_fluxes_Î£=0;
  âˆ€ node{
    const â„Â³ Î”u = uÌ…-uâ‚™;
    â„Â³ FQs = AQs â¨‚ Î”u;
    FQs += pÌ…*CQs;
    momentum_fluxes_Î£ -= FQs;
    total_energy_fluxes_Î£ -= FQsâ‹…uâ‚™;
  }
}

âˆ€ cells uâ¿â¼â° = 0;
âˆ€ cells uâ¿âºÂ¹ = uâ¿ + Î´tâ¿*momentum_fluxes_Î£â¿/mâ¿;

// *************************************************************
// * RÃ©duction pour le calcul du pas de temps
// *************************************************************
âˆ€ cells { 
  â„ Î£ljr=0;
  âˆ€ node Î£ljr+=absCQs;
  glace_Î´t=2.0*V/(c*Î£ljr);
}
âˆ€ cells reduced_Î´t <?= glace_Î´t @ 31.0;

// *************************************************************
// * Calcul du pas de temps d'aprÃ¨s
// *************************************************************
âˆ€ nodes Î´tâ¿â¼â° = option_Î´t_ini;
âˆ€ nodes Î´tâ¿âºÂ¹ = Î´t_nextâ¿;

â„ computeÎ´tNext(void){
  const â„ max_time_step = (1.0+option_Î´t_max_variation)*Î´t;
  const â„ min_time_step = (1.0-option_Î´t_min_variation)*Î´t;
  â„ new_Î´t=option_Î´t_control*reduced_Î´t;
  if (new_Î´t > max_time_step) new_Î´t=max_time_step;
  if (new_Î´t < min_time_step) new_Î´t=min_time_step;
  new_Î´t = min(new_Î´t, option_Î´t_max);
  new_Î´t = max(new_Î´t, option_Î´t_min);
  if (option_Î´t_last_exact && ((time + new_Î´t) > option_Î´t_end)) 
    new_Î´t = option_Î´t_end - time;
  if ((time>=option_Î´t_end) || (new_Î´t==0.0)) exit;
  return new_Î´t;
}
Î´t_next = computeÎ´tNext();

// *************************************************************
// * Routines gÃ©omÃ©triques
// *************************************************************
â„Â³ âŸ‚(const â„Â³ *s){ return â„Â³(s[1].y-s[0].y,-s[1].x+s[0].x,0);}
â„ quadVolume(const â„Â³ *s){
  const â„Â³ e0 = s[2]-s[0];
  const â„Â³ e1 = s[0]-s[1];
  return e0â¨¯e1;
}

âˆ€ cells Vâ¿â¼â°=Vâ°;
âˆ€ cells {
  â„Â³[4] coords;
  âˆ€ nodes coords[#]=Î§â¿âºÂ¹;
  Vâ¿âºÂ¹=quadVolume(coords);
}

âˆ€ cells {
  â„Â³[4] coords;
  âˆ€ nodes coords[#]=Î§;
  CQs[0] = Â½*âŸ‚(s3,s1); absCQs[0]=norm(CQs[0]);
  CQs[1] = Â½*âŸ‚(s0,s2); absCQs[1]=norm(CQs[1]);
  CQs[2] = Â½*âŸ‚(s1,s3); absCQs[2]=norm(CQs[2]);
  CQs[3] = Â½*âŸ‚(s2,s0); absCQs[3]=norm(CQs[3]);
}
