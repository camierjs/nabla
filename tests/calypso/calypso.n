///////////////////////////////////////////////////////////////////////////////
// NABLA - a Numerical Analysis Based LAnguage                               //
//                                                                           //
// Copyright (C) 2014~2017 CEA/DAM/DIF                                       //
// IDDN.FR.001.520002.000.S.P.2014.000.10500                                 //
//                                                                           //
// Contributor(s): CAMIER Jean-Sylvain - Jean-Sylvain.Camier@cea.fr          //
//                                                                           //
// This software is a computer program whose purpose is to translate         //
// numerical-analysis specific sources and to generate optimized code        //
// for different targets and architectures.                                  //
//                                                                           //
// This software is governed by the CeCILL license under French law and      //
// abiding by the rules of distribution of free software. You can  use,      //
// modify and/or redistribute the software under the terms of the CeCILL     //
// license as circulated by CEA, CNRS and INRIA at the following URL:        //
// "http://www.cecill.info".                                                 //
//                                                                           //
// The CeCILL is a free software license, explicitly compatible with         //
// the GNU GPL.                                                              //
//                                                                           //
// As a counterpart to the access to the source code and rights to copy,     //
// modify and redistribute granted by the license, users are provided only   //
// with a limited warranty and the software's author, the holder of the      //
// economic rights, and the successive licensors have only limited liability.//
//                                                                           //
// In this respect, the user's attention is drawn to the risks associated    //
// with loading, using, modifying and/or developing or reproducing the       //
// software by the user in light of its specific status of free software,    //
// that may mean that it is complicated to manipulate, and that also         //
// therefore means that it is reserved for developers and experienced        //
// professionals having in-depth computer knowledge. Users are therefore     //
// encouraged to load and test the software's suitability as regards their   //
// requirements in conditions enabling the security of their systems and/or  //
// data to be ensured and, more generally, to use and operate it in the      //
// same conditions as regards security.                                      //
//                                                                           //
// The fact that you are presently reading this means that you have had      //
// knowledge of the CeCILL license and that you accept its terms.            //
//                                                                           //
// See the LICENSE file for details.                                         //
///////////////////////////////////////////////////////////////////////////////
with cartesian;

// ‚Ñï‚Ñù‚Ñæ

// ****************************************************************************
// * Options
// ****************************************************************************
options{
  // Precision
  ‚Ñù huge = sqrt(huge(1.0*0.1));
  ‚Ñù eps = 10.0/huge;
  ‚Ñù eps_io = 1.0e-9;

  // Constants
  ‚Ñï FNAME_MAX_LEN = 256;      // filename maximum length
  ‚Ñï KEYWORD_MAX_LEN = 30;     // maximum length of keywords
  ‚Ñï GRIDS_MAX_NBR = 100;      // maximum number of grids
  ‚Ñï GAGES_MAX_NBR = 500;      // maximum number of gages 
  ‚Ñï UNITS_MAX_NBR = 89;       // maximum number of simultaneous open units
  ‚Ñï FIRST_UNIT = 9;           // first used unit
  ‚Ñï ERR_MSG_MAX_LEN = 256;    // maximum length of error message
  ‚Ñï LINE_MAX_LEN = GRIDS_MAX_NBR*FNAME_MAX_LEN; // maximum line width
  ‚Ñï NT_CK_EXP_MIN = 10;       // minimum number of time steps between two checkings of explosion

  // Configuration
  ‚Ñù GZ = 9.81;                // standard acceleration due to gravity
  ‚Ñù PI = acos(-1.0);          // pi constant
  ‚Ñù DT_STD_OUT = 2.0;         // time step between two standard output
  ‚Ñù DT_CK_EXP = 2.0;          // time step between two checkings of explosion
  ‚Ñù FILL_VALUE = -999999.0;   // fill value for netcdf files
  ‚Ñù H_MAX = 500.0;            // maximum water height before considering explosion

  ‚Ñï VERBOSITY = 1;
                                                                                    
  ‚Ñï Ndim = 2;          // dimension (1 or 2)
  ‚Ñï number_of_grids=0; // number of grids
  ‚Ñï verbosity = 1;
  ‚Ñï west_bound=-1; // code of the west boundary condition
  ‚Ñï east_bound=-1; // code of the east boundary condition
  ‚Ñï north_bound=-1; // code of the north boundary condition
  ‚Ñï south_bound=-1; // code of the south boundary condition
  
  ‚Ñù time_of_simulation  = 0.0; // time of simulation
  ‚Ñù start_time          = 0.0; // start time
  ‚Ñù time_step_to_output = 0.0; // time step to output grids
  ‚Ñù time_step_of_gages  = -1.0; // time step of gages

//ùïäoutput_dir; // output directory name
//  ùïäwater_inlet_fname; // the name of the water inlet file
//  ùïäsurf_fname; // the name of a surface file
//  ùïäuvel_fname; // the name of the file with the velocity field along the x-axis
//  ùïävvel_fname; // the name of the file with the velocity field along the y-axis
//  ùïägages_fname; // the name of the file with gages
//  ùïäsources_fname; // the name of the file with sources
//  ùïägrid_coord_sys; // the name of the coordinate system of the grid
  
  // for each grid
  ‚Ñæ do_two_ways_interp/*[GRIDS_MAX_NBR]*/=false;
  ‚Ñæ is_runup/*[GRIDS_MAX_NBR]*/;           // is there run-up ? (for each grid)
  ‚Ñæ is_boussinesq/*[GRIDS_MAX_NBR]*/=false;      // is it Boussinesq resolution ? (for each grid)
  ‚Ñæ do_init_source/*[GRIDS_MAX_NBR]*/=false;     // do source initialization
  ‚Ñï hldg_grid_id/*[GRIDS_MAX_NBR]*/=-1;     // holding grid identification (for each grid)
  ‚Ñï space_scheme_order/*[GRIDS_MAX_NBR]*/=1;// the order of the space scheme (for each grid)
  ‚Ñù time_step/*[GRIDS_MAX_NBR]*/;           // time step (for each grid)
  ‚Ñù epsd/*[GRIDS_MAX_NBR]*/=0.0;            // minimum water depth computed (for each grid)
  ‚Ñù epshd/*[GRIDS_MAX_NBR]*/=0.0;           // minimum water thickness computed (for each grid)
  ‚Ñù dcut/*[GRIDS_MAX_NBR]*/=0.0;            // depth thresold from which the seabottom is flatten (for each grid)
//  ùïätime_scheme[GRIDS_MAX_NBR] = "ICN"; // time scheme name (for each grid)
//  ùïä depth_fname[GRIDS_MAX_NBR];        // depth file names (for each grid)
//  ùïä output_types[OUT_TYPES_MAX_NBR] = "";   // list of output types

  // Private attributes
  ‚Ñæ is_output_velocities = false;
  ‚Ñæ output_velocities = false;            // deprecated parameter -> use output_types instead
  ‚Ñæ is_master_proc;                       // is it the master process ?
  ‚Ñæ is_parallel;                          // is it a parallel run?
  ‚Ñï grid_id/*[GRIDS_MAX_NBR]*/=-1;            // grid identification
  ‚Ñï grids_call_init_seism/*[GRIDS_MAX_NBR]*/ = 0; // list of grids calling initializing with the source
  ‚Ñù epshd = 1.0e-9;
};


// ****************************************************************************
// * Cells
// ****************************************************************************
cells{
  ‚Ñù hnp; // h^(n+1) matrix
  ‚Ñù unp; // u^(n+1) matrix
  ‚Ñù vnp; // v^(n+1) matrix

  ‚Ñù d;
  ‚Ñù d_hn;
  ‚Ñù hn; // the water height matrix
  ‚Ñù un; // the velocity matrix along the x-axis
  ‚Ñù vn; // the velocity matrix along the y-axis
  ‚Ñù deqh;
  ‚Ñù fc; // Coriolis force
};


// ***************************************************************************
// * Faces
// ***************************************************************************
faces{
  ‚Ñù bv;
};


// ***************************************************************************
// * Globals
// ***************************************************************************
global{
  ‚Ñù dt,t; // time step, time
  ‚Ñï nt; // iteration
  ‚Ñù cfl_max; // maximum value of CFL
  ‚Ñù inv_dx,inv_dy;
  ‚Ñù ti; // the initial time
  ‚Ñù tf; // final time
};


// ***************************************************************************
// * Initialisation part
// ***************************************************************************
conf_init @ -11.9 { debug()<<"[1;33m[conf_init][m"; }
simulation_init @ -11.9 { debug()<<"[1;33m[simulation_init][m"; }
cliona_start @ -12.0 { debug()<<"[1;33m[cliona_start][m"; }


// ***************************************************************************
// * Compute loop
// ***************************************************************************

time_scheme_leapfrog_iterate @ 1.0 {
// Time t_n to t_n+1
}

‚àÄ cells eulerIterateEqh @ 1.1 {
  d_hn = d + hn;
}

// Compute space derivatives of the equation of
// conservation of mass (eq. h) and do one iteration of
// Euler time scheme
‚àÄ cells space_scheme_nlsw_1st_order_compute_eqh_X @ 1.2 {
  // Term: d((d+h)u)/dx
  const ‚Ñù dhn1=(un>0.0)?d_hn[‚Üí]:d_hn;
  const ‚Ñù dhn2=(un[‚Üê]>0.0)?d_hn[‚Üê]:d_hn;
  const ‚Ñù deqh_dx = (un*dhn1-un[‚Üí]*dhn2)*inv_dx;
}
‚àÄ cells space_scheme_nlsw_1st_order_compute_eqh_Y @ 1.2 {
  // Term: d((d+h)v)/dy
  const ‚Ñù dhn1=(vn>0.0)?d_hn[‚Üë]:d_hn;
  const ‚Ñù dhn2=(vn[‚Üì]>0.0)?d_hn[‚Üì]:d_hn;
  const ‚Ñù deqh_dy = (vn*dhn1-vn[‚Üì]*dhn2)*inv_dx;
}
‚àÄ cells space_scheme_nlsw_1st_order_compute_eqh_Y_sum @ 1.21 {
  deqh = deqh_dx + deqh_dy;
}
‚àÄ cells space_scheme_nlsw_1st_order_compute_eqh_Y_euler_time_iteration @ 1.22 {
  hnp = hn - dt*deqh;
}

time_scheme_update_hn @ 1.3 { hn = hnp; }
time_scheme_update_un @ 1.3 { un = unp; }
time_scheme_update_vn @ 1.3 { if (Ndim == 2) vn = vnp; }

// Time t_n+1/2 to t_n+3/2
// Euler iteration on equation of conservation of moment

// space_scheme_nlsw_1st_order_compute_equ
// Computes pace derivatives of the equation of
// conservation of moment along x-axis (eq. u) and do one
// iteration of Euler time scheme
‚àÄ cells space_scheme_nlsw_1st_order_compute_equ @ 1.4 {
  const ‚Ñï i_tu1 = i - (un <= 0.0);
  const ‚Ñù tv = 0.25*(vn[‚Üì]+vn[‚Üò]+vn+v[‚Üí]);
  const ‚Ñï j_tu2 = j - (tv <= 0.0);
  const ‚Ñù tu1 = un * (un[i_tu1,j]-un[i_tu1-1,j]); // u*du/dx
  const ‚Ñù tu2 = tv * (un[i,j_tu2]-un[i,j_tu2-1]); // v*du/dy
  const ‚Ñù thu = gz * (hn[‚Üí]-hn); // g*dh/dx
  const ‚Ñù tfc = -tv * fc; // Coriolis force
  dequ = (tu1+thu)*inv_dx + tu2*inv_dy + tfc;
  unp = un - dt*dequ; // Euler time iteration
}
‚àÄ cells space_scheme_nlsw_1st_order_compute_eqv @ 1.4 {
  const ‚Ñù tu = 0.25 * (un[‚Üê]+un+un[‚Üñ]+un[‚Üë]);
  const ‚Ñï j_tv2 = j - (vn <= 0.0);
  const ‚Ñï i_tv1 = i - (tu <= 0.0);
  const ‚Ñù tv1 = tu * (vn[i_tv1,j]-vn[i_tv1-1,j]); // u*dv/dx
  const ‚Ñù tv2 = vn[i,j] * (vn[i,j_tv2]-vn[i,j_tv2-1]); // v*dv/dy
  const ‚Ñù thv = GZ * (hn[‚Üë]-hn); // g*dh/dy
  const ‚Ñù tfc = tu * fc; // Coriolis force
  deqv = tv1*inv_dx + (tv2+thv)*inv_dy + tfc;
  vnp[i-Nf,jj] = vn - dt*deqv; // Euler time iteration
}

// time_scheme_leapfrog_iterate: Runup
// time_scheme_leapfrog_iterate: Update temporary matrix
‚àÄ cells time_scheme_leapfrog_iterate_update_temporary_matrix @ 1.5 {
  d_hn = d + hn;
}

// time_scheme_leapfrog_iterate: Treatment for velocities
void runup_treat_vel_d_dhn_hn_cn_cnp(‚Ñù cn, ‚Ñù cnp){
  const ‚Ñï Nf = 1;
  // if at least the west neighbour cell is wet
  if (d_hn< epshd){
    // - both cells are dry (cases a1, c1 [CK98]) or if no flood
    // is possible because water surface at a wet cell is lower than the bottom 
    // of the neighbour dry cell (case c2 [CK98])
    if (d_hn[i+i1,j+j1] < epshd or hn[i+i1,j+j1] < -d) {
      cnp[‚Üô] = 0.0;
      // - if flood is possible, a correction of grad(h) in the equation of 
      // conservation of moments (equ,eqv) is required 
      // (use d_hn instead of hn in term 'thu', cases b1 and c3 [CK98])
    }else{
      if (cn[i,j] < 0.0 and hn[i+i1,j+j1] > hn) {
        cnp[‚Üô] = cnp[i-Nf,j-Nf] - coef_grad_h[jj]*(hn[i,j]+d[i+i1,j+j1]);
      }
    }
  }
  // if only the east neighbour cell is wet
  else {
    if (d_hn[i+i1,j+j1] < epshd) {
      // if no flood is possible because water surface at a 
      // wet cell is lower than the bottom of the neighbour 
      // dry cell (case a2 [CK98])
      if (hn < -d[i+i1,j+j1]) {
        cnp[i-Nf,j-Nf] = 0.0;
        // - if flood is possible, a correction of grad(h) in the equation of 
        // conservation of moments (equ,eqv) is required 
        // (use d_hn instead of hn in term 'thu', cases a3 and d1 [CK98])
      }else {
        if (cn > 0.0 and (hn > hn[i+i1,j+j1])) {
          cnp[‚Üô] = cnp[‚Üô] + coef_grad_h[jj]*(hn[i+i1,j+j1]+d);
        }
      }
    }
      // if both cells are wet but the water surface of one is lower 
      // than the bottom of the neighbour dry cell a correction of 
      // grad(h) in the equation of conservation of moments (equ,eqv) is required 
      else{
        // - cases d2 [fig. 2, CK98]
        if (cn[i,j] > 0.0) {
          if (-d[i,j] > hn[i+i1,j+j1]) {
            cnp[‚Üô] = cnp[i-Nf,j-Nf] + coef_grad_h[jj]*(hn[i+i1,j+j1]+d);
          }
        }
        // - case b2 [fig. 2, CK98]
        else 
          if(-d[i+i1,j+j1] > hn[i,j]) {
            cnp[i-Nf,j-Nf] = cnp[i-Nf,j-Nf] - coef_grad_h[jj]*(hn[i,j]+d[i+i1,j+j1]);
          }
      }
  }
}
runup_treat_vel_d_dhn_hn_un_unp @ 1.6{
  runup_treat_vel_d_dhn_hn_cn_cnp(un,unp);
  runup_treat_vel_d_dhn_hn_cn_cnp(vn,vnp);
}

// time_scheme_leapfrog_iterate update_vel
time_scheme_update_vel_u @ 1.7 { un = unp; }
time_scheme_update_vel_v @ 1.7 { if (Ndim == 2) vn = vnp; }

// [time_scheme_leapfrog_iterate] Check explosion
time_scheme_check_explosion @ 1.8 {
  ‚Ñæ is_explosion = false;
  // Check for NaN in the first computed cell only
  // Check for high values
  // abort the simulation if explosion
}


model_iterate_time_update @ 1.9 {
  t = t + dt;
  nt = nt + 1;
}

model_iterate_segment_update @ 2.0 { }


model_iterate_boundary_update @ 2.1 { // d, hn, un, vn, nt
  
}

boundary_force @ 2.11 { if (is_forced_bound); }
boundary_set_value_forced @ 2.12 {}

boundary_continuative @ 2.13 {}
boundary_set_value_continue @ 2.14 {}

boundary_reflective @ 2.15 {}
boundary_set_value_reflect @ 2.16 {}

model_iterate_snapshots_update_extreme @ 2.2 { }

//      call error("nabla")




