with cartesian; // donne accès aux 'xyz' comme arguments des points d'entrée


// ****************************************************************************
// * Déclaration des options accessibles depuis l'AXL
// ****************************************************************************
options{
  Integer option_ordre_projection = 1;
  Real gamma = 1.4;
  Real dx = 0.005;
  Integer option_max_iterations=20;
};


// ****************************************************************************
// * Déclaration des variables aux noeuds
// ****************************************************************************
nodes{
  Real3 eulerian_coordinates;   // coords des noeuds du maillage eulérien (= avant phase Lagrange.)
  Real3 lagrangian_coordinates; // coords des noeuds après phase Lagrange.
                                // Tableau de travail, est rempli depuis le maillage.
                                // Les noeuds ont bougé avec la vitesse de grille 0.5 (velocity + old_velocity).
  Real3 velocity;               // Vitesse nodale à la fin du pas de temps. Spécifique prédicteur/correcteur ??
  Real3 old_velocity;           // Vitesse nodale au début du pas de temps. Spécifique prédicteur/correcteur ??
  Real3 lagrangian_velocity;    // Vitesse de déplacement des noeuds du maillage
  Real nodal_mass_flux_left;    // Flux de masse dual pour la projection des quantités aux noeuds (= la vitesse).
  Real nodal_mass_flux_right;   // Flux de masse dual pour la projection des quantités aux noeuds (= la vitesse). 
  Real delta_mass;              // Pour diagnostiquer une éventuelle perte de masse dans la masse nodale.
  Real pressure_gradient;
  Real nodal_density;
  Real old_nodal_density;
};


// ****************************************************************************
// * Déclaration des variables aux mailles
// ****************************************************************************
cells{
  Real old_volume;                   // Volume des mailles au début du pas de temps
  Real volume_flux_left;             // Flux de volume pour la projection (dVol pour S1F). Tableau mailles mixtes
  Real volume_flux_right;            // Flux de volume pour la projection (dVol pour S1F). Tableau mailles mixtes
  Real mass_flux_left;               // Flux de masse pour la projection (dm pour S1F). Tableau mailles mixtes
  Real mass_flux_right;              // Flux de masse pour la projection (dm pour S1F). Tableau mailles mixtes
  Real directional_projected_volume; // Volume projeté directionnel. Tableau mailles mixtes
  Real nrj;
  Real directional_internal_energy;  // Flux de masse pour la projection (dm pour S1F). Tableau mailles mixtes
  Real old_density;
  Real pressure;
  Real density;
};



// ****************************************************************************
// * Partie d'initialisation ]-oo,-0[
// ****************************************************************************

void cartesianHydroStartInit(void) @ -10{
  deltat = 1.0;
}




// ****************************************************************************
// * Partie de calcul ]+0,+oo[ 
// ****************************************************************************

nodes void copyEulerianCoordinates(void)
  out (node eulerian_coordinates) @ 0.01 {
  eulerian_coordinates=coord; // Could 'copy'
}

cells void copyCurrentCellsVariablesToOldVariables(void)
  in (cell density) out (cell old_density) @ 0.01 {
  old_density = density;
}

nodes void copyCurrentNodesVariablesToOldVariables(void)
  in (cell velocity) out (cell old_velocity) @ 0.01 {
  old_velocity = velocity;
}

// Position des noeuds après la phase Lagrange (= position des noeuds stockée dans le maillage).
nodes void copyCoordsToLagrangian(void)
  out (node lagrangian_coordinates) @ 0.01{
  lagrangian_coordinates=coord; // Could 'copy'
}

// Vitesse de déplacement des noeuds (valable en prédicteur correcteur).
nodes void prepareLagrangianVariables(void)
  in (node velocity, node old_velocity) out (node lagrangian_velocity) @ 0{
   lagrangian_velocity = 0.5*(old_velocity+velocity);
}


// Appel des points d'entrée à arguments
void cartesianHydroMain(void) @ 1.0{
  evolvePrimalUpwindedVariables(MD_DirX);// @ 1;
  computePrimalMassFluxBoundary(MD_DirX);// @ 1;
  evolveDualUpwindedVariables(MD_DirX);// @ 2;
}

// ******************************************************************************
// * Partie PRIMALE avec arguments: on les appelle depuis un autre point d'entrée
// ******************************************************************************
inner cells void evolvePrimalUpwindedVariables(xyz direction)
  in(cell density) {
  // Temporaire pour le 1d. En attendant la connectivite Maille/face directionnelle.
  const Real3 left_face_velocity = lagrangian_velocity[previousLeft];
  const Real left_face_velocity_dir = left_face_velocity.x;
  const Real3 right_face_velocity = lagrangian_velocity[nextLeft];
  const Real right_face_velocity_dir = right_face_velocity.x;
  // Calcul des signes pour le décentrement.
  const Real sign_left = (left_face_velocity_dir > 0.0 ? 1.0 : -1.0);
  const Real sign_right = (right_face_velocity_dir > 0.0 ? 1.0 : -1.0);
  Real nrj_left_cell = nrj[prevCell];
  Real nrj_right_cell = nrj[nextCell];
  //Real nrj_current_cell = nrj;
  const Real dmass_left = 0.5 * left_face_velocity_dir
    * ((density + density[prevCell]) - sign_left * (density - density[prevCell]));
  const Real dmass_right = 0.5 * right_face_velocity_dir * 
    ((density[nextCell] + density) - sign_right * (density[nextCell] - density));
  // Décentrement énergie interne.
  const Real nrj_left  = 0.5 * ((nrj + nrj_left_cell) - sign_left * (nrj - nrj_left_cell));
  const Real nrj_right = 0.5 * ((nrj_right_cell + nrj) - sign_right * (nrj_right_cell - nrj));
  Real nrj_current_cell;
  mass_flux_left = dmass_left;
  mass_flux_right = dmass_right;
  density = density - deltat * (dmass_right - dmass_left) / dx;
  nrj_current_cell = old_density * nrj - deltat * (nrj_right * dmass_right - nrj_left * dmass_left) / dx;
  // Terme source PdV.
  nrj_current_cell = nrj_current_cell - deltat * pressure * (right_face_velocity_dir - left_face_velocity_dir) / dx;
  if (density != 0.0) {
    nrj_current_cell /= density;
  } else {
    info() << "Erreur, densite nulle.\n";
    //std::abort();
  }
  nrj = nrj_current_cell;
}

// Calcul des flux de masse pour les mailles de bord dans la direction de calcul.
outer cells void computePrimalMassFluxBoundary(xyz direction)
  out(cell mass_flux_right, cell mass_flux_left)  {
  if (prevCell.null()){ // Frontière gauche
    mass_flux_right = mass_flux_left[nextCell];
    mass_flux_left = mass_flux_right;
  }
  if (nextCell.null()){ // Frontière droite.
    mass_flux_left = mass_flux_right[prevCell];
    mass_flux_right = mass_flux_left;
  }
}

// ****************************************************************************
// * Partie DUALE avec arguments: on les appelle depuis un autre point d'entrée
// ****************************************************************************
// Calcul des quantités duales : vitesse (quantité de mouvement).
void evolveDualUpwindedVariables(xyz direction){
  _evolveDualUpwindedVariables1();//@1;
  computeDualMassFluxBoundary(direction);//@1;
  computePressureGradientIni();//@2;
  computePressureGradient(direction);//@3;
  evolveDualUpwindedVariablesContinue(direction);//@4;
}

// Calcul des quantités duales : vitesse (quantité de mouvement).
own nodes void _evolveDualUpwindedVariables1(void)
  out (node nodal_mass_flux_right){
  //Densités nodales.
  Real nodal_density_sum = 0.0;
  Real old_nodal_density_sum = 0.0;
  Real nodal_mass_flux_right_accumulation = 0.0;
  Real nodal_mass_flux_left_accumulation = 0.0;
  //CellEnumerator node_cells =  node.cells();
  if (nbCell==0) fatal("", "No cell attached to the node");
  foreach cell{
    nodal_density_sum += density;
    old_nodal_density_sum += old_density;
    nodal_mass_flux_right_accumulation += mass_flux_right;
    nodal_mass_flux_left_accumulation += mass_flux_left;
    }
  nodal_density = nodal_density_sum / nbCell;
  old_nodal_density = old_nodal_density_sum / nbCell;
  nodal_mass_flux_right = nodal_mass_flux_right_accumulation / nbCell;
  nodal_mass_flux_left = nodal_mass_flux_left_accumulation / nbCell;
}

outer nodes void computeDualMassFluxBoundary(xyz direction)
  inout(node nodal_mass_flux_left, node nodal_mass_flux_right)
  {
  if (leftNode.null()) { // Frontière gauche.
    nodal_mass_flux_left = nodal_mass_flux_left[rightNode];
    nodal_mass_flux_right = nodal_mass_flux_right[rightNode];
  }
  if (rightNode.null()) { // Frontière droite.
    nodal_mass_flux_left = nodal_mass_flux_left[leftNode];
    nodal_mass_flux_right = nodal_mass_flux_right[leftNode];
  }
}

// Le gradient de pression est une variable temporaire qui peut a priori être cumulée
// Il vaut mieux la mettre à 0.
nodes void computePressureGradientIni(void)
  out (node pressure_gradient){
  pressure_gradient = 0.0;
}

cells void computePressureGradient(xyz direction)
  in (cell pressure) {
  Real current_pressure_gradient=pressure;
  if (!prevCell.null())
    current_pressure_gradient -= pressure[prevCell];
  // Chaque point du maillage (sauf aux bords) aura son gradient de
  // pression calculé 2 fois, mais ca n'est pas grave...
  pressure_gradient[previousLeft] = current_pressure_gradient;
  pressure_gradient[previousRight] = current_pressure_gradient;
}


inner nodes void evolveDualUpwindedVariablesContinue(xyz direction)
  out(node velocity){
  const Real sign_left = (nodal_mass_flux_left > 0.0 ? 1.0 : -1.0);
  const Real sign_right = (nodal_mass_flux_right > 0.0 ? 1.0 : -1.0);
  const Real3 nodal_velocity_right = 
    0.5 * ((old_velocity[rightNode] + old_velocity) - 
           sign_right * (old_velocity[rightNode] - old_velocity));
  const Real3 nodal_velocity_left = 
    0.5 * ((old_velocity + old_velocity[leftNode]) - 
           sign_left * (old_velocity - old_velocity[leftNode]));
  lagrangian_velocity = 
    old_nodal_density * lagrangian_velocity - 
    deltat * (nodal_mass_flux_right * nodal_velocity_right - 
                 nodal_mass_flux_left  * nodal_velocity_left) / dx;
  lagrangian_velocity.x -= deltat * pressure_gradient / dx;
  if (nodal_density != 0.0) {
    lagrangian_velocity /= nodal_density;
  } else {
    fatal("Probleme","densite nodale nulle.\n");
  }
  velocity = lagrangian_velocity;
}



// ****************************************************************************
// * Fin des parties PRIMALES & DUALES
// ****************************************************************************

// Application de l'équation d'état. En dur (gaz parfaits, gamma=1.4) pour l'instant
cells void computePressure(void)
  out (cell pressure) @ 2{   
  pressure = (gamma - 1.0) * density * nrj;
}

// On doit avoir conservation de la masse nodale (calculée au moment
// du décentrement de la quantité de mouvement, à partir de la masse
// aux mailles). C'est un diagnostic utile.
own nodes void checkNodalMassConservation(void)
  out (node delta_mass) @ 2{
  delta_mass =
    (nodal_density-old_nodal_density)
    + deltat*(nodal_mass_flux_right-nodal_mass_flux_left)/dx;
}


void testForQuit(void) @ 4.0{
  if (GlobalIteration >= option_max_iterations) exit;
}
