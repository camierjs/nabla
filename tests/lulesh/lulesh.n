///////////////////////////////////////////////////////////////////////////////
// NABLA - a Numerical Analysis Based LAnguage                               //
//                                                                           //
// Copyright (C) 2014~2017 CEA/DAM/DIF                                       //
// IDDN.FR.001.520002.000.S.P.2014.000.10500                                 //
//                                                                           //
// Contributor(s): CAMIER Jean-Sylvain - Jean-Sylvain.Camier@cea.fr          //
//                                                                           //
// This software is a computer program whose purpose is to translate         //
// numerical-analysis specific sources and to generate optimized code        //
// for different targets and architectures.                                  //
//                                                                           //
// This software is governed by the CeCILL license under French law and      //
// abiding by the rules of distribution of free software. You can  use,      //
// modify and/or redistribute the software under the terms of the CeCILL     //
// license as circulated by CEA, CNRS and INRIA at the following URL:        //
// "http://www.cecill.info".                                                 //
//                                                                           //
// The CeCILL is a free software license, explicitly compatible with         //
// the GNU GPL.                                                              //
//                                                                           //
// As a counterpart to the access to the source code and rights to copy,     //
// modify and redistribute granted by the license, users are provided only   //
// with a limited warranty and the software's author, the holder of the      //
// economic rights, and the successive licensors have only limited liability.//
//                                                                           //
// In this respect, the user's attention is drawn to the risks associated    //
// with loading, using, modifying and/or developing or reproducing the       //
// software by the user in light of its specific status of free software,    //
// that may mean that it is complicated to manipulate, and that also         //
// therefore means that it is reserved for developers and experienced        //
// professionals having in-depth computer knowledge. Users are therefore     //
// encouraged to load and test the software's suitability as regards their   //
// requirements in conditions enabling the security of their systems and/or  //
// data to be ensured and, more generally, to use and operate it in the      //
// same conditions as regards security.                                      //
//                                                                           //
// The fact that you are presently reading this means that you have had      //
// knowledge of the CeCILL license and that you accept its terms.            //
//                                                                           //
// See the LICENSE file for details.                                         //
///////////////////////////////////////////////////////////////////////////////

// This NABLA port is an implementation of the benchmark LULESH:
// the Livermore Unstructured Lagrangian Explicit Shock Hydrodynamics
// (see https://computation.llnl.gov/casc/ShockHydro/ for details)

with cartesian;


// ****************************************************************************
// * Options
// ****************************************************************************
options{
  ‚Ñù LENGTH                    = 1.125;
  ‚Ñï X_EDGE_ELEMS              = 8;
  ‚Ñï Y_EDGE_ELEMS              = 8;
  ‚Ñï Z_EDGE_ELEMS              = 8;
  
  ‚Ñù option_Œ¥t_fixed           = -1.0e-7;  // fixed time increment
  ‚Ñù option_Œ¥t_initial         = 1.0e-7;   // variable time increment
  ‚Ñù option_Œ¥t_courant         = 1.0e+20;
  ‚Ñù option_Œ¥t_hydro           = 1.0e+20;
  ‚Ñù option_Œ¥t_mult_lower_b    = 1.1;
  ‚Ñù option_Œ¥t_mult_upper_b    = 1.2;
  ‚Ñù option_initial_energy     = 3.948746e+7;
  ‚Ñù option_stoptime           = 1.0e-2;   // end time for simulation
  ‚Ñù option_hgcoef             = 3.0;      // hourglass control
  ‚Ñù option_qstop              = 1.0e+12;  // excessive q indicator
  ‚Ñù option_monoq_max_slope    = 1.0;
  ‚Ñù option_monoq_limiter_mult = 2.0;
  ‚Ñù option_e_cut              = 1.0e-7;   // energy tolerance
  ‚Ñù option_p_cut              = 1.0e-7;   // pressure tolerance
  ‚Ñù option_q_cut              = 1.0e-7;   // q tolerance
  ‚Ñù option_u_cut              = 1.0e-7;   // node velocity cut-off value
  ‚Ñù option_v_cut              = 1.0e-10;  // relative volume tolerance
  ‚Ñù option_qlc_monoq          = 0.5;      // linear term coef for q
  ‚Ñù option_qqc_monoq          = 0.6666666666667;//666666; // quadratic term coef for q
  ‚Ñù option_qqc                = 2.0;
  ‚Ñù option_eosvmax            = 1.0e+9;
  ‚Ñù option_eosvmin            = 1.0e-9;
  ‚Ñù option_pmin               = 0.0;      // pressure floor
  ‚Ñù option_emin               = -1.0e+15; // energy floor
  ‚Ñù option_dvovmax            = 0.1;      // maximum allowable volume change
  ‚Ñù option_refdens            = 1.0;      // reference density
  ‚Ñù option_dtmax              = 1.0e-2;   // maximum allowable time increment
  ‚Ñæ option_chaos           = false;
  ‚Ñù option_chaos_seed         = 1.1234567890123;//456789;
  ‚Ñï option_max_iterations     = 32768;//128;
};


// ****************************************************************************
// * Node Variables
// ****************************************************************************
nodes{
  ‚Ñù¬≥ ùúïx;           // Velocity vector
  ‚Ñù¬≥ ùúïùúïx;          // Acceleration vector
  ‚Ñù¬≥ nForce;       // Force vector
  ‚Ñù nodalMass;     // Nodal mass
};


// ****************************************************************************
// * Element Variables
// ****************************************************************************
cells{
  // Table 1.2 Element Variables  ////////////////
  ‚Ñù p;              // pressure
  ‚Ñù e;              // internal energy, (to synchronize)
  ‚Ñù q;              // artificial viscosity
  ‚Ñù v;              // relative volume
  ‚Ñù calc_volume;    // instant relative volume
  ‚Ñù vdov;           // relative volume change per volume
  ‚Ñù delv;           // relative volume change
  ‚Ñù volo;           // reference (initial) volume
  ‚Ñù arealg;         // characteristic length
  ‚Ñù¬≥ Œµ;             // diagonal terms of deviatoric strain  dxx(),dyy(),dzz()
  ‚Ñù ql;             // artificial viscosity linear term, (to synchronize)
  ‚Ñù qq;             // artificial viscosity quadratic term, (to synchronize)
  ‚Ñù¬≥ cForce[nodes];
  // Temporaries /////////////////////////////////
  ‚Ñù delv_xi;        // velocity gradient
  ‚Ñù delv_eta;
  ‚Ñù delv_zeta;
  ‚Ñù delx_xi;        // coordinate gradient
  ‚Ñù delx_eta;
  ‚Ñù delx_zeta;
  ‚Ñù phixi;
  ‚Ñù phieta;
  ‚Ñù phizeta;
  ‚Ñù vnew;           // new relative volume
  ‚Ñù elemMass;       // mass
  // EoS /////////////////////////////////////////
  ‚Ñù e_old;
  ‚Ñù delvc;
  ‚Ñù p_old;
  ‚Ñù q_old;
  ‚Ñù compression;
  ‚Ñù compHalfStep;
  ‚Ñù work;
  ‚Ñù p_new;
  ‚Ñù e_new;
  ‚Ñù q_new;
  ‚Ñù bvc;
  ‚Ñù pbvc;
  ‚Ñù vnewc;
  ‚Ñù pHalfStep;
  ‚Ñù sound_speed;
  // Boundary Conditions Flags //////////////////////////////////////////////
  ‚Ñï elemBC;          // symmetry/free-surface flags for each elem face
  // Reductions ////////////////////////////
  ‚Ñù Œ¥t_cell_hydro;
  ‚Ñù Œ¥t_cell_courant;
};


// ****************************************************************************
// * Global Variables
// ****************************************************************************
global{
  ‚Ñù Œ¥t_courant;         // Courant time constraint
  ‚Ñù Œ¥t_hydro;           // Hydro time constraint
};


// ****************************************************************************
// * Initialization Part @ ]-‚àû,-0.0[
// ****************************************************************************


// ****************************************************************************
// * ini
// ****************************************************************************
void ini(void) @ -10.0{
  Œ¥t=(option_chaos)?option_Œ¥t_initial*option_chaos_seed:0.0;
  Œ¥t_hydro=option_Œ¥t_hydro;
  Œ¥t_courant=option_Œ¥t_courant;
  //atexit(dumpFinalEnergy);
}

‚àÄ nodes void chaosNodes(void) out (node coord) @ -12.0{
  coord *= (option_chaos)?option_chaos_seed:1.0;
  //const Real chaos = (((Real)uid)+1.0)*option_chaos_seed;
  //coord = (option_chaos)?chaos:1.0;
  //info()<<"coord="<<coord;
  //printf("\ncoord[%d]=(%.21e,%.21e,%.21e)",uid,coord.x,coord.y,coord.z);
}
/*nodes void dumpCorners(void)@-12.0{
  foreach cell{
    const int corner = node_cell_corner[8*n+i];
    if (corner==-1) continue;
    if (uid==31) printf("\n[#%d] node_#%d is corner %d of cell %d",i,uid,node_cell_corner[8*n+i],node_cell[8*n+i]);
  }
  }*/


  
// ****************************************************************************
// * Set up boundary condition information
// * Set up elemement connectivity information
// ****************************************************************************
#define XI_M        0x003
#define XI_M_SYMM   0x001
#define XI_M_FREE   0x002
#define XI_P        0x00C
#define XI_P_SYMM   0x004
#define XI_P_FREE   0x008
#define ETA_M       0x030
#define ETA_M_SYMM  0x010
#define ETA_M_FREE  0x020
#define ETA_P       0x0C0
#define ETA_P_SYMM  0x040
#define ETA_P_FREE  0x080
#define ZETA_M      0x300
#define ZETA_M_SYMM 0x100
#define ZETA_M_FREE 0x200
#define ZETA_P      0xC00
#define ZETA_P_SYMM 0x400
#define ZETA_P_FREE 0x800
‚àÄ cells void iniCellBC(void) in (node coord) out (cell elemBC) @ -9.5{
  const ‚Ñù zero = 0.0;
  const ‚Ñù maxBoundaryX = LENGTH;//X_EDGE_TICK*X_EDGE_ELEMS;
  const ‚Ñù maxBoundaryY = LENGTH;//Y_EDGE_TICK*Y_EDGE_ELEMS;
  const ‚Ñù maxBoundaryZ = LENGTH;//Z_EDGE_TICK*Z_EDGE_ELEMS;
  elemBC=0; // clear BCs by default
  ‚àÄ node{
    elemBC |= (coord.x==zero)?XI_M_SYMM;
    elemBC |= (coord.y==zero)?ETA_M_SYMM;
    elemBC |= (coord.z==zero)?ZETA_M_SYMM;
    elemBC |= (coord.x==maxBoundaryX)?XI_P_FREE;
    elemBC |= (coord.y==maxBoundaryY)?ETA_P_FREE;
    elemBC |= (coord.z==maxBoundaryZ)?ZETA_P_FREE;
  }
  //debug()<<"#"<<uid<<" elemBC="<<elemBC;
  //printf("\n#%d elemBC=%d",uid,elemBC);
}



// ****************************************************************************
// * Cells initialization
// ****************************************************************************
‚àÄ cells void iniCells(void) in (node coord)
  out (cell v, cell e, cell volo, cell elemMass, cell calc_volume,
       cell p, cell q, cell sound_speed) @ -8.0{
  ‚Ñù¬≥ X[8];
  const ‚Ñù chaos = (((‚Ñù)uid)+1.0)*option_chaos_seed;
  v=1.0;
  ‚àÄ node X[n]=coord;
  e=(option_chaos)?chaos:(uid==0)?option_initial_energy:0.0;
  sound_speed=p=q=(option_chaos)?chaos;
  volo=elemMass=calc_volume=computeElemVolume(X);
  //debug()<<": e["<<uid<<"]="<<e<<", volume="<<calc_volume;
  //printf("\ne[%02d]=%.21e, volume=%.21e",uid,e,calc_volume);
}

‚àÄ nodes void iniNodalMass(void) in (cell calc_volume) out (node nodalMass) @ -6.9{
  //const int nid=uid;
  nodalMass=0.0;
  //if (nid==0) printf("\n[iniNodalMass] n=%d, Node #%d, nodalMass=%.21e",n,nid,nodalMass);
  ‚àÄ cell{
    /*
      const int a=xs_node_cell[8*nw+c];
    const int b=xs_node_cell[8*(nw+1)+c];
    const int xsa=2*WARP_BASE(a)+WARP_OFFSET(a);
    const int xsb=2*WARP_BASE(b)+WARP_OFFSET(b);
    debug()<<"a="<<a<<", xsa="<<xsa<<", b="<<b<<", xsb="<<xsb;
    */

    //int cid=node_cell[8*n+i];
    //if (cid<0) continue;
    //if (nid==0) printf("\n\tprefix: %d+=#%d nodalMass=%.21e (+=%.21e)",nid,cid,nodalMass,calc_volume/8.0);
    nodalMass+=calc_volume/8.0;
    //if (nid==0) printf("\n\tpostfix: %d+=#%d nodalMass=%.21e (+=%.21e)",nid,cid,nodalMass,calc_volume/8.0);
  }
  //debug()<<uid<<": nodalMass="<<nodalMass;
  //printf("\n#%d nodalMass=%.21e",uid,nodalMass);
}


// ****************************************************************************
// * Compute part @ ]+0,+‚àû[
// ****************************************************************************



// ****************************************************************************
// * timeIncrement
// * This routine computes the time increment Œ¥tn for the
// * current timestep loop iteration. We aim for a "target" value of t_final-tn
// * for Œ¥tn . However, the actual time increment is allowed to grow by a
// * certain prescribed amount from the value used in the previous step and is
// * subject to the constraints Œ¥t_Courant and Œ¥t_hydro described in Section 1.5.3.
// ****************************************************************************
void timeIncrement(void) @ 0.1 {
  const ‚Ñù target_Œ¥t = option_stoptime - time;
  const ‚Ñù max_Œ¥t = 1.0e+20;
  const ‚Ñù new_Œ¥t_courant = (Œ¥t_courant < max_Œ¥t)?¬Ω*Œ¥t_courant:max_Œ¥t;
  const ‚Ñù new_Œ¥t_courant_hydro = (Œ¥t_hydro < new_Œ¥t_courant)?Œ¥t_hydro*2.0/3.0:new_Œ¥t_courant;
  const ‚Ñù now_Œ¥t = new_Œ¥t_courant_hydro ;
  const ‚Ñù old_Œ¥t = (iteration==1)?option_Œ¥t_initial:Œ¥t;
  const ‚Ñù ratio = now_Œ¥t / old_Œ¥t ;
  const ‚Ñù up_new_Œ¥t = (ratio >= 1.0)?(ratio < option_Œ¥t_mult_lower_b)?old_Œ¥t:now_Œ¥t:now_Œ¥t;//option_Œ¥t_mult_lower_b
  const ‚Ñù dw_new_Œ¥t = (ratio >= 1.0)?(ratio > option_Œ¥t_mult_upper_b)?old_Œ¥t*option_Œ¥t_mult_upper_b:up_new_Œ¥t:up_new_Œ¥t;
  const ‚Ñù new_Œ¥t = (dw_new_Œ¥t > option_dtmax)?option_dtmax:dw_new_Œ¥t;
  const ‚Ñù Œ¥œÑ = (option_Œ¥t_fixed <= 0.0)?(iteration != 1)?new_Œ¥t:old_Œ¥t:old_Œ¥t;
  const ‚Ñù scaled_target_Œ¥t = (target_Œ¥t>Œ¥œÑ)?((target_Œ¥t<(4.0*Œ¥œÑ/3.0))?2.0*Œ¥œÑ/3.0:target_Œ¥t):target_Œ¥t;
  const ‚Ñù scaled_Œ¥t = (scaled_target_Œ¥t < Œ¥œÑ)?scaled_target_Œ¥t:Œ¥œÑ;
  Œ¥t = scaled_Œ¥t ;
  //Œ¥t = (iteration>1)?1.0-07;
  //Œ¥t = (iteration==2)?1.199999999999999892758e-07;
  //Œ¥t = (iteration==3)?1.439999999999999924249e-07;
  //Œ¥t <?= (scaled_Œ¥t);
  //info()<<"ITERATION "<<iteration;
  //printf("\nITERATION %d, time=%f, Œ¥t=%f (sum=%f)",iteration,time,Œ¥t,time+Œ¥t);
  if (((time+Œ¥t)==option_stoptime)?true:false)
    assert(X_EDGE_ELEMS==8 && Y_EDGE_ELEMS==8 && Z_EDGE_ELEMS==8 && iteration==470);
  if (iteration >= option_max_iterations) exit;
  //info()<< "\t\t\33[7mTimeIncrement Œ¥t="<<Œ¥t<<"\33[m";//0]
  //printf("\n\t\t\33[7mTimeIncrement dtt=%.21e\33[m", Œ¥t);
  //if (Œ¥t == 0.) exit;
}


// ****************************************************************************
// * Sum contributions to total stress tensor
// * pull in the stresses appropriate to the hydro integration
// * Initialize stress terms for each element. Recall that our assumption of
// * an inviscid isotropic stress tensor implies that the three principal
// * stress components are equal, and the shear stresses are zero.
// * Thus, we initialize the diagonal terms of the stress tensor to
// * -(p + q) in each element.
// ****************************************************************************
‚àÄ cells void initStressTermsForElems(void)
  in (node coord, cell p, cell q)
  out (cell Œµ, cell cForce) @ 0.3 {
  const ‚Ñù chaos = (((‚Ñù)0.0)+1.0)*option_chaos_seed;
  const ‚Ñù sig = (option_chaos)?chaos:-p-q;
  ‚Ñù¬≥ fNormals,dj,x[8],B[8];
  //debug()<<"sig="<<sig;
  ‚àÄ node x[n] = coord;
  Œµ = dj = -¬º*((x[0]+x[1]+x[5]+x[4])-(x[3]+x[2]+x[6]+x[7]));
  calcElemShapeFunctionDerivatives(x,B);
  ‚àÄ node B[n]=0.0;
  Œ£_FaceNormal(B,0,1,2,3,x);
  Œ£_FaceNormal(B,0,4,5,1,x);
  Œ£_FaceNormal(B,1,5,6,2,x);
  Œ£_FaceNormal(B,2,6,7,3,x);
  Œ£_FaceNormal(B,3,7,4,0,x);
  Œ£_FaceNormal(B,4,7,6,5,x);
  ‚àÄ node cForce = -sig*B[n];
  //printf("\n@0.3 cForce[%d]=(%.21e,%.21e,%.21e)",uid,cForce.x,cForce.y,cForce.z);
  }

‚àÄ nodes void fetchCellNodeForce0(void) in (cell cForce) out (node nForce)@0.301 {
  ‚Ñù¬≥ Œ£=‚Ñù¬≥(0.0,0.0,0.0);
  ‚àÄ cell{
    /*
      const int a=xs_node_cell[8*nw+c];
    const int b=xs_node_cell[8*(nw+1)+c];
    const int xsa=2*WARP_BASE(a)+WARP_OFFSET(a);
    const int xsb=2*WARP_BASE(b)+WARP_OFFSET(b);
    debug()<<"a="<<a<<", xsa="<<xsa<<", b="<<b<<", xsb="<<xsb;
    */
    //const int corner = node_cell_corner[8*n+i];
    //if (corner==-1) continue;
    //printf("\n[#%d] node_#%d is corner %d of cell %d",i,uid,corner,node_cell[8*n+i]);
    Œ£+=cForce;
  }
  nForce=Œ£;
  //debug()<<"@0.3 nForce="<<nForce;
  //printf("\n@0.3 nForce[%d]=(%.21e,%.21e,%.21e)",uid,nForce.x,nForce.y,nForce.z);
}

// ****************************************************************************
// * calcFBHourglassForceForElems
// * Calculates the Flanagan-Belytschko anti-hourglass force
// * calcFBHourglassForceForElems
// ****************************************************************************
‚àÄ cells void Œ£ElemStressesToNodeForces(void)
  in (node coord, cell volo, cell v,
      cell sound_speed, cell elemMass,
      node ùúïx)
  out (cell cForce)  @ 1.3{
  const ‚Ñù Œ≥[4][8]={{ 1., 1.,-1.,-1.,-1.,-1., 1., 1.},
                      { 1.,-1.,-1., 1.,-1., 1., 1.,-1.},
                      { 1.,-1., 1.,-1., 1.,-1., 1.,-1.},
                      {-1., 1.,-1., 1., 1.,-1., 1.,-1.}};
  ‚Ñù Œ∑0[4],Œ∑1[4],Œ∑2[4],Œ∑3[4] ;
  ‚Ñù Œ∑4[4],Œ∑5[4],Œ∑6[4],Œ∑7[4];
  ‚Ñù¬≥ x[8],xd[8],dvd[8],Œ∑[8];
  const ‚Ñù hourg=option_hgcoef;
  const ‚Ñù œÑv = volo*v;
  const ‚Ñù volume13=‚àõ(œÑv);
  const ‚Ñù Œ∏ = -hourg*0.01*sound_speed*elemMass/volume13;
  const ‚Ñù determ = œÑv;
  //const ‚Ñù chaos = (((‚Ñù)uid)+1.0)*option_chaos_seed;
  ‚àÄ node x[n] = coord;
  //‚àÄ node xd[n] = (option_chaos)?chaos:ùúïx;  
  ‚àÄ node xd[n] = ùúïx;  
  dvd[0]=ùúïVolume(x[1],x[2],x[3],x[4],x[5],x[7]);
  dvd[3]=ùúïVolume(x[0],x[1],x[2],x[7],x[4],x[6]);
  dvd[2]=ùúïVolume(x[3],x[0],x[1],x[6],x[7],x[5]);
  dvd[1]=ùúïVolume(x[2],x[3],x[0],x[5],x[6],x[4]);
  dvd[4]=ùúïVolume(x[7],x[6],x[5],x[0],x[3],x[1]);
  dvd[5]=ùúïVolume(x[4],x[7],x[6],x[1],x[0],x[2]);
  dvd[6]=ùúïVolume(x[5],x[4],x[7],x[2],x[1],x[3]);
  dvd[7]=ùúïVolume(x[6],x[5],x[4],x[3],x[2],x[0]);
  cHourglassModes(0,determ,dvd,Œ≥,x,Œ∑0,Œ∑1,Œ∑2,Œ∑3,Œ∑4,Œ∑5,Œ∑6,Œ∑7);
  //printf("\n[#%d] Œ∑[0]: %.21e,%.21e,%.21e,%.21e,%.21e,%.21e,%.21e,%.21e",uid, Œ∑0[0],Œ∑1[0],Œ∑2[0],Œ∑3[0],Œ∑4[0],Œ∑5[0],Œ∑6[0],Œ∑7[0]);
  cHourglassModes(1,determ,dvd,Œ≥,x,Œ∑0,Œ∑1,Œ∑2,Œ∑3,Œ∑4,Œ∑5,Œ∑6,Œ∑7);
  //rintf("\n[#%d] Œ∑[1]: %.21e,%.21e,%.21e,%.21e,%.21e,%.21e,%.21e,%.21e",uid, Œ∑0[1],Œ∑1[1],Œ∑2[1],Œ∑3[1],Œ∑4[1],Œ∑5[1],Œ∑6[1],Œ∑7[1]);
  cHourglassModes(2,determ,dvd,Œ≥,x,Œ∑0,Œ∑1,Œ∑2,Œ∑3,Œ∑4,Œ∑5,Œ∑6,Œ∑7);
  //printf("\n[#%d] Œ∑[2]: %.21e,%.21e,%.21e,%.21e,%.21e,%.21e,%.21e,%.21e",uid, Œ∑0[2],Œ∑1[2],Œ∑2[2],Œ∑3[2],Œ∑4[2],Œ∑5[2],Œ∑6[2],Œ∑7[2]);
  cHourglassModes(3,determ,dvd,Œ≥,x,Œ∑0,Œ∑1,Œ∑2,Œ∑3,Œ∑4,Œ∑5,Œ∑6,Œ∑7);
  //printf("\n[#%d] Œ∑[3]: %.21e,%.21e,%.21e,%.21e,%.21e,%.21e,%.21e,%.21e",uid, Œ∑0[3],Œ∑1[3],Œ∑2[3],Œ∑3[3],Œ∑4[3],Œ∑5[3],Œ∑6[3],Œ∑7[3]);
  //debug()<<"hourg="<<hourg<<", sound_speed="<<sound_speed<<", elemMass="<<elemMass;
  //printf("\nŒ∏[%d]=%.21e",uid,Œ∏);
  calcElemFBHourglassForce(xd,Œ∑0,Œ∑1,Œ∑2,Œ∑3,Œ∑4,Œ∑5,Œ∑6,Œ∑7,Œ∏,Œ∑);
  //foreach node debug()<<uid<<" "<<n<<" hgf="<<Œ∑[n];
  //‚àÄ node printf("\n[#%d] Œ∑[%d]=(%.21e,%.21e,%.21e)",uid,n,Œ∑[n].x,Œ∑[n].y,Œ∑[n].z);
  ‚àÄ node cForce = Œ∑[n];
//#warning cForce chaos
    //foreach node cForce += Œ∑[n];
  //foreach node cForce = (n+1.0)*1.1234567890123456789;
  //printf("\n@1.3 cForce[%d]=(%.21e,%.21e,%.21e)",uid,cForce.x,cForce.y,cForce.z);
}

‚àÄ nodes void Œ£CellNodeForce(void) in (cell cForce) out (node nForce)@ 1.4 {
  ‚Ñù¬≥ Œ£=‚Ñù¬≥(0.0,0.0,0.0);//0.0;
  foreach cell Œ£+=cForce;
  nForce+=Œ£;
  //debug()<<"@1.4 nForce="<<nForce;
  //printf("\n@1.4 nForce[%d]=(%.21e,%.21e,%.21e)",uid,nForce.x,nForce.y,nForce.z);
}


// ****************************************************************************
// * The routine CalcAccelerationForNodes() calculates a three-dimensional
// * acceleration vector A at each mesh node from F.
// * The acceleration is computed using Newton's Second Law of Motion,
// * F = m0 A, where m0 is the mass at the node.
// * Note that since the mass in each element is constant in time for our calculations,
// * the mass at each node is also constant in time.
// * The nodal mass values are set during the problem set up.
// ****************************************************************************
‚àÄ nodes void ùúïùúïForNodes(void)
  in (node nForce, node nodalMass) out (node ùúïùúïx) @ 2.8{
  ùúïùúïx = nForce/nodalMass;
  //debug()<<"ùúïùúïx="<<ùúïùúïx;
}

// ****************************************************************************
// * The routine ApplyAccelerationBoundaryConditions() applies symmetry boundary
// * conditions at nodes on the boundaries of the mesh where these were specified
// * during problem set up. A symmetry boundary condition sets the normal
// * component of A at the boundary to zero.
// * This implies that the normal component of the velocity vector U will
// * remain constant in time.
// ****************************************************************************
‚àÄ outer nodes void ùúïùúïBCForNodes(void)
  out (node ùúïùúïx) @ 2.9 {
  ùúïùúïx.x=(coord.x==0.0)?0.0;
  ùúïùúïx.y=(coord.y==0.0)?0.0;
  ùúïùúïx.z=(coord.z==0.0)?0.0;
}


// ****************************************************************************
// * The routine CalcVelocityForNodes() integrates the acceleration at each node
// * to advance the velocity at the node to tn+1.
// * Note that this routine also applies a cut-off to each velocity vector value.
// * Specifically, if a value is below some prescribed value, that term is set to zero.
// * The reason for this cutoff is to prevent spurious mesh motion which may arise
// * due to floating point roundoff error when the velocity is near zero.
// ****************************************************************************
‚àÄ nodes void ùúïForNodes(void) in (node ùúïùúïx) inout (node ùúïx) @ 3.0{
  ùúïx += ùúïùúïx*Œ¥t ;
  ùúïx.x = (norm(ùúïx.x)<option_u_cut)?0.0;
  ùúïx.y = (norm(ùúïx.y)<option_u_cut)?0.0;
  ùúïx.z = (norm(ùúïx.z)<option_u_cut)?0.0;
  //debug()<<"ùúïx="<<ùúïx;
  //printf("\nvelocity[%d]=(%.21e,%.21e,%.21e)",uid,ùúïx.x,ùúïx.y,ùúïx.z);
}


// ****************************************************************************
// * The routine CalcPositionForNodes() performs the last step in the nodal
// * advance portion of the algorithm by integrating the velocity at each node
// * to advance the position of the node to tn+1.
// ****************************************************************************
‚àÄ nodes void coordForNodes(void) in (node ùúïx) @ 3.1{
  coord += ùúïx*Œ¥t;
  //debug()<<"coords= "<<coord;
  //printf("\ncoords[%d]=(%.21e,%.21e,%.21e)",uid,coord.x,coord.y,coord.z);
}


// ****************************************************************************
// * calcElemVolume
// ****************************************************************************
‚àÄ cells void calcElemVolume(void)
  in (node coord, node ùúïx,cell v, volo, delx_xi, delv_xi,
      cell delx_eta, delv_eta, delx_zeta, delv_zeta)
  inout (cell Œµ) out (cell delv, vnew, calc_volume, vdov, arealg) @ 4.0{
  const ‚Ñù dt2= ¬Ω*Œ¥t;
  const ‚Ñù Œ¥ = 1.e-36;
  ‚Ñù¬≥ B[8],X[8],Xd[8];
  ‚Ñù DetJ,volume,œÅVolume;
  foreach node X[n]=coord;
  foreach node Xd[n]=ùúïx;
  //printf("\n[#%d] Xd[1]=(%.21e,%.21e,%.21e)",uid, Xd[1].x, Xd[1].y, Xd[1].z);
  volume = calc_volume = computeElemVolume(X);  
  vnew = œÅVolume = volume/volo;
  delv = œÅVolume - v;
  //printf("\n[#%d] volume=%.21e, volo=%.21e, œÅVolume=%.21e, delv=%.21e",uid, volume, volo, œÅVolume, delv);
  arealg = calcElemCharacteristicLength(X,volume);
  //debug()<<"arealg="<<arealg;
  {
    const ‚Ñù vol = volo*vnew;
    const ‚Ñù nrm = 1.0/(vol+Œ¥);
    const ‚Ñù¬≥ di =  ¬º*((X[1]+X[2]+X[6]+X[5])-(X[0]+X[3]+X[7]+X[4]));
    const ‚Ñù¬≥ dj = -¬º*((X[0]+X[1]+X[5]+X[4])-(X[3]+X[2]+X[6]+X[7]));
    const ‚Ñù¬≥ dk =  ¬º*((X[4]+X[5]+X[6]+X[7])-(X[0]+X[1]+X[2]+X[3]));
    const ‚Ñù¬≥ a_xi = (dj‚®Ødk);
    const ‚Ñù¬≥ a_eta = (dk‚®Ødi);
    const ‚Ñù¬≥ a_zeta = (di‚®Ødj);
    const ‚Ñù¬≥ dv_xi  =  ¬º*((Xd[1]+Xd[2]+Xd[6]+Xd[5])-(Xd[0]+Xd[3]+Xd[7]+Xd[4]));
    const ‚Ñù¬≥ dv_eta = -¬º*((Xd[0]+Xd[1]+Xd[5]+Xd[4])-(Xd[3]+Xd[2]+Xd[6]+Xd[7]));
    const ‚Ñù¬≥ dv_zeta = ¬º*((Xd[4]+Xd[5]+Xd[6]+Xd[7])-(Xd[0]+Xd[1]+Xd[2]+Xd[3]));
    delx_xi = vol/‚àö(a_xi‚ãÖa_xi+Œ¥);
    delx_eta = vol/‚àö(a_eta‚ãÖa_eta+Œ¥);
    delx_zeta = vol/‚àö(a_zeta‚ãÖa_zeta+Œ¥);
    delv_zeta = (a_zeta*nrm)‚ãÖdv_zeta;     
    delv_xi = (a_xi*nrm)‚ãÖdv_xi;
    delv_eta = (a_eta*nrm)‚ãÖdv_eta;
  }
  foreach node X[n] -= dt2*Xd[n];
  DetJ=calcElemShapeFunctionDerivatives(X,B);
  //printf("\n[#%d] DetJ=%.21e",uid, DetJ);
  //printf("\n[#%d] B[0]=(%.21e,%.21e,%.21e)",uid, B[0].x, B[0].y, B[0].z);
  //printf("\n[#%d] B[1]=(%.21e,%.21e,%.21e)",uid, B[1].x, B[1].y, B[1].z);
  //printf("\n[#%d] B[2]=(%.21e,%.21e,%.21e)",uid, B[2].x, B[2].y, B[2].z);
  //printf("\n[#%d] B[3]=(%.21e,%.21e,%.21e)",uid, B[3].x, B[3].y, B[3].z);
  
  //printf("\n[#%d] Xd[0]=(%.21e,%.21e,%.21e)",uid, Xd[0].x, Xd[0].y, Xd[0].z);
  //printf("\n[#%d] Xd[1]=(%.21e,%.21e,%.21e)",uid, Xd[1].x, Xd[1].y, Xd[1].z);
  //printf("\n[#%d] Xd[2]=(%.21e,%.21e,%.21e)",uid, Xd[2].x, Xd[2].y, Xd[2].z);
  //printf("\n[#%d] Xd[3]=(%.21e,%.21e,%.21e)",uid, Xd[3].x, Xd[3].y, Xd[3].z);
  //printf("\n[#%d] Xd[4]=(%.21e,%.21e,%.21e)",uid, Xd[4].x, Xd[4].y, Xd[4].z);
  //printf("\n[#%d] Xd[5]=(%.21e,%.21e,%.21e)",uid, Xd[5].x, Xd[5].y, Xd[5].z);
  //printf("\n[#%d] Xd[6]=(%.21e,%.21e,%.21e)",uid, Xd[6].x, Xd[6].y, Xd[6].z);
  //printf("\n[#%d] Xd[7]=(%.21e,%.21e,%.21e)",uid, Xd[7].x, Xd[7].y, Xd[7].z);
  Œµ=calcElemVelocityGradient(Xd,B,DetJ);
  //printf("\n[#%d] Epsilon=(%.21e,%.21e,%.21e)",uid, Œµ.x, Œµ.y, Œµ.z);
  //calc strain rate and apply as constraint
  vdov = Œµ.x+Œµ.y+Œµ.z;
  //printf("\n[#%d] vdov=%.21e",uid, vdov);
  // make the rate of deformation tensor deviatoric
  //Œµ -= ‚Öì*vdov;
  const ‚Ñù tvdov = ‚Öì*vdov;
  const ‚Ñù¬≥ t3vdov = ‚Ñù¬≥(tvdov,tvdov,tvdov);
  Œµ -= t3vdov;
  // See if any volumes are negative, and take appropriate action.
  //assert(vnew >= 0.0);//fatal("calcLagrangeElements","VolumeError");
}


// ****************************************************************************
// * This routine performs the second part of the q calculation.
// ****************************************************************************
‚àÄ cells void calcMonotonicQForElemsByDirectionX(void)
  in (cell elemBC, cell delv_xi) out (cell phixi) @ 4.7 {
  const ‚Ñù monoq_limiter_mult = option_monoq_limiter_mult;
  const ‚Ñù monoq_max_slope = option_monoq_max_slope;
  ‚Ñ§ bcSwitch;
  ‚Ñù delvm=0.0;
  ‚Ñù delvp=0.0;
  const ‚Ñù ptiny = 1.e-36;
  const ‚Ñù nrm = 1./(delv_xi+ptiny);
  bcSwitch = elemBC & XI_M;
  delvm = (bcSwitch == 0)?delv_xi[prevCellX];
  delvm = (bcSwitch == XI_M_SYMM)?delv_xi;
  delvm = (bcSwitch == XI_M_FREE)?0.0;
  delvm = delvm * nrm ;
  bcSwitch = elemBC & XI_P;
  delvp = (bcSwitch == 0)?delv_xi[nextCellX];
  delvp = (bcSwitch == XI_P_SYMM)?delv_xi;
  delvp = (bcSwitch == XI_P_FREE)?0.0;
  delvp = delvp * nrm ;
  phixi = ¬Ω * (delvm + delvp) ;
  delvm *= monoq_limiter_mult ;
  delvp *= monoq_limiter_mult ;
  phixi = (delvm < phixi)?delvm;
  phixi = (delvp < phixi)?delvp;
  phixi = (phixi < 0.)?0.0;
  phixi = (phixi > monoq_max_slope)?monoq_max_slope;
  }

‚àÄ cells void calcMonotonicQForElemsByDirectionY(void)
  in (cell elemBC, cell delv_eta) out (cell phieta) @ 4.7 {
  const ‚Ñù monoq_limiter_mult = option_monoq_limiter_mult;
  const ‚Ñù monoq_max_slope = option_monoq_max_slope;
  ‚Ñ§ bcSwitch;
  ‚Ñù delvm=0.;
  ‚Ñù delvp=0.;
  const ‚Ñù ptiny = 1.e-36;
  const ‚Ñù nrm = 1./(delv_eta+ptiny);
  bcSwitch = elemBC & ETA_M;
  delvm = (bcSwitch == 0)?delv_eta[prevCellY];
  delvm = (bcSwitch == ETA_M_SYMM)?delv_eta;
  delvm = (bcSwitch == ETA_M_FREE)?0.0;
  delvm = delvm * nrm ;
  bcSwitch = elemBC & ETA_P;
  delvp = (bcSwitch == 0)?delv_eta[nextCellY];
  delvp = (bcSwitch == ETA_P_SYMM)?delv_eta;
  delvp = (bcSwitch == ETA_P_FREE)?0.0;
  delvp = delvp * nrm ;
  phieta = ¬Ω*(delvm + delvp) ;
  delvm *= monoq_limiter_mult ;
  delvp *= monoq_limiter_mult ;
  phieta = (delvm  < phieta)?delvm;
  phieta = (delvp  < phieta)?delvp;
  phieta = (phieta < 0.0)?0.0;
  phieta = (phieta > monoq_max_slope)?monoq_max_slope;
}

‚àÄ cells void calcMonotonicQForElemsByDirectionZ(void)
  in (cell elemBC, cell delv_zeta) out (cell phizeta) @ 4.7 {
  const ‚Ñù monoq_limiter_mult = option_monoq_limiter_mult;
  const ‚Ñù monoq_max_slope = option_monoq_max_slope;
  ‚Ñ§ bcSwitch;
  ‚Ñù delvm=0.;
  ‚Ñù delvp=0.;
  const ‚Ñù ptiny = 1.e-36;
  const ‚Ñù nrm = 1./(delv_zeta+ptiny) ;
  bcSwitch = elemBC & ZETA_M;
  delvm = (bcSwitch == 0)?delv_zeta[prevCellZ];
  delvm = (bcSwitch == ZETA_M_SYMM)?delv_zeta;
  delvm = (bcSwitch == ZETA_M_FREE)?0.0;
  delvm = delvm * nrm ;
  bcSwitch = elemBC & ZETA_P;
  delvp = (bcSwitch == 0)?delv_zeta[nextCellZ];
  delvp = (bcSwitch == ZETA_P_SYMM)?delv_zeta;
  delvp = (bcSwitch == ZETA_P_FREE)?0.0;
  delvp = delvp * nrm ;
  phizeta = ¬Ω*(delvm+delvp);
  delvm *= monoq_limiter_mult ;
  delvp *= monoq_limiter_mult ;
  phizeta = (delvm < phizeta )?delvm;
  phizeta = (delvp < phizeta )?delvp;
  phizeta = (phizeta < 0.0)?0.0;
  phizeta = (phizeta > monoq_max_slope )?monoq_max_slope;
}

‚àÄ cells void calcMonotonicQForElemsQQQL(void)
  in (cell vdov, cell elemMass, cell volo, cell vnew,
      cell delx_xi, cell delv_eta, cell delx_eta,
      cell delv_zeta, cell delx_zeta, cell delv_xi,
      cell phixi, cell phieta, cell phizeta)
  out(cell qq, cell ql)@ 4.72{
  const ‚Ñù rho = elemMass/(volo*vnew);
  const ‚Ñù qlc_monoq = option_qlc_monoq;
  const ‚Ñù qqc_monoq = option_qqc_monoq;
  const ‚Ñù delvxxi   = delv_xi*delx_xi;
  const ‚Ñù delvxeta  = delv_eta*delx_eta;
  const ‚Ñù delvxzeta = delv_zeta*delx_zeta;
  const ‚Ñù delvxxit  = (delvxxi>0.0)?0.0:delvxxi;
  const ‚Ñù delvxetat = (delvxeta>0.0)?0.0:delvxeta;
  const ‚Ñù delvxzetat= (delvxzeta>0.0)?0.0:delvxzeta;
  const ‚Ñù qlin = -qlc_monoq*rho*(delvxxit*(1.0-phixi)+
                                    delvxetat*(1.0-phieta)+
                                    delvxzetat*(1.0-phizeta));
  const ‚Ñù qquad = qqc_monoq*rho*(delvxxit*delvxxit*(1.0-phixi*phixi) +
                                    delvxetat*delvxetat*(1.0-phieta*phieta) +
                                    delvxzetat*delvxzetat*(1.0-phizeta*phizeta));
  const ‚Ñù qlint  = (vdov>0.0)?0.0:qlin;  // Remove length scale
  const ‚Ñù qquadt = (vdov>0.0)?0.0:qquad;
  qq = qquadt ;
  ql = qlint  ;
  //debug()<<"phixi="<<phixi<<" phieta="<<phieta<<" phizeta="<<phizeta;
  //printf("\nphixi=%.21e phieta=%.21e phizeta=%.21e",phixi,phieta,phizeta);
  //debug()<<"ql="<<ql<<", qq="<<qq;
  //ok printf("\n[#%02d] ql=%.21e, qq=%.21e",uid, ql,qq);
}



// ****************************************************************************
// * The routine ApplyMaterialPropertiesForElems() updates the pressure and
// * internal energy variables to their values at the new time, p_n+1 and e_n+1.
// * The routine first initializes a temporary array with the values of Vn+1 for
// * each element that was computed earlier. Then, upper and lower cut-off
// * values are applied to each array value to keep the relative volumes
// * within a prescribed range (not too close to zero and not too large).
// * Next, the routine EvalEOSForElems() is called and the array of modified
// * relative element volumes is passed to it.
// ****************************************************************************
‚àÄ cells void applyMaterialPropertiesForElems(void)
  in (cell vnew) out(cell vnewc) @ 5.0{
  vnewc = vnew ;
  vnewc = (vnewc < option_eosvmin)?option_eosvmin;
  vnewc = (vnewc > option_eosvmax)?option_eosvmax;
}


// ****************************************************************************
// * The routine EvalEOSForElems() calculates updated values for pressure p_n+1
// * and internal energy e_n+1.
// * The computation involves several loops over elements to pack various mesh
// * element arrays (e.g., p, e, q, etc.) into local temporary arrays.
// * Several other quantities are computed and stored in element length
// * temporary arrays also.
// * The temporary arrays are needed because the routine CalcEnergyForElems()
// * calculates p_n+1 and e_n+1 in each element in an iterative process that
// * requires knowledge of those variables at time tn while it computes the
// * new time values.
// ****************************************************************************
‚àÄ cells void evalEOSForElems0(void)
  in (cell e, cell delv, cell p, cell q, cell vnewc)
  out(cell e_old, cell delvc, cell p_old, cell q_old,
      cell compression, cell compHalfStep,cell work) @ 6.0{
  const ‚Ñù vchalf = vnewc - ( ¬Ω*delv);
  work = 0.0; 
  e_old = e;
  delvc = delv;
  p_old = p;
  q_old = q ;
  compression = (1.0/vnewc) - 1.0;
  compHalfStep = (1.0/vchalf)-1.0;
}

‚àÄ cells void evalEOSForElems1(void)
  in (cell vnewc, cell compression)
  out(cell compHalfStep) @ 6.1 {
  compHalfStep = (vnewc <= option_eosvmin)?compression;
}

‚àÄ cells void evalEOSForElems6(void)
  in (cell vnewc, cell compHalfStep)
  out(cell p_old, cell compression) @ 6.6 {
  p_old = (vnewc < option_eosvmax)?p_old:0.0;
  compression =(vnewc < option_eosvmax)?compression:0.0;
  compHalfStep = (vnewc < option_eosvmax)?compHalfStep:0.0;
}


// ****************************************************************************
// * The routine CalcEnergyForElems() calls CalcPressureForElems() repeatedly.
// * The function CalcPressureForElems() is the Equation of State model
// * for a "gamma law" gas.
// * The value c1s passed to the routine is defined to be Œ≥ - 1.
// * The Equation of State calculation is a core part of any hydrocode.
// * In a production code, one of any number of Equation of State functions
// * may be called to generate a pressure that is needed to close the system
// * of equations and generate a unique solution.
// ****************************************************************************
// @ 7.1   calcEnergyForElems1
‚àÄ cells void calcEnergyForElems1(void)
  in (cell e_old, cell delvc, cell p_old, cell q_old, cell work)
  inout (cell e_new) @ 7.1{
  e_new = e_old - ¬Ω*delvc*(p_old + q_old) + ¬Ω*work;
  e_new = (e_new < option_emin)?option_emin;
  //debug()<<"vchalf="<<(vnewc-(¬Ω*delv));
  //debug()<<"e_old="<<e_old<<", delvc="<< delvc <<", work="<< work<<", e_new="<<e_new;
  //ok printf("\n[#%d] e_old=%.21e, delvc=%.21e, work=%.21e, e_new=%.21e",uid,e_old, delvc, work, e_new);
}


// ****************************************************************************
// * calcPressureForElems
// * p_new => pHalfStep
// * compression => compHalfStep
// * e_old => e_new
// ****************************************************************************
‚àÄ cells void calcPressureForElemspHalfStepcompHalfStep(void)
  in (cell compHalfStep, cell e_new) 
  inout(cell bvc, cell pHalfStep)
  out (cell vnewc, cell pbvc) @ 7.2{
  const ‚Ñù c1s = 2.0/3.0;
  bvc = c1s*(compHalfStep+1.0);
  pbvc = c1s;
  pHalfStep = bvc*e_new ;
  pHalfStep=(rabs(pHalfStep)<option_p_cut)?0.0;
  pHalfStep = (vnewc >= option_eosvmax )?0.0; // impossible condition here?
  pHalfStep = (pHalfStep < option_pmin)?option_pmin;
  //debug()<<"pHalfStep="<<pHalfStep<<", bvc="<<bvc<<", pbvc="<<pbvc<<", e_new="<<e_new;
  //printf("\npHalfStep=%.21e, bvc=%.21e, pbvc=%.21e, e_new=%.21e",pHalfStep, bvc, pbvc, e_new);
  //debug()<<"compHalfStep="<<compHalfStep<<", vnewc="<<vnewc<<", pmin="<<option_pmin<<", p_cut="<<option_p_cut;
}

inline ‚Ñù computeSoundSpeed(const ‚Ñù c,//pbvc
                           const ‚Ñù energy,
                           const ‚Ñù volume,
                           const ‚Ñù b,//bvc
                           const ‚Ñù pressure,
                           const ‚Ñù rho,
                           const ‚Ñù _ql,
                           const ‚Ñù _qq){
  const ‚Ñù pe = c*energy;
  const ‚Ñù vvbp=volume*volume*b*pressure;
  const ‚Ñù ssc = (pe + vvbp)/rho;
  const ‚Ñù ssct = (ssc <= 0.111111e-36)?0.333333e-18:‚àö(ssc);
  const ‚Ñù sscq = ssct*_ql;
  const ‚Ñù sscqt = sscq+_qq;
  return sscqt;
}
inline ‚Ñù computeSoundSpeed(const ‚Ñù c,//pbvc
                           const ‚Ñù energy,
                           const ‚Ñù volume,
                           const ‚Ñù b,//bvc
                           const ‚Ñù pressure,
                           const ‚Ñù rho){
  const ‚Ñù pe = c*energy;
  const ‚Ñù vvbp=volume*volume*b*pressure;
  const ‚Ñù ssc = (pe + vvbp)/rho;
  const ‚Ñù ssct = (ssc <= 0.111111e-36)?0.333333e-18:‚àö(ssc);
  return ssct;
}

‚àÄ cells void calcEnergyForElems3(void)
  in (cell compHalfStep, cell delvc, cell pbvc, cell ql, cell qq,
      cell bvc, cell pHalfStep, cell p_old, cell q_old)
  out (cell q_new)
  inout (cell e_new) @ 7.3 {
  const ‚Ñù vhalf = 1.0/(1.0+compHalfStep);
  const ‚Ñù ssc = computeSoundSpeed(pbvc,e_new,vhalf,bvc,pHalfStep,option_refdens,ql,qq);
  q_new = (delvc>0.0)?0.0:ssc;//(ssct*ql + qq);
  e_new = e_new + ¬Ω*delvc*(3.0*(p_old+q_old)-4.0*(pHalfStep+q_new)) ;
  //ok printf("\n[#%02d] q_new=%.21e, e_new=%.21e",uid,q_new,e_new);
}

‚àÄ cells void calcEnergyForElems4(void) in (cell work)
  inout (cell e_new)@ 7.4{
  e_new += ¬Ω*work;
  e_new = (rabs(e_new) < option_e_cut)?0.0;
  e_new = (e_new<option_emin)?option_emin;
  //debug()<<"q_new="<<q_new<<", e_new="<<e_new;
  //printf("\n[#%02d] e_new=%.21e",uid,e_new);
}

‚àÄ cells void calcPressureForElemsPNewCompression(void)
  in (cell compression,
      cell bvc,
      cell e_new, cell vnewc)
      inout (cell pbvc, cell p_new) @ 7.5,7.7{
  const ‚Ñù c1s = 2.0/3.0;
  bvc = c1s*(compression + 1.0);
  pbvc = c1s;
  p_new = bvc*e_new ;
  p_new = (rabs(p_new) < option_p_cut)?0.0;
  p_new = (vnewc >= option_eosvmax )?0.0;
  p_new = (p_new < option_pmin)?option_pmin;
}

‚àÄ cells void calcEnergyForElems6(void)
  in (cell delvc, cell bvc,cell pbvc, cell vnewc, cell p_new, cell ql,
      cell qq, cell p_old, cell q_old, cell pHalfStep, cell q_new)
  inout(cell e_new)@ 7.6{
  const ‚Ñù sixth = 1.0/6.0;
  //const ‚Ñù ssc = ( pbvc*e_new + vnewc*vnewc*bvc*p_new)/option_refdens;
  //const ‚Ñù ssct = (ssc <= 0.111111e-36)?0.333333e-18:‚àö(ssc);
  const ‚Ñù ssc = computeSoundSpeed(pbvc,e_new,vnewc,bvc,p_new,option_refdens,ql,qq);
  const ‚Ñù q_tilde = (delvc > 0.)?0.0:ssc;//(ssct*ql + qq);
  //debug()<<"ssc="<<ssct;
  //debug()<<"pbvc="<<pbvc<<" e_new="<<e_new<<" vnewc="<<vnewc
  //<<" bvc="<<bvc<<" p_new="<<p_new <<" rho0="<<option_refdens;
  e_new = e_new - (7.0*(p_old + q_old)
                   - (8.0)*(pHalfStep + q_new)
                   + (p_new + q_tilde)) * delvc*sixth ;
  //debug()<<"e_new="<<e_new;
  e_new = (rabs(e_new) < option_e_cut)?0.0;
  e_new = (e_new < option_emin)?option_emin;
  //debug()<<"e_new="<<e_new;
  //ok printf("\n[#%02d] e_new=%.21e",uid,e_new);
}

‚àÄ cells void calcEnergyForElems8(void)
  in (cell delvc, cell bvc, cell pbvc, cell e_new,
      cell vnewc, cell p_new, cell ql, cell qq)
  inout(cell q_new)@ 7.8{
  const ‚Ñù qnw = computeSoundSpeed(pbvc,e_new,vnewc,bvc,p_new,option_refdens,ql,qq);
  const ‚Ñù qnwt = (rabs(qnw) < option_q_cut)?0.0:qnw;
  //printf("\n[#%02d] pe=%.21e, vvbp=%.21e, ss=%.21e",uid,pe,vvbp,ss);
  //printf("\n[#%02d] ssc=%.21e, ssct=%.21e, sq=%.21e, qnw=%.21e, qnwt=%.21e",uid,ssc,ssct,sq,qnw,qnwt);
  //debug()<<"pbvc="<<pbvc<<" e_new="<<e_new<<" vnewc="<<vnewc
  //<<" bvc="<<bvc<<" p_new="<<p_new <<" rho0="<<option_refdens;
  //debug()<<"8 delvc="<<delvc;
  //debug()<<"8 ssc="<<ssct;
  q_new = (delvc <= 0.)?qnwt;
  //debug()<<"8 q_new="<<q_new;
  //printf("\n[#%02d] pe=%.21e, vvbp=%.21e, ssc=%.21e, ssct=%.21e, qnw=%.21e, qnwt=%.21e",uid,pe,vvbp,ssc,ssct,qnw,qnwt);
  //printf("\n[#%02d] q_new=%.21e",uid,q_new);
}

‚àÄ cells void evalEOSForElems8(void)
  in (cell p_new, cell e_new, cell q_new)
  out(cell p, cell e, cell q)@ 8.0{
  p = p_new;
  e = e_new;
  q = q_new;
  //debug()<<"p_new="<<p_new<<" e_new="<< e_new <<" q_new="<< q_new;
  //printf("\n[#%02d] p_new=%.21e, e_new=%.21e, q_new=%.21e",uid,p_new, e_new, q_new);
}


// ****************************************************************************
// * Lastly, the routine CalcSoundSpeedForElems() calculates the sound speed
// * sound_speed in each element using p_n+1 and e_n+1.
// * The maximum value of sound_speed is used to calculate constraints on t_n+1
// * which will be used for the next time advance step.
// ****************************************************************************
‚àÄ cells void calcSoundSpeedForElems(void)
  in (cell bvc, cell pbvc, cell e_new, cell vnewc, cell p_new)
  out (cell sound_speed) @ 9.0{
  //foreach material
  {
    //debug()<<"pbvc="<<pbvc<<" e_new="<<e_new<<" vnewc="<<vnewc<<" bvc="<<bvc<<" p_new="<<p_new <<" rho0="<<option_refdens;
    //const ‚Ñù ssTmp = (pbvc*e_new + vnewc*vnewc*bvc*p_new)/option_refdens;
    //const ‚Ñù ssTmpt = (ssTmp <= 0.111111e-36)?0.333333e-18:‚àö(ssTmp);
    const ‚Ñù ssTmpt = computeSoundSpeed(pbvc,e_new,vnewc,bvc,p_new,option_refdens);
    sound_speed = ssTmpt;
    //debug()<<"calcSoundSpeedForElems sound_speed="<<sound_speed;
    //ok printf("\n[#%d] sound_speed=%.21e",uid,sound_speed);
  }
}


// ****************************************************************************
// * The routine UpdateVolumesForElems() updates the relative volume to V_n+1.
// * This routine basically resets the current volume V_n in each element to
// * the new volume V_n+1 so the simulation can continue to the next time
// * increment.
// * Note that this routine applies a cut-off to the relative volume V in
// * each element. Specifically, if V is sufficiently close to one (a
// * prescribed tolerance), then V is set to one.
// * The reason for this cutoff is to prevent spurious deviations of volume
// * from their initial values which may arise due to floating point roundoff
// * error.
// ****************************************************************************
‚àÄ cells void updateVolumesForElems(void)
  in (cell vnew) out (cell v) @ 10.0{
  const ‚Ñù ŒΩ = vnew;
  const ‚Ñù ŒΩt = (rabs(ŒΩ-1.0)<option_v_cut)?1.0:ŒΩ;
  v = ŒΩt;
  //debug()<<"updateVolumesForElems v="<<v;
  //ok printf("\n[#%d] v=%.21e",uid,v);
}


// ****************************************************************************
// * The routine CalcCourantConstraintForElems() calculates the Courant timestep
// * constraint Œ¥t_Courant. This constraint is calculated only in elements
// * whose volumes are changing that is, dV/V!=0.
// * If all element volumes remain the same, there is no Courant constraint
// * applied during the subsequent Œ¥t calculation.
// ****************************************************************************
‚àÄ cells void calcCourantConstraintForElems(void)
  in (cell sound_speed, cell arealg, cell vdov)
  out (cell Œ¥t_cell_courant) @ 12.1{
  const ‚Ñù arg_max_courant=1.0e+20;
  Œ¥t_cell_courant=arg_max_courant;
  //foreach material
  {
    const ‚Ñù qqc2 = 64.0 * option_qqc * option_qqc ;
    const ‚Ñù Œ¥f = sound_speed[m] * sound_speed[m];
    const ‚Ñù Œ¥ft=(vdov[m]<0.0)?qqc2*arealg[m]*arealg[m]*vdov[m]*vdov[m]:0.0;
    const ‚Ñù Œ¥fpp = Œ¥f+Œ¥ft;
    const ‚Ñù Œ¥fp = ‚àö(Œ¥fpp);
    const ‚Ñù aŒ¥fp = arealg[m]/Œ¥fp;
    //ok printf("\n[#%d] vdov=%.21e, arealg=%.21e, sound_speed=%.21e, aŒ¥fp=%.21e",uid,vdov,arealg,sound_speed,aŒ¥fp);
    Œ¥t_cell_courant=(vdov!=0.0)?min(arg_max_courant,aŒ¥fp);
    //debug()<<"dtcourant="<<dtcourant;
    //ok printf("\n[#%d] dtcourant=%.21e",uid,dtcourant);
  }
  //return dtcourant;
} 


// ****************************************************************************
// * The routine CalcHydroConstraintForElems() calculates the hydro timestep
// * constraint. Similar to Œ¥t_Courant, Œ¥t_hydro is calculated only in elements
// * whose volumes are changing. When an element is undergoing volume change,
// * Œ¥t_hydro for the element is some maximum allowable element volume change
// * (prescribed) divided by dV/V in the element.
// ****************************************************************************
‚àÄ cells void calcHydroConstraintForElems(void)
  in (cell vdov) out (cell Œ¥t_cell_hydro) @ 12.2{
  const ‚Ñù arg_max_hydro=1.0e+20;
  Œ¥t_cell_hydro=arg_max_hydro;
  //foreach material
  {
    const ‚Ñù Œ¥dv = rabs(vdov[m]);
    const ‚Ñù Œ¥dve = Œ¥dv+1.e-20;
    const ‚Ñù Œ¥dvov = option_dvovmax/Œ¥dve;
    const ‚Ñù Œ¥hdr = min(arg_max_hydro,Œ¥dvov);
    //debug()<<"vdov="<<vdov<<" dtdvov="<<dtdvov<<" dvovmax="<<option_dvovmax;
    //printf("\n[#%d] vdov=%.21e, dtdvov=%.21e, dvovmax=%.21e,",uid,vdov,dtdvov,option_dvovmax);
    Œ¥t_cell_hydro=(vdov!=0.0)?Œ¥hdr;
    //info()<<"Œ¥t_cell_hydro="<<Œ¥t_cell_hydro;
    //printf("\n[#%d] Œ¥dvov=%.21e, Œ¥hdr=%.21e, dthydro=%.21e",uid,Œ¥dvov,Œ¥hdr,dthydro);
    //printf("\n[#%d] Œ¥t_cell_hydro=%.21e",uid,Œ¥t_cell_hydro);
  }
  //return dthydro;
}


// ****************************************************************************
// * After all solution variables are advanced to t_n+1, the constraints Œ¥tCourant
// * and Œ¥thydro for the next time increment t_n+1 are calculated in this routine.
// * Each constraint is computed in each element and then the final constraint value
// * is the minimum over all element values.
// * The constraints are applied during the computation of Œ¥t for the next time step.
// ****************************************************************************
// Cells min reduction
‚àÄ cells Œ¥t_courant <?= Œ¥t_cell_courant @ 12.11;
‚àÄ cells Œ¥t_hydro   <?= Œ¥t_cell_hydro   @ 12.22;


void dumpTimeConstraintsForElems(void) @ 12.3{
  //debug()<<"\tdomain.dtcourant()="<<Œ¥t_courant;
  //debug()<<"\tdomain.dthydro()  ="<<Œ¥t_hydro;
  //printf("\n\tdomain.dtcourant()=%.21e",Œ¥t_courant);
  //printf("\n\tdomain.dthydro()  =%.21e",Œ¥t_hydro);
}



// ****************************************************************************
// * atexit: dumpFinalEnergy
// ****************************************************************************
/*void dumpFinalEnergy(void){
  ‚Ñù MaxAbsDiff = 0.0;
  ‚Ñù TotalAbsDiff = 0.0;
  ‚Ñù MaxRelDiff = 0.0;
  int edgeElems=X_EDGE_ELEMS;
  debug()<<"   Problem size = "<<edgeElems;
  debug()<<"   Iteration count = "<<iteration-1;
  debug()<<"   Final Origin Energy = "<<e[0];
  debug()<<"";
  for(int j=0; j < edgeElems; ++j){
    for(int k=j+1; k < edgeElems; ++k){
      ‚Ñù RelDiff,AbsDiff = fabs(e[j*edgeElems+k]-e[k*edgeElems+j]);
      TotalAbsDiff += AbsDiff;
      if (MaxAbsDiff<AbsDiff) MaxAbsDiff=AbsDiff;
      RelDiff = AbsDiff/e[k*edgeElems+j];
      if (MaxRelDiff<RelDiff)MaxRelDiff=RelDiff;
    }
  }
  debug()<<"\n   Testing Plane 0 of Energy Array:";
  debug()<<"        MaxAbsDiff   = "<<MaxAbsDiff;
  debug()<<"        TotalAbsDiff = "<<TotalAbsDiff;
  debug()<<"        MaxRelDiff   = "<<MaxRelDiff;
  }*/
