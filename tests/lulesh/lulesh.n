// NABLA - a Numerical Analysis Based LAnguage

// Copyright (C) 2014 CEA/DAM/DIF
// Jean-Sylvain CAMIER - Jean-Sylvain.Camier@cea.fr

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
// See the LICENSE file for details.

// This NABLA port is an implementation of the benchmark LULESH:
// the Livermore Unstructured Lagrangian Explicit Shock Hydrodynamics
// (see https://computation.llnl.gov/casc/ShockHydro/ for details)

with cartesian;


// ****************************************************************************
// * Options
// ****************************************************************************
options{
  Real option_dtfixed            = -1.0e-7;  // fixed time increment
  Real option_Œ¥t_initial         = 1.0e-7;   // variable time increment
  Real option_Œ¥t_courant         = 1.0e+20;
  Real option_Œ¥t_hydro           = 1.0e+20;
  Real option_Œ¥t_mult_lower_b    = 1.1;
  Real option_Œ¥t_mult_upper_b    = 1.2;
  Real option_initial_energy     = 3.948746e+7;
  Real option_stoptime           = 1.0e-2;   // end time for simulation
  Real option_hgcoef             = 3.0;      // hourglass control
  Real option_qstop              = 1.0e+12;  // excessive q indicator
  Real option_monoq_max_slope    = 1.0;
  Real option_monoq_limiter_mult = 2.0;
  Real option_e_cut              = 1.0e-7;   // energy tolerance
  Real option_p_cut              = 1.0e-7;   // pressure tolerance
  Real option_q_cut              = 1.0e-7;   // q tolerance
  Real option_u_cut              = 1.0e-7;   // node velocity cut-off value
  Real option_v_cut              = 1.0e-10;  // relative volume tolerance
  Real option_qlc_monoq          = 0.5;      // linear term coef for q
  Real option_qqc_monoq          = 0.666666666666666666;  // quadratic term coef for q, should be 2.0/3.0 
  Real option_qqc                = 2.0;
  Real option_eosvmax            = 1.0e+9;
  Real option_eosvmin            = 1.0e-9;
  Real option_pmin               = 0.0;      // pressure floor
  Real option_emin               = -1.0e+15; // energy floor
  Real option_dvovmax            = 0.1;      // maximum allowable volume change
  Real option_refdens            = 1.0;      // reference density
  Real option_dtmax              = 1.0e-2;   // maximum allowable time increment
  Integer option_max_iterations  = 8;
};


// ****************************************************************************
// * Node Variables
// ****************************************************************************
nodes{
  Real3 ùúïx;            // Velocity vector
  Real3 ùúïùúïx;           // Acceleration vector
  Real3 nForce;       // Force vector
  Real nodalMass;     // Nodal mass
  //Integer symmX;
  //Integer symmY;
  //Integer symmZ;
};


// ****************************************************************************
// * Element Variables
// ****************************************************************************
cells{
  // Table 1.2 Element Variables  ////////////////
  Real p;              // pressure
  Real e;              // internal energy, (to synchronize)
  Real q;              // artificial viscosity
  Real v;              // relative volume
  Real calc_volume;    // instant relative volume
  Real vdov;           // relative volume change per volume
  Real delv;           // relative volume change
  Real volo;           // reference (initial) volume
  Real arealg;         // characteristic length
  Real3 Œµ;             // diagonal terms of deviatoric strain  dxx(),dyy(),dzz()
  Real ql;             // artificial viscosity linear term, (to synchronize)
  Real qq;             // artificial viscosity quadratic term, (to synchronize)
  Real3 cForce[nodes];
  // Temporaries /////////////////////////////////
  Real delv_xi;        // velocity gradient
  Real delv_eta;
  Real delv_zeta;
  Real delx_xi;        // coordinate gradient
  Real delx_eta;
  Real delx_zeta;
  Real phixi;
  Real phieta;
  Real phizeta;
  Real vnew;           // new relative volume
  Real elemMass;       // mass
  // EoS /////////////////////////////////////////
  Real e_old;
  Real delvc;
  Real p_old;
  Real q_old;
  Real compression;
  Real compHalfStep;
  Real work;
  Real p_new;
  Real e_new;
  Real q_new;
  Real bvc;
  Real pbvc;
  Real vnewc;
  Real pHalfStep;
  Real sound_speed;
  // Boundary Conditions Flags //////////////////////////////////////////////
  Integer elemBC;          // symmetry/free-surface flags for each elem face
};


// ****************************************************************************
// * Global Variables
// ****************************************************************************
global{
  Real Œ¥t_courant;         // Courant time constraint
  Real Œ¥t_hydro;           // Hydro time constraint
};


// ****************************************************************************
// * Initialization Part @ ]-‚àû,-0.0[
// ****************************************************************************


// ****************************************************************************
// * ini
// ****************************************************************************
void ini(void) @ -10.0{
  Œ¥t=0.0;
  Œ¥t_hydro=option_Œ¥t_hydro;
  Œ¥t_courant=option_Œ¥t_courant;
//  if (option_eosvmax==0.) fatal("ini", "option_eosvmax==0.");
//  if (option_eosvmin==0.) fatal("ini", "option_eosvmin==0.");
//  atexit(dumpFinalEnergy);
}


// ****************************************************************************
// * Set up boundary condition information
// * Set up elemement connectivity information
// ****************************************************************************
#define XI_M        0x003
#define XI_M_SYMM   0x001
#define XI_M_FREE   0x002
#define XI_P        0x00C
#define XI_P_SYMM   0x004
#define XI_P_FREE   0x008
#define ETA_M       0x030
#define ETA_M_SYMM  0x010
#define ETA_M_FREE  0x020
#define ETA_P       0x0C0
#define ETA_P_SYMM  0x040
#define ETA_P_FREE  0x080
#define ZETA_M      0x300
#define ZETA_M_SYMM 0x100
#define ZETA_M_FREE 0x200
#define ZETA_P      0xC00
#define ZETA_P_SYMM 0x400
#define ZETA_P_FREE 0x800
cells void iniCellBC(void) in (node coord) out (cell elemBC) @ -9.5{
  const Real zero = 0.0;
  const Real maxBoundaryX = X_EDGE_TICK*X_EDGE_ELEMS;
  const Real maxBoundaryY = Y_EDGE_TICK*Y_EDGE_ELEMS;
  const Real maxBoundaryZ = Z_EDGE_TICK*Z_EDGE_ELEMS;
  elemBC=0; // clear BCs by default
  foreach node{
    elemBC |= (coord.x==zero)?XI_M_SYMM;
    elemBC |= (coord.y==zero)?ETA_M_SYMM;
    elemBC |= (coord.z==zero)?ZETA_M_SYMM;
    elemBC |= (coord.x==maxBoundaryX)?XI_P_FREE;
    elemBC |= (coord.y==maxBoundaryY)?ETA_P_FREE;
    elemBC |= (coord.z==maxBoundaryZ)?ZETA_P_FREE;
  }
  //debug()<<"#"<<uid<<" elemBC="<<elemBC;
  //printf("\n#%d elemBC=%d",uid,elemBC);
}


// ****************************************************************************
// * Cells initialization
// ****************************************************************************
cells void iniCells(void) in (node coord)
  out (cell v, cell e, cell volo, cell elemMass, cell calc_volume) @ -8.0{
  Real3 X[8];
  v=1.0;
  foreach node X[n]=coord;
  e=(uid==0)?option_initial_energy:0.0;
  volo=elemMass=calc_volume=computeElemVolume(X);
  //debug()<<": e["<<uid<<"]="<<e<<", volume="<<calc_volume;
  printf("\ne[%02d]=%.21e, volume=%.21e",uid,e,calc_volume);
}

nodes void iniNodalMass(void) in (cell calc_volume) out (node nodalMass) @ -6.9{
  const int nid=uid;
  nodalMass=0.0;
  //if (nid==0) printf("\n[iniNodalMass] tnid=%d, Node #%d, nodalMass=%.21e",tnid,nid,nodalMass);
  foreach cell{
    //int cid=node_cell[8*tnid+i];
    //if (cid<0) continue;
    //if (nid==0) printf("\n\tprefix: %d+=#%d nodalMass=%.21e (+=%.21e)",nid,cid,nodalMass,calc_volume/8.0);
    nodalMass+=calc_volume/8.0;
    //if (nid==0) printf("\n\tpostfix: %d+=#%d nodalMass=%.21e (+=%.21e)",nid,cid,nodalMass,calc_volume/8.0);
  }
  //debug()<<uid<<": nodalMass="<<nodalMass;
  printf("\n#%d nodalMass=%.21e",uid,nodalMass);
}


// ****************************************************************************
// * Compute part @ ]+0,+‚àû[
// ****************************************************************************


// ****************************************************************************
// * timeIncrement
// * This routine computes the time increment Œ¥tn for the
// * current timestep loop iteration. We aim for a "target" value of t_final-tn
// * for Œ¥tn . However, the actual time increment is allowed to grow by a
// * certain prescribed amount from the value used in the previous step and is
// * subject to the constraints Œ¥t_Courant and Œ¥t_hydro described in Section 1.5.3.
// ****************************************************************************
void timeIncrement(void) @ 0.1 {
  const Real target_Œ¥t = option_stoptime - time;
  const Real max_Œ¥t = 1.0e+20;
  const Real new_Œ¥t_courant = (Œ¥t_courant < max_Œ¥t)?¬Ω*Œ¥t_courant:max_Œ¥t;
  const Real new_Œ¥t_courant_hydro = (Œ¥t_hydro < new_Œ¥t_courant)?Œ¥t_hydro*2.0/3.0:new_Œ¥t_courant;
  const Real now_Œ¥t = new_Œ¥t_courant_hydro ;
  const Real old_Œ¥t = (GlobalIteration==1)?option_Œ¥t_initial:Œ¥t;
  const Real ratio = now_Œ¥t / old_Œ¥t ;
  const Real up_new_Œ¥t = (ratio >= 1.0)?(ratio < option_Œ¥t_mult_lower_b)?old_Œ¥t:now_Œ¥t:now_Œ¥t;//option_Œ¥t_mult_lower_b
  const Real dw_new_Œ¥t = (ratio >= 1.0)?(ratio > option_Œ¥t_mult_upper_b)?old_Œ¥t*option_Œ¥t_mult_upper_b:up_new_Œ¥t:up_new_Œ¥t;
  const Real new_Œ¥t = (dw_new_Œ¥t > option_dtmax)?option_dtmax:dw_new_Œ¥t;
  const Real Œ¥œÑ = (option_dtfixed <= 0.0)?(GlobalIteration != 1)?new_Œ¥t:old_Œ¥t:old_Œ¥t;
  const Real scaled_target_Œ¥t = (target_Œ¥t>Œ¥œÑ)?((target_Œ¥t<(4.0*Œ¥œÑ/3.0))?2.0*Œ¥œÑ/3.0:target_Œ¥t):target_Œ¥t;
  const Real scaled_Œ¥t = (scaled_target_Œ¥t < Œ¥œÑ)?scaled_target_Œ¥t:Œ¥œÑ;
  Œ¥t = mpi_reduce(ReduceMin, scaled_Œ¥t);
  //info()<<"ITERATION "<<GlobalIteration;
  if (GlobalIteration > option_max_iterations) exit;
  //info()<< "\t\t\33[7mTimeIncrement Œ¥t="<<Œ¥t<<"\33[m";//[0]
  printf("\n\t\t\33[7mTimeIncrement dtt=%.21e\33[m", Œ¥t);
  //if (ReduceMinToDouble(Œ¥t) == 0.) exit;
}


// ****************************************************************************
// * Sum contributions to total stress tensor
// * pull in the stresses appropriate to the hydro integration
// * Initialize stress terms for each element. Recall that our assumption of
// * an inviscid isotropic stress tensor implies that the three principal
// * stress components are equal, and the shear stresses are zero.
// * Thus, we initialize the diagonal terms of the stress tensor to
// * -(p + q) in each element.
// ****************************************************************************
cells void initStressTermsForElems(void)
  in (node coord, cell p, cell q)
  out (cell Œµ, cell cForce) @ 0.3 {
  Real sig = -p-q;
  Real3 fNormals,dj,x[8],B[8];
  //debug()<<"sig="<<sig;
  foreach node x[n]=coord;
  Œµ = dj = -¬º*((x[0]+x[1]+x[5]+x[4])-(x[3]+x[2]+x[6]+x[7]));
  calcElemShapeFunctionDerivatives(x,B);
  foreach node B[n]=0.0;
  Œ£_FaceNormal(B,0,1,2,3,x);
  Œ£_FaceNormal(B,0,4,5,1,x);
  Œ£_FaceNormal(B,1,5,6,2,x);
  Œ£_FaceNormal(B,2,6,7,3,x);
  Œ£_FaceNormal(B,3,7,4,0,x);
  Œ£_FaceNormal(B,4,7,6,5,x);
  foreach node
    cForce = -sig*B[n];
}

/*nodes void fetchCellNodeForce0(void) in (cell cForce) out (node nForce)@0.301 {
  Real3 Œ£=0.0;
  foreach cell Œ£+=cForce;
  nForce=Œ£;
  //debug()<<"@0.3 nForce="<<nForce;
  printf("\n@0.3 nForce[%d]=(%.21e,%.21e,%.21e)",uid,nForce.x,nForce.y,nForce.z);
}*/

// ****************************************************************************
// * calcFBHourglassForceForElems
// * Calculates the Flanagan-Belytschko anti-hourglass force
// * calcFBHourglassForceForElems
// ****************************************************************************
/*cells void Œ£ElemStressesToNodeForces(void)
  in (node coord, cell volo, cell v,
      cell sound_speed, cell elemMass,
      node ùúïx)
  out (cell cForce)  @ 1.3{
  const Real Œ≥[4][8]={{ 1., 1.,-1.,-1.,-1.,-1., 1., 1.},
                      { 1.,-1.,-1., 1.,-1., 1., 1.,-1.},
                      { 1.,-1., 1.,-1., 1.,-1., 1.,-1.},
                      {-1., 1.,-1., 1., 1.,-1., 1.,-1.}};
  Real Œ∑0[4],Œ∑1[4],Œ∑2[4],Œ∑3[4] ;
  Real Œ∑4[4],Œ∑5[4],Œ∑6[4],Œ∑7[4];
  Real3 x[8],xd[8],dvd[8],Œ∑[8];
  const Real hourg=option_hgcoef;
  const Real œÑv = volo*v;
  const Real volume13=‚àõ(œÑv);
  const Real Œ∏ = -hourg*0.01*sound_speed*elemMass/volume13;
  const Real determ = œÑv;
  foreach node x[n] = coord;
  foreach node xd[n] = ùúïx;  
  dvd[0]=ùúïVolume(x[1],x[2],x[3],x[4],x[5],x[7]);
  dvd[3]=ùúïVolume(x[0],x[1],x[2],x[7],x[4],x[6]);
  dvd[2]=ùúïVolume(x[3],x[0],x[1],x[6],x[7],x[5]);
  dvd[1]=ùúïVolume(x[2],x[3],x[0],x[5],x[6],x[4]);
  dvd[4]=ùúïVolume(x[7],x[6],x[5],x[0],x[3],x[1]);
  dvd[5]=ùúïVolume(x[4],x[7],x[6],x[1],x[0],x[2]);
  dvd[6]=ùúïVolume(x[5],x[4],x[7],x[2],x[1],x[3]);
  dvd[7]=ùúïVolume(x[6],x[5],x[4],x[3],x[2],x[0]);
  cHourglassModes(0,determ,dvd,Œ≥,x,Œ∑0,Œ∑1,Œ∑2,Œ∑3,Œ∑4,Œ∑5,Œ∑6,Œ∑7);
  cHourglassModes(1,determ,dvd,Œ≥,x,Œ∑0,Œ∑1,Œ∑2,Œ∑3,Œ∑4,Œ∑5,Œ∑6,Œ∑7);
  cHourglassModes(2,determ,dvd,Œ≥,x,Œ∑0,Œ∑1,Œ∑2,Œ∑3,Œ∑4,Œ∑5,Œ∑6,Œ∑7);
  cHourglassModes(3,determ,dvd,Œ≥,x,Œ∑0,Œ∑1,Œ∑2,Œ∑3,Œ∑4,Œ∑5,Œ∑6,Œ∑7);
  //debug()<<"hourg="<<hourg<<", sound_speed="<<sound_speed<<", elemMass="<<elemMass;
  calcElemFBHourglassForce(xd,Œ∑0,Œ∑1,Œ∑2,Œ∑3,Œ∑4,Œ∑5,Œ∑6,Œ∑7,Œ∏,Œ∑);
  //foreach node debug()<<uid<<" "<<n<<" hgf="<<Œ∑[n];
  foreach node cForce = Œ∑[n];
  }*/

/*nodes void Œ£CellNodeForce(void) in (cell cForce) out (node nForce)@ 1.4 {
  Real3 Œ£=0.0;
  foreach cell Œ£+=cForce;
  nForce+=Œ£;
  //debug()<<"fix @1.4 nForce="<<nForce;
  }*/


// ****************************************************************************
// * The routine CalcAccelerationForNodes() calculates a three-dimensional
// * acceleration vector A at each mesh node from F.
// * The acceleration is computed using Newton's Second Law of Motion,
// * F = m0 A, where m0 is the mass at the node.
// * Note that since the mass in each element is constant in time for our calculations,
// * the mass at each node is also constant in time.
// * The nodal mass values are set during the problem set up.
// ****************************************************************************
/*nodes void ùúïùúïForNodes(void)
  in (node nForce, node nodalMass) out (node ùúïùúïx) @ 2.8{
  ùúïùúïx = nForce/nodalMass;
  //debug()<<"ùúïùúïx="<<ùúïùúïx;
}*/

// ****************************************************************************
// * The routine ApplyAccelerationBoundaryConditions() applies symmetry boundary
// * conditions at nodes on the boundaries of the mesh where these were specified
// * during problem set up. A symmetry boundary condition sets the normal
// * component of A at the boundary to zero.
// * This implies that the normal component of the velocity vector U will
// * remain constant in time.
// ****************************************************************************
/*outer nodes void ùúïùúïBCForNodes(void)
  out (node ùúïùúïx) @ 2.9 {
  ùúïùúïx.x=(coord.x==0.0)?0.0;
  ùúïùúïx.y=(coord.y==0.0)?0.0;
  ùúïùúïx.z=(coord.z==0.0)?0.0;
  }*/


// ****************************************************************************
// * The routine CalcVelocityForNodes() integrates the acceleration at each node
// * to advance the velocity at the node to tn+1.
// * Note that this routine also applies a cut-off to each velocity vector value.
// * Specifically, if a value is below some prescribed value, that term is set to zero.
// * The reason for this cutoff is to prevent spurious mesh motion which may arise
// * due to floating point roundoff error when the velocity is near zero.
// ****************************************************************************
/*nodes void ùúïForNodes(void) in (node ùúïùúïx) inout (node ùúïx) @ 3.0{
  ùúïx += ùúïùúïx*Œ¥t ;
  ùúïx.x = (norm(ùúïx.x)<option_u_cut)?0.0;
  ùúïx.y = (norm(ùúïx.y)<option_u_cut)?0.0;
  ùúïx.z = (norm(ùúïx.z)<option_u_cut)?0.0;
  //debug()<<"ùúïx="<<ùúïx;
  }*/


// ****************************************************************************
// * The routine CalcPositionForNodes() performs the last step in the nodal
// * advance portion of the algorithm by integrating the velocity at each node
// * to advance the position of the node to tn+1.
// ****************************************************************************
/*nodes void coordForNodes(void) in (node ùúïx) @ 3.1{
  coord += ùúïx*Œ¥t;
  //debug()<<"coords= "<<coord;
  }*/


// ****************************************************************************
// * calcElemVolume
// ****************************************************************************
/*cells void calcElemVolume(void)
  in (node coord, node ùúïx,cell v, cell volo, cell delx_xi, cell delv_xi,
      cell delx_eta, cell delv_eta, cell delx_zeta, cell delv_zeta)
  inout (cell Œµ) out (cell delv, cell vnew, cell calc_volume, cell vdov, cell arealg) @ 4.0{
  const Real dt2= ¬Ω*Œ¥t;
  const Real Œ¥ = 1.e-36;
  Real3 B[8],X[8],Xd[8];
  Real DetJ,volume,œÅVolume;
  foreach node X[n]=coord;
  foreach node Xd[n]=ùúïx;
  volume = calc_volume = computeElemVolume(X);  
  vnew = œÅVolume = volume/volo;
  delv = œÅVolume - v;
  arealg = calcElemCharacteristicLength(X,volume);
  //debug()<<"arealg="<<arealg;
  {
    const Real vol = volo*vnew;
    const Real nrm = 1.0/(vol+Œ¥);
    const Real3 di =  ¬º*((X[1]+X[2]+X[6]+X[5])-(X[0]+X[3]+X[7]+X[4]));
    const Real3 dj = -¬º*((X[0]+X[1]+X[5]+X[4])-(X[3]+X[2]+X[6]+X[7]));
    const Real3 dk =  ¬º*((X[4]+X[5]+X[6]+X[7])-(X[0]+X[1]+X[2]+X[3]));
    const Real3 a_xi = (dj‚®Ødk);
    const Real3 a_eta = (dk‚®Ødi);
    const Real3 a_zeta = (di‚®Ødj);
    const Real3 dv_xi  =  ¬º*((Xd[1]+Xd[2]+Xd[6]+Xd[5])-(Xd[0]+Xd[3]+Xd[7]+Xd[4]));
    const Real3 dv_eta = -¬º*((Xd[0]+Xd[1]+Xd[5]+Xd[4])-(Xd[3]+Xd[2]+Xd[6]+Xd[7]));
    const Real3 dv_zeta = ¬º*((Xd[4]+Xd[5]+Xd[6]+Xd[7])-(Xd[0]+Xd[1]+Xd[2]+Xd[3]));
    delx_xi = vol/‚àö(a_xi‚ãÖa_xi+Œ¥);
    delx_eta = vol/‚àö(a_eta‚ãÖa_eta+Œ¥);
    delx_zeta = vol/‚àö(a_zeta‚ãÖa_zeta+Œ¥);
    delv_zeta = (a_zeta*nrm)‚ãÖdv_zeta;     
    delv_xi = (a_xi*nrm)‚ãÖdv_xi;
    delv_eta = (a_eta*nrm)‚ãÖdv_eta;
  }
  foreach node X[n] -= dt2*Xd[n];    
  DetJ=calcElemShapeFunctionDerivatives(X,B);
  Œµ=calcElemVelocityGradient(Xd,B,DetJ);
  //calc strain rate and apply as constraint
  vdov = Œµ.x+Œµ.y+Œµ.z;
  // make the rate of deformation tensor deviatoric
  Œµ -= ‚Öì*vdov;
  // See if any volumes are negative, and take appropriate action.
  //assert(vnew >= 0.0);//fatal("calcLagrangeElements","VolumeError");
  }*/


// ****************************************************************************
// * This routine performs the second part of the q calculation.
// ****************************************************************************
/*cells void calcMonotonicQForElemsByDirectionX(xyz direction)
  in (cell elemBC, cell delv_xi, cell phixi){
  const Real monoq_limiter_mult = option_monoq_limiter_mult;
  const Real monoq_max_slope = option_monoq_max_slope;
  Integer bcSwitch;
  Real delvm=0.0;
  Real delvp=0.0;
  const Real ptiny = 1.e-36;
  const Real nrm = 1./(delv_xi+ptiny);
  bcSwitch = elemBC & XI_M;
  delvm = (bcSwitch == 0)?delv_xi[prevCell];
  delvm = (bcSwitch == XI_M_SYMM)?delv_xi;
  delvm = (bcSwitch == XI_M_FREE)?0.0;
  delvm = delvm * nrm ;
  bcSwitch = elemBC & XI_P;
  delvp = (bcSwitch == 0)?delv_xi[nextCell];
  delvp = (bcSwitch == XI_P_SYMM)?delv_xi;
  delvp = (bcSwitch == XI_P_FREE)?0.0;
  delvp = delvp * nrm ;
  phixi = ¬Ω * (delvm + delvp) ;
  delvm *= monoq_limiter_mult ;
  delvp *= monoq_limiter_mult ;
  phixi = (delvm < phixi)?delvm;
  phixi = (delvp < phixi)?delvp;
  phixi = (phixi < 0.)?0.0;
  phixi = (phixi > monoq_max_slope)?monoq_max_slope;
  }

cells void calcMonotonicQForElemsByDirectionY(xyz direction)
  in (cell elemBC, cell delv_eta, cell phieta){
  const Real monoq_limiter_mult = option_monoq_limiter_mult;
  const Real monoq_max_slope = option_monoq_max_slope;
  Integer register bcSwitch;
  Real register delvm=0.;
  Real register delvp=0.;
  const Real ptiny = 1.e-36;
  const Real nrm = 1./(delv_eta+ptiny);
  bcSwitch = elemBC & ETA_M;
  delvm = (bcSwitch == 0)?delv_eta[prevCell];
  delvm = (bcSwitch == ETA_M_SYMM)?delv_eta;
  delvm = (bcSwitch == ETA_M_FREE)?0.0;
  delvm = delvm * nrm ;
  bcSwitch = elemBC & ETA_P;
  delvp = (bcSwitch == 0)?delv_eta[nextCell];
  delvp = (bcSwitch == ETA_P_SYMM)?delv_eta;
  delvp = (bcSwitch == ETA_P_FREE)?0.0;
  delvp = delvp * nrm ;
  phieta = ¬Ω*(delvm + delvp) ;
  delvm *= monoq_limiter_mult ;
  delvp *= monoq_limiter_mult ;
  phieta = (delvm  < phieta)?delvm;
  phieta = (delvp  < phieta)?delvp;
  phieta = (phieta < 0.0)?0.0;
  phieta = (phieta > monoq_max_slope)?monoq_max_slope;
}

cells void calcMonotonicQForElemsByDirectionZ(xyz direction)
  in (cell elemBC, cell delv_zeta, cell phizeta){
  const Real monoq_limiter_mult = option_monoq_limiter_mult;
  const Real monoq_max_slope = option_monoq_max_slope;
  Integer bcSwitch;
  Real delvm=0.;
  Real delvp=0.;
  const Real ptiny = 1.e-36;
  const Real nrm = 1./(delv_zeta+ptiny) ;
  bcSwitch = elemBC & ZETA_M;
  delvm = (bcSwitch == 0)?delv_zeta[prevCell];
  delvm = (bcSwitch == ZETA_M_SYMM)?delv_zeta;
  delvm = (bcSwitch == ZETA_M_FREE)?0.0;
  delvm = delvm * nrm ;
  bcSwitch = elemBC & ZETA_P;
  delvp = (bcSwitch == 0)?delv_zeta[nextCell];
  delvp = (bcSwitch == ZETA_P_SYMM)?delv_zeta;
  delvp = (bcSwitch == ZETA_P_FREE)?0.0;
  delvp = delvp * nrm ;
  phizeta = ¬Ω*(delvm+delvp);
  delvm *= monoq_limiter_mult ;
  delvp *= monoq_limiter_mult ;
  phizeta = (delvm < phizeta )?delvm;
  phizeta = (delvp < phizeta )?delvp;
  phizeta = (phizeta < 0.0)?0.0;
  phizeta = (phizeta > monoq_max_slope )?monoq_max_slope;
}

void calcMonotonicQForElems(void) @ 4.7{
  calcMonotonicQForElemsByDirectionX(MD_DirX);
  calcMonotonicQForElemsByDirectionY(MD_DirY);
  calcMonotonicQForElemsByDirectionZ(MD_DirZ);
  }*/

/*cells void calcMonotonicQForElemsQQQL(void)
  in (cell vdov, cell elemMass, cell volo, cell vnew,
      cell delx_xi, cell delv_eta, cell delx_eta,
      cell delv_zeta, cell delx_zeta, cell delv_xi,
      cell phixi, cell phieta, cell phizeta)
  out(cell qq, cell ql)@ 4.72{
  const Real rho = elemMass/(volo*vnew);
  const Real qlc_monoq = option_qlc_monoq;
  const Real qqc_monoq = option_qqc_monoq;
  const Real delvxxi   = delv_xi*delx_xi;
  const Real delvxeta  = delv_eta*delx_eta;
  const Real delvxzeta = delv_zeta*delx_zeta;
  const Real delvxxit  = (delvxxi>0.0)?0.0:delvxxi;
  const Real delvxetat = (delvxeta>0.0)?0.0:delvxeta;
  const Real delvxzetat= (delvxzeta>0.0)?0.0:delvxzeta;
  const Real qlin = -qlc_monoq*rho*(delvxxit*(1.0-phixi)+
                                    delvxetat*(1.0-phieta)+
                                    delvxzetat*(1.0-phizeta));
  const Real qquad = qqc_monoq*rho*(delvxxit*delvxxit*(1.0-phixi*phixi) +
                                    delvxetat*delvxetat*(1.0-phieta*phieta) +
                                    delvxzetat*delvxzetat*(1.0-phizeta*phizeta));
  const Real qlint  = (vdov>0.0)?0.0:qlin;  // Remove length scale
  const Real qquadt = (vdov>0.0)?0.0:qquad;
  qq = qquadt ;
  ql = qlint  ;
  //debug()<<"phixi="<<phixi<<" phieta="<<phieta<<" phizeta="<<phizeta;
  //debug()<<"ql="<<ql<<", qq="<<qq;
  }*/


// ****************************************************************************
// * The routine CalcQForElems() calculates the artificial viscosity term q
// * for each element. The calculation is partitioned into two parts.
// * CalcQForElems
// ****************************************************************************
/*cells void calcQForElemsExcessiveArtificialViscosityTest(void) in (cell q) @ 4.8{
  // Don't allow excessive artificial viscosity
  if (q>=option_qstop){
    //debug()<<"calcQForElemsExcessiveArtificialViscosityTest!";
//    fatal("calcQForElemsExcessiveArtificialViscosityTest", "q > option_qstop");
  }
  }*/


// ****************************************************************************
// * The routine ApplyMaterialPropertiesForElems() updates the pressure and
// * internal energy variables to their values at the new time, p_n+1 and e_n+1.
// * The routine first initializes a temporary array with the values of Vn+1 for
// * each element that was computed earlier. Then, upper and lower cut-off
// * values are applied to each array value to keep the relative volumes
// * within a prescribed range (not too close to zero and not too large).
// * Next, the routine EvalEOSForElems() is called and the array of modified
// * relative element volumes is passed to it.
// ****************************************************************************
/*cells void applyMaterialPropertiesForElems(void)
  in (cell vnew) out(cell vnewc) @ 5.0{
  vnewc = vnew ;
  vnewc = (vnewc < option_eosvmin)?option_eosvmin;
  vnewc = (vnewc > option_eosvmax)?option_eosvmax;
  }*/


// ****************************************************************************
// * The routine EvalEOSForElems() calculates updated values for pressure p_n+1
// * and internal energy e_n+1.
// * The computation involves several loops over elements to pack various mesh
// * element arrays (e.g., p, e, q, etc.) into local temporary arrays.
// * Several other quantities are computed and stored in element length
// * temporary arrays also.
// * The temporary arrays are needed because the routine CalcEnergyForElems()
// * calculates p_n+1 and e_n+1 in each element in an iterative process that
// * requires knowledge of those variables at time tn while it computes the
// * new time values.
// ****************************************************************************
/*cells void evalEOSForElems0(void)
  in (cell e, cell delv, cell p, cell q, cell vnewc)
  out(cell e_old, cell delvc, cell p_old, cell q_old,
      cell compression, cell compHalfStep,cell work) @ 6.0{
  const Real vchalf = vnewc - ( ¬Ω*delv);
  work = 0.0; 
  e_old = e;
  delvc = delv;
  p_old = p;
  q_old = q ;
  compression = (1.0/vnewc) - 1.0;
  compHalfStep = (1.0/vchalf)-1.0;
  }*/

/*cells void evalEOSForElems1(void)
  in (cell vnewc, cell compression)
  out(cell compHalfStep) @ 6.1 {
  compHalfStep = (vnewc <= option_eosvmin)?compression;
  }*/

/*cells void evalEOSForElems6(void)
  in (cell vnewc, cell compHalfStep)
  out(cell p_old, cell compression) @ 6.6 {
  p_old = (vnewc < option_eosvmax)?p_old:0.0;
  compression =(vnewc < option_eosvmax)?compression:0.0;
  compHalfStep = (vnewc < option_eosvmax)?compHalfStep:0.0;
  }*/


// ****************************************************************************
// * The routine CalcEnergyForElems() calls CalcPressureForElems() repeatedly.
// * The function CalcPressureForElems() is the Equation of State model
// * for a "gamma law" gas.
// * The value c1s passed to the routine is defined to be Œ≥ - 1.
// * The Equation of State calculation is a core part of any hydrocode.
// * In a production code, one of any number of Equation of State functions
// * may be called to generate a pressure that is needed to close the system
// * of equations and generate a unique solution.
// ****************************************************************************
// @ 7.1   calcEnergyForElems1
/*cells void calcEnergyForElems1(void)
  in (cell e_old, cell delvc, cell p_old, cell q_old, cell work)
  inout (cell e_new) @ 7.1{
  e_new = e_old - ¬Ω*delvc*(p_old + q_old) + ¬Ω*work;
  e_new = (e_new < option_emin)?option_emin;
  //debug()<<"vchalf="<<(vnewc-(¬Ω*delv));
  //debug()<<"e_old="<<e_old<<", delvc="<< delvc <<", work="<< work<<", e_new="<<e_new;
  }*/


// ****************************************************************************
// * calcPressureForElems
// * p_new => pHalfStep
// * compression => compHalfStep
// * e_old => e_new
// ****************************************************************************
/*cells void calcPressureForElemspHalfStepcompHalfStep(void)
  in (cell compHalfStep, cell e_new) 
  inout(cell bvc, cell pHalfStep)
  out (cell vnewc, cell pbvc) @ 7.2{
  const Real c1s = 2.0/3.0;
  bvc = c1s*(compHalfStep+1.0);
  pbvc = c1s;
  pHalfStep = bvc*e_new ;
  pHalfStep=(rabs(pHalfStep)<option_p_cut)?0.0;
  pHalfStep = (vnewc >= option_eosvmax )?0.0; // impossible condition here?
  pHalfStep = (pHalfStep < option_pmin)?option_pmin;
  //debug()<<"pHalfStep="<<pHalfStep<<", bvc="<<bvc<<", pbvc="<<pbvc<<", e_new="<<e_new;
  //debug()<<"compHalfStep="<<compHalfStep<<", vnewc="<<vnewc<<", pmin="<<option_pmin<<", p_cut="<<option_p_cut;
}

cells void calcEnergyForElems3(void)
  in (cell compHalfStep, cell delvc, cell pbvc, cell ql, cell qq,
      cell bvc, cell pHalfStep, cell p_old, cell q_old)
  out (cell q_new)
  inout (cell e_new) @ 7.3 {
  const Real vhalf = 1.0/(1.0+compHalfStep);
  const Real ssc = ( pbvc*e_new + vhalf*vhalf*bvc*pHalfStep)/option_refdens ;
  const Real ssct = (ssc<=0.111111e-36)?0.333333e-18:‚àö(ssc);
  q_new = (delvc>0.0)?0.0:(ssct*ql + qq);
  e_new = e_new + ¬Ω*delvc*(3.0*(p_old+q_old)-4.0*(pHalfStep+q_new)) ;
}

cells void calcEnergyForElems4(void) in (cell work)
  inout (cell e_new)@ 7.4{
  e_new += ¬Ω*work;
  e_new = (rabs(e_new) < option_e_cut)?0.0;
  e_new = (e_new<option_emin)?option_emin;
  //debug()<<"q_new="<<q_new<<", e_new="<<e_new;
  }*/

/*cells void calcPressureForElemsPNewCompression(void)
  in (cell compression,
      cell bvc,
      cell e_new, cell vnewc)
      inout (cell pbvc, cell p_new) @ 7.5,7.7{
  const Real c1s = 2.0/3.0;
  bvc = c1s*(compression + 1.0);
  pbvc = c1s;
  p_new = bvc*e_new ;
  p_new = (rabs(p_new) < option_p_cut)?0.0;
  p_new = (vnewc >= option_eosvmax )?0.0;
  p_new = (p_new < option_pmin)?option_pmin;
}

cells void calcEnergyForElems6(void)
  in (cell delvc, cell bvc,cell pbvc, cell vnewc, cell p_new, cell ql,
      cell qq, cell p_old, cell q_old, cell pHalfStep, cell q_new)
  inout(cell e_new)@ 7.6{
  const Real sixth = 1.0/6.0;
  const Real ssc = ( pbvc*e_new + vnewc*vnewc*bvc*p_new)/option_refdens;
  const Real ssct = (ssc <= 0.111111e-36)?0.333333e-18:‚àö(ssc);
  const Real q_tilde = (delvc > 0.)?0.0:(ssct*ql + qq);
  //debug()<<"ssc="<<ssct;
  //debug()<<"pbvc="<<pbvc<<" e_new="<<e_new<<" vnewc="<<vnewc
  //<<" bvc="<<bvc<<" p_new="<<p_new <<" rho0="<<option_refdens;
  e_new = e_new - (7.0*(p_old + q_old)
                   - (8.0)*(pHalfStep + q_new)
                   + (p_new + q_tilde)) * delvc*sixth ;
  //debug()<<"e_new="<<e_new;
  e_new = (rabs(e_new) < option_e_cut)?0.0;
  e_new = (e_new < option_emin)?option_emin;
  //debug()<<"e_new="<<e_new;
}

cells void calcEnergyForElems8(void)
  in (cell delvc, cell bvc, cell pbvc, cell e_new,
      cell vnewc, cell p_new, cell ql, cell qq)
  inout(cell q_new)@ 7.8{
  const Real ssc = (pbvc*e_new + vnewc*vnewc*bvc*p_new)/option_refdens;
  const Real ssct = (ssc <= 0.111111e-36)?0.333333e-18:‚àö(ssc);
  const Real qnw = (ssct*ql+qq);
  const Real qnwt = (rabs(qnw) < option_q_cut)?0.0:qnw;
  //debug()<<"pbvc="<<pbvc<<" e_new="<<e_new<<" vnewc="<<vnewc
  //<<" bvc="<<bvc<<" p_new="<<p_new <<" rho0="<<option_refdens;
  //debug()<<"8 delvc="<<delvc;
  //debug()<<"8 ssc="<<ssct;
  q_new = (delvc <= 0.)?qnwt;
  //debug()<<"8 q_new="<<q_new;
}

cells void evalEOSForElems8(void)
  in (cell p_new, cell e_new, cell q_new)
  out(cell p, cell e, cell q)@ 8.0{
  p = p_new;
  e = e_new;
  q = q_new;
  //debug()<<"p_new="<<p_new<<" e_new="<< e_new <<" q_new="<< q_new;
  }*/


// ****************************************************************************
// * Lastly, the routine CalcSoundSpeedForElems() calculates the sound speed
// * sound_speed in each element using p_n+1 and e_n+1.
// * The maximum value of sound_speed is used to calculate constraints on t_n+1
// * which will be used for the next time advance step.
// ****************************************************************************
/*cells void calcSoundSpeedForElems(void)
  in (cell bvc, cell pbvc, cell e_new, cell vnewc, cell p_new)
  out (cell sound_speed) @ 9.0{
  foreach material{
    //debug()<<"pbvc="<<pbvc<<" e_new="<<e_new<<" vnewc="<<vnewc<<" bvc="<<bvc<<" p_new="<<p_new <<" rho0="<<option_refdens;
    const Real ssTmp = (pbvc*e_new + vnewc*vnewc*bvc*p_new)/option_refdens;
    const Real ssTmpt = (ssTmp <= 0.111111e-36)?0.333333e-18:‚àö(ssTmp);
    sound_speed = ssTmpt;
    //debug()<<"calcSoundSpeedForElems sound_speed="<<sound_speed;
  }
  }*/


// ****************************************************************************
// * The routine UpdateVolumesForElems() updates the relative volume to V_n+1.
// * This routine basically resets the current volume V_n in each element to
// * the new volume V_n+1 so the simulation can continue to the next time
// * increment.
// * Note that this routine applies a cut-off to the relative volume V in
// * each element. Specifically, if V is sufficiently close to one (a
// * prescribed tolerance), then V is set to one.
// * The reason for this cutoff is to prevent spurious deviations of volume
// * from their initial values which may arise due to floating point roundoff
// * error.
// ****************************************************************************
/*cells void updateVolumesForElems(void)
  in (cell vnew) out (cell v) @ 10.0{
  const Real ŒΩ = vnew;
  const Real ŒΩt = (rabs(ŒΩ-1.0)<option_v_cut)?1.0:ŒΩ;
  v = ŒΩt;
  //debug()<<"updateVolumesForElems v="<<v;
  }*/


// ****************************************************************************
// * The routine CalcCourantConstraintForElems() calculates the Courant timestep
// * constraint Œ¥t_Courant. This constraint is calculated only in elements
// * whose volumes are changing that is, dV/V!=0.
// * If all element volumes remain the same, there is no Courant constraint
// * applied during the subsequent Œ¥t calculation.
// ****************************************************************************
/*cells Real calcCourantConstraintForElems(Real dtcourant)
  in (cell sound_speed, cell arealg, cell vdov) {
  foreach material{
    const Real qqc2 = 64.0 * option_qqc * option_qqc ;
    const Real Œ¥f = sound_speed[m] * sound_speed[m];
    const Real Œ¥fp = ‚àö(Œ¥f+((vdov[m]<0.0)?qqc2*arealg[m]*arealg[m]*vdov[m]*vdov[m]:0.0));
    const Real aŒ¥fp = arealg[m]/Œ¥fp;
    dtcourant=(vdov!=0.0)?min(dtcourant,aŒ¥fp);
    //debug()<<"dtcourant="<<dtcourant;
  }
  return dtcourant;
  }*/     


// ****************************************************************************
// * The routine CalcHydroConstraintForElems() calculates the hydro timestep
// * constraint. Similar to Œ¥t_Courant, Œ¥t_hydro is calculated only in elements
// * whose volumes are changing. When an element is undergoing volume change,
// * Œ¥t_hydro for the element is some maximum allowable element volume change
// * (prescribed) divided by dV/V in the element.
// ****************************************************************************
/*cells Real calcHydroConstraintForElems(Real dthydro) in (cell vdov){
  foreach material{
    const Real Œ¥dvov = option_dvovmax/(rabs(vdov[m])+1.e-20);
    const Real Œ¥hdr = min(dthydro,Œ¥dvov);
    //debug()<<"vdov="<<vdov<<" dtdvov="<<dtdvov<<" dvovmax="<<option_dvovmax;
    dthydro=(vdov!=0.0)?Œ¥hdr;
    //debug()<<"dthydro="<<dthydro;
  }
  return dthydro;
  }*/


// ****************************************************************************
// * After all solution variables are advanced to t_n+1, the constraints Œ¥tCourant
// * and Œ¥thydro for the next time increment t_n+1 are calculated in this routine.
// * Each constraint is computed in each element and then the final constraint value
// * is the minimum over all element values.
// * The constraints are applied during the computation of Œ¥t for the next time step.
// ****************************************************************************
/*void calcTimeConstraintsForElems(void) @ 12.1{
  const Real crnt=calcCourantConstraintForElems(1.0e+20);
  const Real hdr=calcHydroConstraintForElems(1.0e+20);
  Œ¥t_courant <?= (crnt);  // MIN_ASSIGN
  Œ¥t_hydro <?= (hdr);
//  debug()<<"\tdomain.dtcourant()="<<Œ¥t_courant;//
//  debug()<<"\tdomain.dthydro()  ="<<Œ¥t_hydro;//
   printf("\n\tdomain.dtcourant()=%.21e",Œ¥t_courant);
   printf("\n\tdomain.dthydro()  =%.21e",Œ¥t_hydro);
   }*/




// ****************************************************************************
// * atexit: dumpFinalEnergy
// ****************************************************************************
void dumpFinalEnergy(void){
  //Real MaxAbsDiff = 0.0;
  //Real TotalAbsDiff = 0.0;
  //Real MaxRelDiff = 0.0;
  //int edgeElems=X_EDGE_ELEMS;
//  debug()<<"   Problem size = "<<edgeElems;
//  debug()<<"   Iteration count = "<<GlobalIteration-1;
//  debug()<<"   Final Origin Energy = "<<e[0]/*[0]*/;
//  debug()<<"";
  /*for(int j=0; j < edgeElems; ++j){
    for(int k=j+1; k < edgeElems; ++k){
      Real RelDiff,AbsDiff = fabs(e[j*edgeElems+k]-e[k*edgeElems+j]);
      TotalAbsDiff += AbsDiff;
      if (MaxAbsDiff<AbsDiff) MaxAbsDiff=AbsDiff;
      RelDiff = AbsDiff/e[k*edgeElems+j];
      if (MaxRelDiff<RelDiff)MaxRelDiff=RelDiff;
    }
    }*/
  //debug()<<"\n   Testing Plane 0 of Energy Array:";
  //debug()<<"        MaxAbsDiff   = "<<MaxAbsDiff;
  //debug()<<"        TotalAbsDiff = "<<TotalAbsDiff;
  //debug()<<"        MaxRelDiff   = "<<MaxRelDiff;
}
