///////////////////////////////////////////////////////////////////////////////
// NABLA - a Numerical Analysis Based LAnguage                               //
//                                                                           //
// Copyright (C) 2014~2017 CEA/DAM/DIF                                       //
// IDDN.FR.001.520002.000.S.P.2014.000.10500                                 //
//                                                                           //
// Contributor(s): CAMIER Jean-Sylvain - Jean-Sylvain.Camier@cea.fr          //
//                                                                           //
// This software is a computer program whose purpose is to translate         //
// numerical-analysis specific sources and to generate optimized code        //
// for different targets and architectures.                                  //
//                                                                           //
// This software is governed by the CeCILL license under French law and      //
// abiding by the rules of distribution of free software. You can  use,      //
// modify and/or redistribute the software under the terms of the CeCILL     //
// license as circulated by CEA, CNRS and INRIA at the following URL:        //
// "http://www.cecill.info".                                                 //
//                                                                           //
// The CeCILL is a free software license, explicitly compatible with         //
// the GNU GPL.                                                              //
//                                                                           //
// As a counterpart to the access to the source code and rights to copy,     //
// modify and redistribute granted by the license, users are provided only   //
// with a limited warranty and the software's author, the holder of the      //
// economic rights, and the successive licensors have only limited liability.//
//                                                                           //
// In this respect, the user's attention is drawn to the risks associated    //
// with loading, using, modifying and/or developing or reproducing the       //
// software by the user in light of its specific status of free software,    //
// that may mean that it is complicated to manipulate, and that also         //
// therefore means that it is reserved for developers and experienced        //
// professionals having in-depth computer knowledge. Users are therefore     //
// encouraged to load and test the software's suitability as regards their   //
// requirements in conditions enabling the security of their systems and/or  //
// data to be ensured and, more generally, to use and operate it in the      //
// same conditions as regards security.                                      //
//                                                                           //
// The fact that you are presently reading this means that you have had      //
// knowledge of the CeCILL license and that you accept its terms.            //
//                                                                           //
// See the LICENSE file for details.                                         //
///////////////////////////////////////////////////////////////////////////////

// This NABLA port is an implementation of the benchmark LULESH:
// the Livermore Unstructured Lagrangian Explicit Shock Hydrodynamics
// (see https://computation.llnl.gov/casc/ShockHydro/ for details)

// ****************************************************************************
// * Geometrics functions
// ****************************************************************************


// ****************************************************************************
// * calcElemShapeFunctionDerivatives
// ****************************************************************************
â„ calcElemShapeFunctionDerivatives(const â„Â³* restrict X, â„Â³* restrict Î²){
  const â„Â³ fjxi = â…›*((X[6]-X[0])+(X[5]-X[3])-(X[7]-X[1])-(X[4]-X[2]));
  const â„Â³ fjet = â…›*((X[6]-X[0])-(X[5]-X[3])+(X[7]-X[1])-(X[4]-X[2]));
  const â„Â³ fjze = â…›*((X[6]-X[0])+(X[5]-X[3])+(X[7]-X[1])+(X[4]-X[2]));
  // compute cofactors
  const â„Â³ cjxi =  (fjetâ¨¯fjze);
  const â„Â³ cjet = -(fjxiâ¨¯fjze);
  const â„Â³ cjze =  (fjxiâ¨¯fjet);
  // calculate partials: this need only be done for 0,1,2,3
  // since, by symmetry, (6,7,4,5) = - (0,1,2,3)
  Î²[0] = - cjxi-cjet-cjze;
  Î²[1] =   cjxi-cjet-cjze;
  Î²[2] =   cjxi+cjet-cjze;
  Î²[3] = - cjxi+cjet-cjze;
  Î²[4] = -Î²[2];
  Î²[5] = -Î²[3];
  Î²[6] = -Î²[0];
  Î²[7] = -Î²[1];
  // calculate jacobian determinant (volume)
  return 8.0*(fjetâ‹…cjet);
}


// ****************************************************************************
// * calcElemVelocityGradient
// ****************************************************************************
â„Â³ calcElemVelocityGradient(const â„Â³* restrict Ï…,
                            const â„Â³* restrict B,
                            const â„ detJ){
  const â„ inv_detJ=1.0/detJ;
  const â„Â³ Ï…06=Ï…[0]-Ï…[6];
  const â„Â³ Ï…17=Ï…[1]-Ï…[7];
  const â„Â³ Ï…24=Ï…[2]-Ï…[4];
  const â„Â³ Ï…35=Ï…[3]-Ï…[5];
  return inv_detJ*(B[0]*Ï…06+B[1]*Ï…17+B[2]*Ï…24+B[3]*Ï…35);
}


// ****************************************************************************
// * computeElemVolume
// ****************************************************************************
â„ computeElemVolume(const â„Â³* restrict X){
  const â„ twelveth = 1.0/12.0;  
  const â„Â³ d31=X[3]-X[1];
  const â„Â³ d72=X[7]-X[2];
  const â„Â³ d63=X[6]-X[3];
  const â„Â³ d20=X[2]-X[0];
  const â„Â³ d43=X[4]-X[3];
  const â„Â³ d57=X[5]-X[7];
  const â„Â³ d64=X[6]-X[4];
  const â„Â³ d70=X[7]-X[0];
  
  const â„Â³ d14=X[1]-X[4];
  const â„Â³ d25=X[2]-X[5];
  const â„Â³ d61=X[6]-X[1];
  const â„Â³ d50=X[5]-X[0];

  const â„ tp1 = (d31+d72)â‹…(d63â¨¯d20);
  const â„ tp2 = (d43+d57)â‹…(d64â¨¯d70);
  const â„ tp3 = (d14+d25)â‹…(d61â¨¯d50);
  return twelveth*(tp1+tp2+tp3);
}


// ****************************************************************************
// * AreaFace
// ****************************************************************************
â„ AreaFace(const â„Â³ X0, const â„Â³ X1, const â„Â³ X2, const â„Â³ X3){
  const â„Â³ f=(X2-X0)-(X3-X1);
  const â„Â³ g=(X2-X0)+(X3-X1);
  return (fâ‹…f)*(gâ‹…g)-(fâ‹…g)*(fâ‹…g);
}


// ****************************************************************************
// * calcElemCharacteristicLength
// ****************************************************************************
â„ calcElemCharacteristicLength(const â„Â³ X[8], const â„ Î½){
  â„ Ï‡=0.0;
  Ï‡=max(AreaFace(X[0],X[1],X[2],X[3]),Ï‡);
  Ï‡=max(AreaFace(X[4],X[5],X[6],X[7]),Ï‡);
  Ï‡=max(AreaFace(X[0],X[1],X[5],X[4]),Ï‡);
  Ï‡=max(AreaFace(X[1],X[2],X[6],X[5]),Ï‡);
  Ï‡=max(AreaFace(X[2],X[3],X[7],X[6]),Ï‡);
  Ï‡=max(AreaFace(X[3],X[0],X[4],X[7]),Ï‡);
  return 4.0*Î½/âˆš(Ï‡);
}


// ****************************************************************************
// * Î£_FaceNormal
// ****************************************************************************
void Î£_FaceNormal(â„Â³* restrict Î²,
                  const int ia, const int ib,
                  const int ic, const int id,
                  const â„Â³* X){
  const â„Â³ bisect0 = Â½*(X[id]+X[ic]-X[ib]-X[ia]);
  const â„Â³ bisect1 = Â½*(X[ic]+X[ib]-X[id]-X[ia]);
  const â„Â³ Î± = Â¼*(bisect0â¨¯bisect1);
  Î²[ia] += Î±; Î²[ib] += Î±;  
  Î²[ic] += Î±; Î²[id] += Î±;  
}


// ****************************************************************************
// * calcElemVolumeDerivative
// * We keep the next one to allow sequential binary reproductibility
// ****************************************************************************
/*â„Â³ ğœ•VolumeUnReproductible(const â„Â³ Î§0, const â„Â³ Î§1, const â„Â³ Î§2,
              const â„Â³ Î§3, const â„Â³ Î§4, const â„Â³ Î§5){
  const â„Â³ v01 = Î§0+Î§1;
  const â„Â³ v12 = Î§1+Î§2;
  const â„Â³ v25 = Î§2+Î§5;
  const â„Â³ v04 = Î§0+Î§4;
  const â„Â³ v34 = Î§3+Î§4;
  const â„Â³ v35 = Î§3+Î§5;
  return (1.0/12.0)*((v12â¨¯v01)+(v04â¨¯v34)-(v25â¨¯v35));
  }*/

â„Â³ ğœ•Volume(const â„Â³ Î§0, const â„Â³ Î§1, const â„Â³ Î§2,
           const â„Â³ Î§3, const â„Â³ Î§4, const â„Â³ Î§5){
  const â„ x0=Î§0.x; const â„ x1=Î§1.x;
  const â„ x2=Î§2.x; const â„ x3=Î§3.x;
  const â„ x4=Î§4.x; const â„ x5=Î§5.x;
  const â„ y0=Î§0.y; const â„ y1=Î§1.y;
  const â„ y2=Î§2.y; const â„ y3=Î§3.y;
  const â„ y4=Î§4.y; const â„ y5=Î§5.y;
  const â„ z0=Î§0.z; const â„ z1=Î§1.z;
  const â„ z2=Î§2.z; const â„ z3=Î§3.z;
  const â„ z4=Î§4.z; const â„ z5=Î§5.z;
  const â„ x = (y1+y2)*(z0+z1)-(y0+y1)*(z1+z2)+(y0+y4)*(z3+z4)-(y3+y4)*(z0+z4)-(y2+y5)*(z3+z5)+(y3+y5)*(z2+z5);
  const â„ y =-(x1+x2)*(z0+z1)+(x0+x1)*(z1+z2)-(x0+x4)*(z3+z4)+(x3+x4)*(z0+z4)+(x2+x5)*(z3+z5)-(x3+x5)*(z2+z5);
  const â„ z =-(y1+y2)*(x0+x1)+(y0+y1)*(x1+x2)-(y0+y4)*(x3+x4)+(y3+y4)*(x0+x4)+(y2+y5)*(x3+x5)-(y3+y5)*(x2+x5);
  return (1.0/12.0)*â„Â³(x,y,z);
}


// ****************************************************************************
// * calcElemFBHourglassForce
// ****************************************************************************
void calcElemFBHourglassForce(const â„Â³* restrict xd,
                              const â„* restrict h0, const â„* restrict h1,
                              const â„* restrict h2, const â„* restrict h3,
                              const â„* restrict h4, const â„* restrict h5,
                              const â„* restrict h6, const â„* restrict h7,
                              const â„ Î¸, â„Â³* restrict Î·){
  const â„Â³ h00=h0[0]*xd[0]+h1[0]*xd[1]+h2[0]*xd[2]+h3[0]*xd[3]+h4[0]*xd[4]+h5[0]*xd[5]+h6[0]*xd[6]+h7[0]*xd[7];
  const â„Â³ h01=h0[1]*xd[0]+h1[1]*xd[1]+h2[1]*xd[2]+h3[1]*xd[3]+h4[1]*xd[4]+h5[1]*xd[5]+h6[1]*xd[6]+h7[1]*xd[7];
  const â„Â³ h02=h0[2]*xd[0]+h1[2]*xd[1]+h2[2]*xd[2]+h3[2]*xd[3]+h4[2]*xd[4]+h5[2]*xd[5]+h6[2]*xd[6]+h7[2]*xd[7];
  const â„Â³ h03=h0[3]*xd[0]+h1[3]*xd[1]+h2[3]*xd[2]+h3[3]*xd[3]+h4[3]*xd[4]+h5[3]*xd[5]+h6[3]*xd[6]+h7[3]*xd[7];
  
  Î·[0]=Î¸*((h0[0]*h00)+(h0[1]*h01)+(h0[2]*h02)+(h0[3]*h03));
  Î·[1]=Î¸*((h1[0]*h00)+(h1[1]*h01)+(h1[2]*h02)+(h1[3]*h03));
  Î·[2]=Î¸*((h2[0]*h00)+(h2[1]*h01)+(h2[2]*h02)+(h2[3]*h03));
  Î·[3]=Î¸*((h3[0]*h00)+(h3[1]*h01)+(h3[2]*h02)+(h3[3]*h03));
  Î·[4]=Î¸*((h4[0]*h00)+(h4[1]*h01)+(h4[2]*h02)+(h4[3]*h03));
  Î·[5]=Î¸*((h5[0]*h00)+(h5[1]*h01)+(h5[2]*h02)+(h5[3]*h03));
  Î·[6]=Î¸*((h6[0]*h00)+(h6[1]*h01)+(h6[2]*h02)+(h6[3]*h03));
  Î·[7]=Î¸*((h7[0]*h00)+(h7[1]*h01)+(h7[2]*h02)+(h7[3]*h03));
}


// ****************************************************************************
// * compute the hourglass modes
// ****************************************************************************
void cHourglassModes(const int i, const â„ Î´,
                     const â„Â³ *Î”, const â„ Î³[4][8],
                     const â„Â³ *Ï‡,
                     â„* restrict h0, â„* restrict h1,
                     â„* restrict h2, â„* restrict h3,
                     â„* restrict h4, â„* restrict h5,
                     â„* restrict h6, â„* restrict h7){
  const â„ Ï…=1.0/Î´;
  const â„Â³ Î· = Ï‡[0]*Î³[i][0]+Ï‡[1]*Î³[i][1]+Ï‡[2]*Î³[i][2]+Ï‡[3]*Î³[i][3]+
    Ï‡[4]*Î³[i][4]+Ï‡[5]*Î³[i][5]+Ï‡[6]*Î³[i][6]+Ï‡[7]*Î³[i][7];
  h0[i] = Î³[i][0]-Ï…*(Î”[0]â‹…Î·);
  h1[i] = Î³[i][1]-Ï…*(Î”[1]â‹…Î·);
  h2[i] = Î³[i][2]-Ï…*(Î”[2]â‹…Î·);
  h3[i] = Î³[i][3]-Ï…*(Î”[3]â‹…Î·);
  h4[i] = Î³[i][4]-Ï…*(Î”[4]â‹…Î·);
  h5[i] = Î³[i][5]-Ï…*(Î”[5]â‹…Î·);
  h6[i] = Î³[i][6]-Ï…*(Î”[6]â‹…Î·);
  h7[i] = Î³[i][7]-Ï…*(Î”[7]â‹…Î·);
}

