/******************************************************************************
  /cea/S/dsku/andromede/temp1/s3/camierjs/arcane/obj/x-alicante/nabla/nabla -v trefle.log -m trefle -i trefle
*******************************************************************************/
with aleph;


// ****************************************************************************
// * Déclaration des options accessibles depuis l'AXL
// ****************************************************************************
options{
  Real option_deltat = 0.001;
  Real option_initial_heat = 800.0;
  Integer option_max_iterations = 8;
};


// ****************************************************************************
// * Déclaration des variables aux mailles
// ****************************************************************************
cells{
  Real Τ;
  Real Σ;
  Integer Ξ;
};


// ****************************************************************************
// * DEFINES
// ****************************************************************************
#define nSurface ((coord[0]-coord[1]).abs()*(coord[0]-coord[3]).abs())


// ****************************************************************************
// * Partie d'initialisation ]-oo,-0[
// ****************************************************************************

// Initialisation du δt de cette simulation
// L'alephIni serait à faire automatiquement via le backend
void ini(void) @ -11{
  δt=option_deltat;
  alephIni();
}

// Initialisation des variables aux mailles Integer puis Real3
cells void iniCellVariables(void) out (cell Τ) @ -10{
  Ξ=0;
  Τ=Σ=0.0;
}

// Conditions initiales possibles aux faces
outer faces void iniCellOuterVariables(void) out (cell Τ) {//@ -9{
  if (!cell(0).isOwn()) continue;
  if (coord[0].x > 0.5) continue;
  Τ[0]=option_initial_heat;
}

// Conditions initiales possibles aux mailles
cells void iniCellHeat(void) out (cell Τ){// @ -9{
  if (coord[0].x > 0.5) continue;
  Τ=option_initial_heat;
}


// * Partie d'initialisation algébrique à faire depuis le backend
own cells void fillCellMatrixIndex(int row_offset, int idx)
  out (cell matrix_idx){
  vector_indexs.add(Ξ=row_offset+(idx++));
  vector_zeroes.add(0.0);
}
void initAlgebra(void) @ -7{
  const Integer nb_row_rank=ownCells().size();
  #warning reduce should be done here nb_row_rank
  const Integer nb_row_size=nb_row_rank;//subDomain()->parallelMng()->reduce(ReduceSum,nb_row_rank);
  m_aleph_kernel->initialize(nb_row_size,nb_row_rank);
  {
    const Integer row_offset=m_aleph_kernel->topology()->part()[m_aleph_kernel->rank()];
    fillCellMatrixIndex(row_offset,0);
    //Ξ.synchronize();
  }
}

// un debug des indices de notre matrice
cells void dbgKsi(void) in (cell Ξ){// @ -6{
  info()<<"Ξ @"<< uid << "="<< Ξ;
}


// ****************************************************************************
// * Partie de calcul ]+0,+oo[ 
// ****************************************************************************
// On flush notre vecteur solution
void rhsInit(void)@1.0{
  ARCANE_HYODA_SOFTBREAK(subDomain());
  rhs.resize(0);
}

// Pour le remplir proprement
own cells void setRhsCellValues(void) in (cell Τ) @ 1.1{
  if (coord[0].x > 0.5)
    rhs.add(/*+*/Τ);
  else
    rhs.add(option_initial_heat);
}

own cells void setRhsCellStdValues(void) in (cell Τ){// @ 1.1{
  rhs.add(/*+*/Τ);
}

// A lancer de façon peut-être plus élégante?!
void getMatrixAndVectors(void) @ 2{
  alephInitialize();
}


// Flush du coef aux mailles
own cells void iniSigma(void) out (cell Σ) @ 2.1{
  ARCANE_HYODA_SOFTBREAK(subDomain());
  Σ=0.0;
}

// Remplissage de la matrice innerBackFaces
inner faces void innerBackFaces(void) in (cell Ξ) out (cell Σ) @  3.1{
  const register Real σ=nSurface;
  if (!backCell.isOwn()) continue;
  //info()<<"innerBackFaces Ξ[backCell] @"<< backCellUid << "="<< Ξ[backCell];
  alephAddValue(Ξ[backCell], Ξ[frontCell], -δt/σ);
  Σ[backCell]+=1.0/σ;
}

// Remplissage de la matrice innerFrontFaces
inner faces void innerFrontFaces(void) in (cell Ξ) out (cell Σ)@ 3.1{
  const register Real σ=nSurface;
  if (!frontCell.isOwn()) continue;
  //info()<<"innerFrontFaces Ξ[frontCell] @"<< frontCellUid << "="<< Ξ[frontCell];
  alephAddValue(Ξ[frontCell], Ξ[backCell], -δt/σ);
  Σ[frontCell]+=1.0/σ;
}

// Remplissage par la contribution outer faces
outer faces void outerFaces(void) out (cell Σ) @ 3.3{
  if (!cell(0).isOwn()) continue;
  Σ[cell(0)]+=1.0/nSurface;
}

// Remplissage diagonale
cells void cellDiagonale(void) in (cell Σ, cell Ξ) @ 3.4{
  alephAddValue(Ξ, Ξ, 1.0+(δt*Σ));
}

// Idem, à lancer de façon peut-être plus élégante?!
void assembleAndSolve(void)@4{
  alephSolve();
}

// Récupération des résultats
own cells void getCellResults(void) out (cell Ξ, cell Τ) @ 5.0{
  Τ=alephRhsGet(Ξ);
}

// Et un test pour sortir en iterout
void testForQuit(void) @ 6.0{
  Τ.synchronize();
  if (GlobalIteration >= option_max_iterations) exit;
}
