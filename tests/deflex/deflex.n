///////////////////////////////////////////////////////////////////////////////
// NABLA - a Numerical Analysis Based LAnguage                               //
//                                                                           //
// Copyright (C) 2014~2017 CEA/DAM/DIF                                       //
// IDDN.FR.001.520002.000.S.P.2014.000.10500                                 //
//                                                                           //
// Contributor(s): CAMIER Jean-Sylvain - Jean-Sylvain.Camier@cea.fr          //
//                                                                           //
// This software is a computer program whose purpose is to translate         //
// numerical-analysis specific sources and to generate optimized code        //
// for different targets and architectures.                                  //
//                                                                           //
// This software is governed by the CeCILL license under French law and      //
// abiding by the rules of distribution of free software. You can  use,      //
// modify and/or redistribute the software under the terms of the CeCILL     //
// license as circulated by CEA, CNRS and INRIA at the following URL:        //
// "http://www.cecill.info".                                                 //
//                                                                           //
// The CeCILL is a free software license, explicitly compatible with         //
// the GNU GPL.                                                              //
//                                                                           //
// As a counterpart to the access to the source code and rights to copy,     //
// modify and redistribute granted by the license, users are provided only   //
// with a limited warranty and the software's author, the holder of the      //
// economic rights, and the successive licensors have only limited liability.//
//                                                                           //
// In this respect, the user's attention is drawn to the risks associated    //
// with loading, using, modifying and/or developing or reproducing the       //
// software by the user in light of its specific status of free software,    //
// that may mean that it is complicated to manipulate, and that also         //
// therefore means that it is reserved for developers and experienced        //
// professionals having in-depth computer knowledge. Users are therefore     //
// encouraged to load and test the software's suitability as regards their   //
// requirements in conditions enabling the security of their systems and/or  //
// data to be ensured and, more generally, to use and operate it in the      //
// same conditions as regards security.                                      //
//                                                                           //
// The fact that you are presently reading this means that you have had      //
// knowledge of the CeCILL license and that you accept its terms.            //
//                                                                           //
// See the LICENSE file for details.                                         //
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÇœÉœÑœÖœÜœáœàœâŒëŒíŒìŒîŒïŒñŒóŒòŒôŒöŒõŒúŒùŒûŒüŒ†Œ°Œ£Œ§Œ•Œ¶ŒßŒ®Œ©
// ‚àÄ ‚Ñù‚Ñï‚Ñ§ ¬≤¬≥‚àö¬Ω‚Öì¬º‚Öõ
// ****************************************************************************

const ‚Ñù œÄ=3.1415926535897932384626433832795028841971693993751;

const ‚Ñï binMax=100;
// Devraient migrer en global pour √™tre capable de placer les atomics
‚Ñù histo[binMax];
‚Ñù Œòbinning[binMax];

// Dump de l'histogramme dans ce fichier
ofstream histoData("/tmp/histo.data");


// ****************************************************************************
// * Options
// ****************************************************************************
options{
  // Mesh options
  ‚Ñù LENGTH                    = 1.0;
  ‚Ñï X_EDGE_ELEMS              = 8;
  ‚Ñï Y_EDGE_ELEMS              = 8;
  ‚Ñï Z_EDGE_ELEMS              = 1;
  // Param√®tres d'entr√©e
  ‚Ñù option_ŒΩŒ¥t = 0.05; // Fr√©quence de collision x pas de temps
  ‚Ñæ option_particle_frame = true;
  // Numerical options
  ‚Ñù option_Œµ_frame_change = 1.0e-15;
  ‚Ñù option_ŒìŒ± = 1.0+0.5;
  ‚Ñù option_ŒìŒ≤ = 2.0;
  // Yet required options for backend
  ‚Ñù option_Œ¥t_initial = 0.1;
  ‚Ñù option_stoptime = 1.0;
  ‚Ñï option_max_iterations = 32768;   // ! utilis√© en dur dans les backends
};


// **************************************************************************
// * Forward declaration
// ****************************************************************************
void iniRandom(double,double);
double gamma_rand(void);


// **************************************************************************
// * Particles Variables
// ****************************************************************************
particles{
  // Rep√®re du laboratoire
  ‚Ñù Œ±Lab,Œ≤Lab,Œ≥Lab; // Cosinus directeurs
  // Rep√®re de la particule
  ‚Ñù Œ±,Œ≤,Œ≥;
};


// **************************************************************************
// * Globals
// ****************************************************************************
//global{ ‚Ñù seed;};


// ****************************************************************************
// * Initialization Part @ ]-‚àû,-0.0[
// ****************************************************************************
void iniGlobals(void) @ -5.0{
  //Œ¥t=option_Œ¥t_initial;
  printf("\n[7m[iniGlobals] Œ¥t=%f[m", (double)Œ¥t);
  assert(Œ¥t>=0.0);
}

void iniRandom(void) @ -5.0 {
  info()<<"[7;37m[iniRandom][m";
  iniRandom(option_ŒìŒ±,option_ŒìŒ≤);
  //info()<<"\n"<<gamma_rand();
}

// ****************************************************************************
// * initialization Œ±, Œ≤ et Œ≥ dans le rep√®re du labo
// ****************************************************************************
‚àÄ particles void ini_Œ±Œ≤Œ≥(void)
  out (particle Œ±,Œ≤,Œ≥) @ -5.0 if (option_particle_frame) {
  if (uid==0) info()<<"[7;37m[ini_Œ±Œ≤Œ≥][m";
  Œ±=1.0;
  Œ≤=Œ≥=0.0;
 }


// ****************************************************************************
// * Compute loop @ ]+0,+‚àû[
// ****************************************************************************
void dbgLoop(void) @ 1.0 {
  printf("\n[7;36m[Loop] #%3d, time=%f[m", iteration,time);
}

// ****************************************************************************
// * particleFrameSampling, aucun in/out, on remplit l'histogramme directement
// ****************************************************************************
‚àÄ particles void particleFrameSampling(void) @ 2.0 {
  ‚Ñæ rejet=true;
  ‚Ñù Œ∏S3,sinŒ∏S3;
  if (uid==0) info()<<"[7;37m[particleFrameSampling][m";
  do{
    // On utilise la m√™me graine & g√©n√©rateur pour toutes les particules
    // La reproductibilit√© n'est pas acquise ici
    const ‚Ñù rndŒì = gamma_rand();
    const ‚Ñù rnd01 = drand48();
    const ‚Ñù Œ∏=Œ∏S3=‚àö(2.0*option_ŒΩŒ¥t*rndŒì);
    sinŒ∏S3=sin(Œ∏);
    rejet=(Œ∏>œÄ)||(sinŒ∏S3<rnd01*Œ∏);
  }while (rejet);
  //info()<<"["<<uid<<"] theta="<<Œ∏S3;
  const ‚Ñù cosŒ∏S3=cos(Œ∏S3);
  // Vecteur tangent œÑ au p√¥le de S¬≥, al√©atoire
  const ‚Ñù œÜ = 2.0*œÄ*drand48();
  const ‚Ñù Œº = -1.0+2.0*drand48();
  // Projection de S¬≥ dans S¬≤
  const ‚Ñù œÑx=Œº;
  const ‚Ñù œÑy=‚àö(1.0-Œº¬≤)*cos(œÜ);
  const ‚Ñù¬≥ Œ©S2=‚Ñù¬≥(cosŒ∏S3,œÑx*sinŒ∏S3,œÑy*sinŒ∏S3);
  const ‚Ñù absŒ©S2=norm(Œ©S2);
  const ‚Ñù¬≥ Œ©S2final=Œ©S2/absŒ©S2;
  //info()<<"[7;37m[particleFrameSampling] Œ©S2.x="<<Œ©S2final.x<<"[m";
  diagnosticSpectrum(acos(Œ©S2final.x));
}

  
// ****************************************************************************
// * changeFrameFromParticleToLab
// ****************************************************************************
‚àÄ particles void changeFrameFromParticleToLab(void)
  in (particle Œ±,Œ≤,Œ≥)
  inout (particle Œ±Lab,Œ≤Lab,Œ≥Lab) @ 4.0 if (!option_particle_frame){
  const ‚Ñù denom = 1.0-Œ±Lab¬≤;
  if (uid==0) info()<<"[7;37m[changeFrameFromeParticleToLab][m";
  if (fabs(denom)>=option_Œµ_frame_change){
    const ‚Ñù sqrtDenom = ‚àö(denom);
    const ‚Ñù unsSqrtDenom = 1./sqrtDenom;
    const ‚Ñù Œ±p = Œ±*Œ±Lab-Œ≥*sqrtDenom;
    const ‚Ñù Œ≤p = Œ±*Œ≤Lab+(Œ±Lab*Œ≤Lab*Œ≥-Œ≥Lab*Œ≤)*unsSqrtDenom;
    const ‚Ñù Œ≥p = Œ±*Œ≥Lab+(Œ±Lab*Œ≤Lab*Œ≥+Œ≤Lab*Œ≤)*unsSqrtDenom;
    Œ±Lab = Œ±p;
    Œ≤Lab = Œ≤p;
    Œ≥Lab = Œ≥p;
  }else{
    Œ±Lab = Œ±*Œ±Lab;
    // A revoir !!
    Œ≤Lab = Œ≥;
    Œ≥Lab = Œ≤;
  }
}


// ****************************************************************************
// * Test for quit
// ****************************************************************************
void tstForQuit(void) @ 4.0 {
  info()<<"[7;37m[tstForQuit][m";
  //printf("\n\t[testForQuit] Iteration=%d, time=%f, delta_t=%f", iteration, time,Œ¥t);
  //if (time<option_stoptime) return;
  //printf("\n[7m[tstForQuit] Quit![m");
  dumpSpectrum();
  exit;
}

