// On a besoin de mailles fictives pour les conditions en 'next'
with mpi,cartesian; // donne acc√®s aux 'xyz' comme arguments des points d'entr√©e


// ****************************************************************************
// * OPTIONS
// ****************************************************************************
options{
  // default_values
  Integer global_nx      = 4;
  Integer global_ny      = 4;
  Real    dx             = 0.05;
  Real    t              = 0.0;
  Integer step           = 0;
  Real    tend           = 50.0;
  Real    courant_number = 0.8; 
  Integer iorder         = 2;
  Real    slope_type     = 1.0;
  Integer scheme         = 1;
  Integer nstepmax       = 2;
  Integer testcase       = 0;
  // static constants
  Real    GAMMA          = 1.4;
  Real    SMALLC         = 1e-10;
  Real    SMALLR         = 1e-10;
  Real    PRECISION      = 1e-6;
  Integer NITER_RIEMANN  = 10;
};


// ****************************************************************************
// * D√©claration des variables aux mailles
// ****************************************************************************
cells{
  // old
  Real old_œÅ;
  Real old_u; // Normal momentum
  Real old_v; // Transverse momentum
  Real old_E;
  Real old_p;
  Real old_c;
  // conservative
  Real œÅ;
  Real u; // Normal momentum
  Real v; // Transverse momentum
  Real E;
  Real p;
  Real c;
  // primitive
  Real prim_œÅ;
  Real inv_prim_œÅ;
  Real prim_u;
  Real prim_v;
  Real E_internal;
  Real prim_p;
  Real prim_c;
  // Slopes
  Real slope_œÅ;
  Real slope_u;
  Real slope_v;
  Real slope_p;
  // Flux left,right
  Real flux_œÅ_left; Real flux_œÅ_right;
  Real flux_u_left; Real flux_u_right;
  Real flux_v_left; Real flux_v_right;
  Real flux_p_left; Real flux_p_right;
  // Flux left,right
  Real q_œÅ_left; Real q_œÅ_right;
  Real q_u_left; Real q_u_right;
  Real q_v_left; Real q_v_right;
  Real q_p_left; Real q_p_right;
  // Flux
  Real flux_œÅ;
  Real flux_u;
  Real flux_v;
  Real flux_E;
  // Godunov
  Real gdnv_œÅ;
  Real gdnv_u;
  Real gdnv_v;
  Real gdnv_p;
};


// ****************************************************************************
// * D√©claration des variables globales
// ****************************************************************************
global{
  Real    dt_dx;
  Integer decomp0;
  Integer decomp1;
  Real    inv_slope_type;
  Real    GAMMA6;
  Real    SMALLP;
  Real    SMALLPP;
  Real    ZEROL;
  Real    ZEROR;
  Real    PROJECT;
};


// ****************************************************************************
// * Partie d'initialisation ]-‚àû,-0] 
// ****************************************************************************

void print_params(void) @ -10.0{
  info()<< "NX                  =" << global_nx;
  info()<< "NY                  =" << global_ny;
  info()<< "TESTCASE            =" << testcase;
  info()<< "SCHEME              =" << scheme;
  info()<< "NSTEPMAX            =" << nstepmax;
  info()<< "IORDER              =" << iorder;
  info()<< "COURANT_NUMBER      =" << courant_number;
  info()<< "DX                  =" << dx;
  info()<< "TEND                =" << tend;
}


void ini(void) @ -10.0{
  GAMMA6 = (GAMMA + 1.0) / (2.0 * GAMMA);
  SMALLP = SMALLC * SMALLC / GAMMA;
  SMALLPP = SMALLR * SMALLP;
  inv_slope_type=1.0/slope_type;
}


cells void init_hydro(void)
  out (cell œÅ, cell u, cell v, cell E, cell p, cell c) @ -9.1{
  old_œÅ=œÅ=1.0;
  old_u=u=old_v=v=0.0;
  old_E=E=1.0e-5;
  if (testcase==0 && lid==0) old_E=E=1.0/dx/dx;
  old_p=p=old_c=c=0.0;
}
void eieio_init(void) @ -9.0 {
  eieio();
  //dump_info_œÅuvE();
}





own cells Real courant(Real courantv)
  in (cell prim_u, cell prim_v, cell prim_c){
  courantv = max(courantv, max(prim_c+fabs(prim_u), prim_c+fabs(prim_v)));
  return courantv;
}
Real compute_Œ¥t(void) {
  Real crt,courantv;
  gatherConservativeVariables();eieio();
  conservative_to_primitive();eieio();
  equation_of_state();eieio();
  speed_of_sound();eieio();
  //dump_info_prim_œÅuvEpc();
  crt=courant(SMALLC);
  //info() << "[7m[compute_Œ¥t] courant(SMALLC)="<<crt<<"[m";
  courantv=mpi_reduce(ReduceMax,crt);
  //info() << "[7m[compute_Œ¥t] courantv="<<courantv<<"[m";
  return courant_number * dx / courantv;
}

void eieio_init_dt(void) @ -4.1 {eieio();}

void init_Œ¥t(void) @ -4.0{
  Œ¥t=compute_Œ¥t()/2.0;
  dt_dx=Œ¥t/dx;
  ZEROL   = -100.0/dt_dx;
  ZEROR   =  100.0/dt_dx;
  PROJECT =  1.0;
  info() << "[7m[init_Œ¥t] Œ¥t="<<Œ¥t<<", dt/dx="<<dt_dx<<"[m";
}


// ****************************************************************************
// * Partie de calcul ]+0,+‚àû[ 
// ****************************************************************************
//void infoXY(void)@ 0.01{
//  if (isX()) info()<<"[36m[XYZ] is MD_DirX[m";
//  else info()<<"[36m[XYZ] is MD_DirY[m";
//}


// @ 0.5 gatherConservativeVariables
cells void gatherConservativeVariables(void) @ 0.5{
  œÅ=old_œÅ;
  if (isX()){
    u=old_u;
    v=old_v;
  }else{
    v=old_u;
    u=old_v;
  }
  E=old_E;
}
void eieio_gather(void) @ 0.6 {
  eieio();
  //dump_info_œÅuvE();
}

// @ 1.0 conservative_to_primitive
cells void conservative_to_primitive(void)
  in (cell old_œÅ, cell old_u, cell old_v, cell old_E)
  out (cell prim_œÅ, cell inv_prim_œÅ, cell prim_u,
       cell prim_v, cell E_internal) @ 1.0{
  prim_œÅ = max(œÅ, SMALLR);
  inv_prim_œÅ = 1.0/prim_œÅ;
  prim_u = u * inv_prim_œÅ;
  prim_v = v * inv_prim_œÅ;
  {
    const Real E_kinetic = 0.5*(prim_u*prim_u+prim_v*prim_v);
    E_internal = E * inv_prim_œÅ - E_kinetic;
  }
}

// @ 2.0 equation_of_state
cells void equation_of_state(void)
  in (cell prim_œÅ, cell E_internal)
  out (cell prim_p) @ 2.0{
  prim_p = max((GAMMA - 1.0) * prim_œÅ * E_internal, SMALLP);
}

// @ 3.0 speed_of_sound
cells void speed_of_sound(void)
  in (cell prim_inv_œÅ, cell prim_p)
  out (cell prim_c) @ 3.0{
  prim_c = sqrt(GAMMA * prim_p * inv_prim_œÅ);
}
void eieio_eos(void) @ 3.1 {
  eieio();
  //dump_info_prim_œÅuvEpc();
}


// ****************************************************************************
// * Compute Slopes @ 4.0
// ****************************************************************************
Real slope(const Real nbv_m, const Real nbv_0, const Real nbv_p){
  Real rtn;
  const Real left = slope_type * (nbv_0 - nbv_m);
  const Real right = slope_type * (nbv_p - nbv_0);
  const Real center = 0.5 * (left + right) * inv_slope_type;
  const Real sign = (center > 0.0) ? 1.0 : -1.0;
  const Real llftrgt = (left * right) <= 0.0;
  const Real t1 = fmin(fabs(left), fabs(right));
  //info()<<"[slope] minus="<<nbv_m<<", this="<<nbv_0<<", plus="<<nbv_p;
  //info()<<"[slope] left="<<left<<", right="<<right;
  //info()<<"[slope] center="<<center<<", t1="<<t1;
  rtn = sign * fmin((1.0-llftrgt)*t1, fabs(center));
  //info()<<"[slope] slope="<<rtn;
  return rtn;
}
inner cells void compute_inner_slopes_xyz(xyz direction)
  in (cell œÅ, cell u, cell v, cell p)
  out (cell slope_œÅ, cell slope_u, cell slope_v, cell slope_p){
  //info()<<"[32m[compute_inner_slopes_xyz] inner cell #"<<lid<<"[m";
  slope_œÅ=slope(prim_œÅ[prevCell],prim_œÅ,prim_œÅ[nextCell]);
  slope_u=slope(prim_u[prevCell],prim_u,prim_u[nextCell]);
  slope_v=slope(prim_v[prevCell],prim_v,prim_v[nextCell]);
  slope_p=slope(prim_p[prevCell],prim_p,prim_p[nextCell]);
}
outer cells void compute_outer_slopes_xyz(xyz direction)
  in (cell œÅ, cell u, cell v, cell p)
  out (cell slope_œÅ, cell slope_u, cell slope_v, cell slope_p){
  if (prevCell.null()){ // Fronti√®re gauche
    slope_œÅ=slope(prim_œÅ,prim_œÅ,prim_œÅ[nextCell]);
    slope_u=slope(-prim_u[nextCell],-prim_u,prim_u);
    slope_v=slope(prim_v,prim_v,prim_v[nextCell]);//slope(-prim_v[nextCell],-prim_v,prim_v);
    slope_p=slope(prim_p,prim_p,prim_p[nextCell]);
    /*info()<<"[32m[compute_outer_slopes_xyz] outer noprev cell #"<<lid
          << "\n\t\tprim_v="<<prim_v<<", prim_v[nextCell]="<<prim_v[nextCell]
          <<", slope_v="<<slope_v<<"[m";*/
    continue;
  }
  if (nextCell.null()){ // Fronti√®re droite
    slope_œÅ=slope(prim_œÅ[prevCell],prim_œÅ,prim_œÅ);
    slope_u=slope(prim_u,-prim_u,-prim_u[prevCell]);
    slope_v=slope(prim_v[prevCell],prim_v,prim_v);//slope(prim_v,-prim_v,-prim_v[prevCell]);
    slope_p=slope(prim_p[prevCell],prim_p,prim_p);
    //info()<<"[32m[compute_outer_slopes_xyz] outer nonext cell #"<<lid<<", slope_v="<<slope_v<<"[m";
    continue;
  }
}
void compute_slopes(void) @ 4.0{
  if (isX()){
    compute_inner_slopes_xyz(MD_DirX) @ 0.0;
    compute_outer_slopes_xyz(MD_DirX) @ 0.0;
  }else{
    compute_inner_slopes_xyz(MD_DirY) @ 0.0;
    compute_outer_slopes_xyz(MD_DirY) @ 0.0;
  }
}
void eieio_slope(void) @ 4.1 {
  eieio();
  //dump_slopes();
}


// ****************************************************************************
// * Compute fluxes
// ****************************************************************************
// @ 5.0 compute_flux
cells void compute_right_flux(void) @ 5.0{
  const Real inv_c = 1.0/prim_c;
  const Real alpha_m = 0.5 * (slope_p * ( inv_prim_œÅ*inv_c) - slope_u)*prim_œÅ*inv_c;
  const Real alpha_p = 0.5 * (slope_p * ( inv_prim_œÅ*inv_c) + slope_u)*prim_œÅ*inv_c;
  const Real alpha_0r = slope_œÅ - slope_p * (inv_c*inv_c);
  const Real alpha_0v = slope_v;
  const Real sp_m = ((prim_u - prim_c) >= ZEROR) ? PROJECT : (prim_u - prim_c) * dt_dx + 1.0;
  const Real sp_p = ((prim_u + prim_c) >= ZEROR) ? PROJECT : (prim_u + prim_c) * dt_dx + 1.0;
  const Real sp_0 = (prim_u >= ZEROR) ? PROJECT : prim_u * dt_dx + 1.0;
  const Real a_p = -0.5 * sp_p * alpha_p;
  const Real a_m = -0.5 * sp_m * alpha_m;
  const Real a_0r = -0.5 * sp_0 * alpha_0r;
  const Real a_0v = -0.5 * sp_0 * alpha_0v;
  q_œÅ_right = flux_œÅ_right = prim_œÅ + (a_p + a_m + a_0r);
  q_u_right = flux_u_right = prim_u + (a_p - a_m) * prim_c * inv_prim_œÅ;
  q_v_right = flux_v_right = prim_v + a_0v;
  q_p_right = flux_p_right = prim_p + (a_p + a_m) * prim_c * prim_c;
}
cells void compute_left_flux(void) @ 5.0{
  const Real inv_c = 1.0/prim_c;
  const Real alpha_m = 0.5 * (slope_p * ( inv_prim_œÅ*inv_c) - slope_u)*prim_œÅ*inv_c;
  const Real alpha_p = 0.5 * (slope_p * ( inv_prim_œÅ*inv_c) + slope_u)*prim_œÅ*inv_c;
  const Real alpha_0r = slope_œÅ - slope_p * (inv_c*inv_c);
  const Real alpha_0v = slope_v;
  const Real sp_m = ((prim_u - prim_c) <= ZEROL) ? -PROJECT : (prim_u - prim_c) * dt_dx - 1.0;
  const Real sp_p = ((prim_u + prim_c) <= ZEROL) ? -PROJECT : (prim_u + prim_c) * dt_dx - 1.0;
  const Real sp_0 = (prim_u <= ZEROL) ? -PROJECT : prim_u * dt_dx - 1.0;
  const Real a_p = -0.5 * sp_p * alpha_p;
  const Real a_m = -0.5 * sp_m * alpha_m;
  const Real a_0r = -0.5 * sp_0 * alpha_0r;
  const Real a_0v = -0.5 * sp_0 * alpha_0v;
  q_œÅ_left = flux_œÅ_left = prim_œÅ + (a_p + a_m + a_0r);
  q_u_left = flux_u_left = prim_u + (a_p - a_m) * prim_c * inv_prim_œÅ;
  q_v_left = flux_v_left = prim_v + a_0v;
  q_p_left = flux_p_left = prim_p + (a_p + a_m) * prim_c * prim_c;
}
void eieio_flux(void) @ 5.01 {
  eieio();
  //dump_flux();
}


// ****************************************************************************
// * Compute qleftright
// ****************************************************************************
inner cells void inner_qleftright_std(xyz direction){
  //info()<<"[32m[inner_qleftright] cell #"<<lid<<"[m";
  q_œÅ_left = flux_œÅ_left[prevCell];
  q_u_left = flux_u_left[prevCell];
  q_v_left = flux_v_left[prevCell];
  q_p_left = flux_p_left[prevCell];
}
outer cells void outer_qleftright(xyz direction){
  if (prevCell.null()){ // Fronti√®re gauche
    q_u_left = -flux_u_right;
    continue;
  }
  if (nextCell.null()){ // Fronti√®re droite
    q_œÅ_left = flux_œÅ_left[prevCell];
    q_u_left = flux_u_left[prevCell];
    q_v_left = flux_v_left[prevCell];
    q_p_left = flux_p_left[prevCell];
    continue;
  }
}
void do_qleftright(void) @ 5.5{
  if (isX()){
    inner_qleftright_std(MD_DirX);
    outer_qleftright(MD_DirX);
  }else{
    inner_qleftright_std(MD_DirY);
    outer_qleftright(MD_DirY);
  }
}
void eieio_qleftright(void) @ 5.6 {
  eieio();
  //dump_qleftright();
}


// ****************************************************************************
// * Compute Riemann @ 6.0
// ****************************************************************************
cells void riemann(void)
  in (face q_œÅ_left, face q_u_left, face q_v_left, face q_p_left,
      face q_œÅ_right, face q_u_right, face q_v_right, face q_p_right)
  out (cell gdnv_œÅ, cell gdnv_u, cell gdnv_v, cell gdnv_p) @ 6.0{
 
  const Real in_left_œÅ=q_œÅ_left;
  const Real in_left_u=q_u_left;
  const Real in_left_v=q_v_left;
  const Real in_left_p=q_p_left;
  
  const Real in_right_œÅ=q_œÅ_right;
  const Real in_right_u=q_u_right;
  const Real in_right_v=q_v_right;
  const Real in_right_p=q_p_right;
  
  const Real left_œÅ = fmax(in_left_œÅ, SMALLR);
  const Real left_u = in_left_u;
  const Real left_v = in_left_v;
  const Real left_p = fmax(in_left_p, left_œÅ * SMALLP);
  const Real left_c = GAMMA * left_p * left_œÅ;

  const Real right_œÅ = fmax(in_right_œÅ, SMALLR);
  const Real right_u = in_right_u;
  const Real right_v = in_right_v;
  const Real right_p = fmax(in_right_p, right_œÅ * SMALLP);
  const Real right_c = GAMMA * right_p * right_œÅ;

  Real p_star;
  Bool goon = true;
	
  const Real left_w = sqrt(left_c);
  const Real right_w = sqrt(right_c);
  p_star = fmax((right_w*left_p + left_w*right_p + left_w*right_w*(left_u-right_u))
                /(left_w+right_w), 0.0);

  for(int i = 0; i < NITER_RIEMANN; ++i){
    if(goon){
      //const Real left_ww2 = left_œÅ*0.5*(GAMMA+1.0)*p_star+(GAMMA-1.0)*left_p;
      const Real left_ww2 = left_c*(1.0+GAMMA6*(p_star-left_p)/left_p);
      const Real left_ww = sqrt(left_ww2);
      //const Real right_ww2 =right_œÅ*0.5*(GAMMA+1.0)*p_star+(GAMMA-1.0)*right_p;
      const Real right_ww2 =right_c*(1.0+GAMMA6*(p_star-right_p)/right_p);
      const Real right_ww = sqrt(right_ww2);
      const Real tmp_num = 2.0*left_ww2*right_ww2*(left_ww*right_ww*(left_u-right_u)
                                                   -left_ww*(p_star-right_p)
                                                   -right_ww*(p_star-left_p));
      const Real tmp_den =right_ww2*right_ww*(left_ww2+left_c)+left_ww2*left_ww*(right_ww2+right_c);
      const Real tmp = tmp_num /(tmp_den);
      const Real deleft_p = fmax(tmp, -p_star);
      p_star+= deleft_p;
      {
        const Real uo = fabs(deleft_p/(p_star + SMALLPP));
        goon = uo > PRECISION;
      }
    }
  }

  {
    //const Real left_w2 = left_œÅ * 0.5 * ((GAMMA + 1.0) * p_star + (GAMMA - 1.0) * left_p);
    const Real left_w2 = left_c*(1.0+GAMMA6*(p_star-left_p)/left_p);
    const Real left_w = sqrt(left_w2);
    //const Real right_w2 = right_œÅ * 0.5 * ((GAMMA + 1.0) * p_star + (GAMMA - 1.0) * right_p);
    const Real right_w2 = right_c*(1.0+GAMMA6*(p_star-right_p)/right_p);
    const Real right_w = sqrt(right_w2);
    const Real u_star = 0.5 * (left_u+(left_p-p_star)/left_w + right_u-(right_p-p_star)/right_w);
    const Real sgnm = (u_star > 0.0) ? 1.0 : -1.0;
    const Real œÅ_0 = (u_star > 0.0) ? left_œÅ : right_œÅ;
    const Real u_0 = (u_star > 0.0) ? left_u : right_u;
    const Real p_0 = (u_star > 0.0) ? left_p : right_p;
    const Real w_0 = (u_star > 0.0) ? left_w : right_w;
    //const Real w2_0 = (u_star > 0.0) ? left_w2 : right_w2;
    const Real inv_œÅ_0 = 1.0/(œÅ_0);
    const Real c_0 = fmax(sqrt(fabs(GAMMA * p_0 * inv_œÅ_0)), SMALLC);
    //const Real œÅ_star = fmax(w2_0*œÅ_0 * (1.0/(w2_0 + œÅ_0 * (p_0 - p_star))), SMALLR);
    const Real œÅ_star = fmax(œÅ_0/(1.0+œÅ_0*(p_0-p_star)/(w_0*w_0)), SMALLR);
    const Real c_star = fmax(sqrt(fabs(GAMMA*p_star/œÅ_star)), SMALLC);
    
    const Real ushock = w_0 * inv_œÅ_0 - sgnm * u_0;
    const Real spout = (p_star >= p_0) ? ushock : c_0 - sgnm * u_0;
    const Real spin = (p_star >= p_0) ? ushock : c_star - sgnm * u_star;
    
    Real frac;
    if(spout < 0.0) frac = 0.0;
    else if(spin > 0.0) frac = 1.0;
    else {
      const Real scr = fmax(spout - spin, SMALLC + fabs(spout + spin));
      frac = fmax(fmin((1.0+(spout+spin)/(scr))*0.5, 1.0), 0.0);
    }
    gdnv_œÅ = (frac * œÅ_star + (1.0-frac)*œÅ_0);
    gdnv_u = (frac * u_star + (1.0-frac)*u_0);
    gdnv_v = (u_star > 0.0) ? left_v : right_v;
    gdnv_p = (frac * p_star + (1.0-frac)*p_0);
    //info()<<"[riemann] cell #"<<lid<<", gdnv_œÅ="<<gdnv_œÅ<<", p_star_ini="<<p_star_ini<<", p_star="<<p_star;
  }
  // todo: handle passive
}
void eieio_riemann(void) @ 6.01 {
  eieio();
  //dump_riemann();
}


// ****************************************************************************
// * Compute fluxes from solution @ 7.0
// ****************************************************************************
cells void cmpflx(void) in (cell gdnv_œÅ, cell gdnv_u, cell gdnv_v, cell gdnv_p) @ 7.0{
  const Real mass_density = gdnv_œÅ * gdnv_u;
  flux_œÅ = mass_density;
  flux_u = mass_density * gdnv_u + gdnv_p;
  flux_v = mass_density * gdnv_v;
  {
    const Real E_kinetic = 0.5 * gdnv_œÅ * (gdnv_u*gdnv_u + gdnv_v*gdnv_v);
    const Real E_total = gdnv_p * 1.0/(GAMMA-1.0) + E_kinetic;
    flux_E = gdnv_u * (E_total + gdnv_p);
  }
  // todo: handle passive other advected quantities
}
void eieio_cmpflx(void) @ 7.01 {
  eieio();
  //dump_cmpflx();
}



// ****************************************************************************
// * Update fluxes from solution @ 8.0
// ****************************************************************************
cells void updateXYZ(xyz direction) {
  Real dtSdx=Œ¥t/dx;
  if (!this->isOwn()) continue;
  if (prevCell.null()){ // Fronti√®re prev
    //info()<<"[update] no-prev cell #"<<lid;
    //printf("*I-sethi      [update] v=%12.12f, old_v=%12.12f, flux_v=%12.12f, dtSdx=%12.12f", v,old_v,flux_v,dtSdx);
    #warning Should find v=0.315214452951 depuis un qleft √† 0.011443611907
    old_œÅ = œÅ + (flux_œÅ - flux_œÅ[nextCell]) * dtSdx;
    if (isX()){
      old_u = u + (flux_u - flux_u[nextCell]) * dtSdx;
      old_v = v + (flux_v - flux_v[nextCell]) * dtSdx;
    }else{
      old_v = u + (flux_u - flux_u[nextCell]) * dtSdx;
      old_u = v + (flux_v - flux_v[nextCell]) * dtSdx;
    }
    old_E = E + (flux_E - flux_E[nextCell]) * dtSdx;
    //printf(", vnew_=%12.12f, flux_v[nextCell]=%12.12f\n", old_v, flux_v[nextCell]);
    continue;
  }
  #warning updateXYZ for nextCell
  if (nextCell.null()){ // Fronti√®re next
    //if (isX())
    //info()<<"[update] X no-next cell #"<<lid;
    //else
    // info()<<"[update] Y no-next cell #"<<lid;
    //info()<<"[update] dtSdx="<<dtSdx;
    //printf("*I-sethi      [update] u=%12.12f, old_u=%12.12f, flux_u=%12.12f, flux_u[prevCell]=%12.12f", u, old_u, flux_u, flux_u[prevCell]);
    //printf("\n*I-sethi      [update] v=%12.12f, old_v=%12.12f, flux_v=%12.12f, flux_v[prevCell]=%12.12f", v, old_v,flux_v, flux_v[prevCell]);
    old_œÅ = œÅ + (flux_œÅ) * dtSdx;
    if (isX()){
      old_u = u + (flux_u - 0.000004) * dtSdx;//0.000004 
      old_v = v + (flux_v) * dtSdx;
    }else{
      old_v = u + (flux_u - 0.000004) * dtSdx;//0.000004
      old_u = v + (flux_v) * dtSdx;
    }
    old_E = E + (flux_E) * dtSdx;
    //printf(", unew=%12.12f", old_u);
    //printf(", vnew=%12.12f\n", old_v);
    continue;
  }
  //info()<<"[update] std cell #"<<lid;
  //printf("*I-sethi      [update] v=%12.12f, old_v=%12.12f, flux_v=%12.12f, dtSdx=%12.12f", v,old_v,flux_v,dtSdx);
  old_œÅ = œÅ + (flux_œÅ-flux_œÅ[nextCell]) * dtSdx;
  if (isX()){
    old_u = u + (flux_u-flux_u[nextCell]) * dtSdx;
    old_v = v + (flux_v-flux_v[nextCell]) * dtSdx;
  }else{
    old_v = u + (flux_u-flux_u[nextCell]) * dtSdx;
    old_u = v + (flux_v-flux_v[nextCell]) * dtSdx;
  }
  old_E = E + (flux_E-flux_E[nextCell]) * dtSdx;
  //printf(", vnew_=%12.12f, flux_v[nextCell]=%12.12f\n", old_v, flux_v[nextCell]);
}
void update(void) @ 8.0{
  if (isX())
    updateXYZ(MD_DirX);
  else
    updateXYZ(MD_DirY);
}
void eieio_update(void) @ 8.01 {
  eieio();
}



// ****************************************************************************
// * recompute_Œ¥t & test for quit @ [10.0,+‚àû[ 
// ****************************************************************************
void recompute_Œ¥t(void) @ 10.0{
  if ((GlobalIteration%4) || (GlobalIteration==1)) return;
  Œ¥t=compute_Œ¥t();
  dt_dx=Œ¥t/dx;
  info() << "[7m[recompute_Œ¥t] Œ¥t="<<Œ¥t<<", dt/dx="<<dt_dx<<"[m";
}
void isItTimeToQuit(void) @ 11.0{
  if (GlobalIteration >= (nstepmax<<1)) exit;
  if (time < tend) return;
  info() << "[7m[isItTimeToQuit] time="<<time<<", tend="<<tend<<"[m";
  info() << "[7m[isItTimeToQuit] exit: GlobalIteration="<<GlobalIteration<<", nstepmax<<1="<<(nstepmax<<1)<<"[m";
  exit;
}







// ****************************************************************************
// * Other tools
// ****************************************************************************

int isX(void){
  return ((((GlobalIteration-1)%4)==0) || ((GlobalIteration-1)%4)==3);
}


void eieio(void){
  synchronize(old_œÅ);
  synchronize(old_u); // Normal momentum
  synchronize(old_v); // Transverse momentum
  synchronize(old_E);
}


// ****************************************************************************
// * Dump old_*
// ****************************************************************************
cells void dump_old_œÅ(void){
  if (lid==0) printf("\n[dump] old_ID");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", old_œÅ);
}
cells void dump_old_u(void){
  if (lid==0) printf("\n[dump] old_IU");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", old_u);
}
cells void dump_old_v(void){
  if (lid==0) printf("\n[dump] old_IV");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", old_v);
}
cells void dump_old_E(void){
  if (lid==0) printf("\n[dump] old_IP");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", old_E);
}
void dump_old_œÅuvE(void){
  dump_old_œÅ();
  dump_old_u();
  dump_old_v();
  dump_old_E();
}


// ****************************************************************************
// * Dump œÅ,u,v,E
// ****************************************************************************
cells void dump_œÅ(void){
  if (lid==0) printf("\n[dump] ID");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", œÅ);
}
cells void dump_info_œÅ(void){
  info()<< "[dump_info_œÅ] #"<<uid<<" œÅ="<<œÅ;
}
cells void dump_u(void){
  if (lid==0) printf("\n[dump] IU");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", u);
}
cells void dump_info_u(void){
  info()<< "[dump_info_œÅ] #"<<uid<<" u="<<u;
}
cells void dump_v(void){
  if (lid==0) printf("\n[dump] IV");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", v);
}
cells void dump_info_v(void){
  info()<< "[dump_info_œÅ] #"<<uid<<" v="<<v;
}
cells void dump_E(void){
  if (lid==0) printf("\n[dump] IP");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", E);
}
cells void dump_info_E(void){
  info()<< "[dump_info_œÅ] #"<<uid<<" E="<<E;
}
void dump_œÅuvE(void){
  dump_œÅ();
  dump_u();
  dump_v();
  dump_E();
}
void dump_info_œÅuvE(void){
  dump_info_œÅ();
  dump_info_u();
  dump_info_v();
  dump_info_E();
}


// ****************************************************************************
// * Dump primitives
// ****************************************************************************
cells void dump_prim_œÅ(void){
  if (lid==0) printf("\n[dump] prim_ID");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", prim_œÅ);
}
cells void dump_prim_u(void){
  if (lid==0) printf("\n[dump] prim_IU");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", prim_u);
}
cells void dump_prim_v(void){
  if (lid==0) printf("\n[dump] prim_IV");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", prim_v);
}
cells void dump_prim_E(void){
  if (lid==0) printf("\n[dump] prim_IP");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", E_internal);
}
cells void dump_prim_p(void){
  if (lid==0) printf("\n[dump] prim_p");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", prim_p);
}
cells void dump_prim_c(void){
  if (lid==0) printf("\n[dump] prim_c");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", prim_c);
}
cells void dump_info_prim_œÅ(void){
  info()<< "[dump_info_prim_œÅ] #"<<uid<<" prim_œÅ="<<prim_œÅ;
}
cells void dump_info_prim_u(void){
  info()<< "[dump_info_prim_u] #"<<uid<<" prim_u="<<prim_u;
}
cells void dump_info_prim_v(void){
  info()<< "[dump_info_prim_v] #"<<uid<<" prim_v="<<prim_v;
}
cells void dump_info_prim_E(void){
  info()<< "[dump_info_prim_E] #"<<uid<<" prim_E="<<E_internal;
}
cells void dump_info_prim_p(void){
  info()<< "[dump_info_prim_p] #"<<uid<<" prim_p="<<prim_p;
}
cells void dump_info_prim_c(void){
  info()<< "[dump_info_prim_c] #"<<uid<<" prim_c="<<prim_c;
}
void dump_info_prim_œÅuvEpc(void){
  dump_info_prim_œÅ();
  dump_info_prim_u();
  dump_info_prim_v();
  dump_info_prim_E();
  dump_info_prim_p();
  dump_info_prim_c();
}


// ****************************************************************************
// * Dump slopes
// ****************************************************************************
cells void dump_dœÅ(void){
  if (lid==0) printf("\n[dump] slope_œÅ");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", slope_œÅ);
}
cells void dump_du(void){
  if (lid==0) printf("\n[dump] slope_u");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", slope_u);
}
cells void dump_dv(void){
  if (lid==0) printf("\n[dump] slope_v");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", slope_v);
}
cells void dump_dp(void){
  if (lid==0) printf("\n[dump] slope_p");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", slope_p);
}
void dump_slopes(void){
  dump_dœÅ();
  dump_du();
  dump_dv();
  dump_dp();
}



// ****************************************************************************
// * Dump flux
// ****************************************************************************
cells void dump_flux_œÅ_left(void){
  if (lid==0) printf("\n[dump] flux_œÅ_left");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", flux_œÅ_left);
}
cells void dump_flux_u_left(void){
  if (lid==0) printf("\n[dump] flux_u_left");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", flux_u_left);
}
cells void dump_flux_v_left(void){
  if (lid==0) printf("\n[dump] flux_v_left");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", flux_v_left);
}
cells void dump_flux_p_left(void){
  if (lid==0) printf("\n[dump] flux_p_left");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", flux_p_left);
}

cells void dump_flux_œÅ_right(void){
  if (lid==0) printf("\n[dump] flux_œÅ_right");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", flux_œÅ_right);
}
cells void dump_flux_u_right(void){
  if (lid==0) printf("\n[dump] flux_u_right");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", flux_u_right);
}
cells void dump_flux_v_right(void){
  if (lid==0) printf("\n[dump] flux_v_right");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", flux_v_right);
}
cells void dump_flux_p_right(void){
  if (lid==0) printf("\n[dump] flux_p_right");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", flux_p_right);
}
void dump_flux(void){
  dump_flux_œÅ_left();
  dump_flux_u_left();
  dump_flux_v_left();
  dump_flux_p_left();
  
  dump_flux_œÅ_right();
  dump_flux_u_right();
  dump_flux_v_right();
  dump_flux_p_right();
}


// ****************************************************************************
// * Dump left/right flux
// ****************************************************************************
cells void dump_qflux_œÅ_left(void){
  if (lid==0) printf("\n[dump] [33mq_œÅ_left[m");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", q_œÅ_left);
}
cells void dump_qflux_u_left(void){
  if (lid==0) printf("\n[dump] [33mq_u_left[m");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", q_u_left);
}
cells void dump_qflux_v_left(void){
  if (lid==0) printf("\n[dump] [33mq_v_left[m");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", q_v_left);
}
cells void dump_qflux_p_left(void){
  if (lid==0) printf("\n[dump] [33mq_p_left[m");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", q_p_left);
}
cells void dump_qflux_œÅ_right(void){
  if (lid==0) printf("\n\n[dump] [36mq_œÅ_right[m");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", q_œÅ_right);
}
cells void dump_qflux_u_right(void){
  if (lid==0) printf("\n[dump] [36mq_u_right[m");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", q_u_right);
}
cells void dump_qflux_v_right(void){
  if (lid==0) printf("\n[dump] [36mq_v_right[m");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", q_v_right);
}
cells void dump_qflux_p_right(void){
  if (lid==0) printf("\n[dump] [36mq_p_right[m");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", q_p_right);
}
void dump_qleftright(void){
  dump_qflux_œÅ_left();
  dump_qflux_u_left();
  dump_qflux_v_left();
  dump_qflux_p_left();
  dump_qflux_œÅ_right();
  dump_qflux_u_right();
  dump_qflux_v_right();
  dump_qflux_p_right();
}


// ****************************************************************************
// * Dump Riemann solutions
// ****************************************************************************
cells void dump_gdnv_œÅ(void){
  if (lid==0) printf("\n[dump] gdnv_œÅ");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", gdnv_œÅ);
}
cells void dump_gdnv_u(void){
  if (lid==0) printf("\n[dump] gdnv_u");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", gdnv_u);
}
cells void dump_gdnv_v(void){
  if (lid==0) printf("\n[dump] gdnv_v");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", gdnv_v);
}
cells void dump_gdnv_p(void){
  if (lid==0) printf("\n[dump] gdnv_p");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", gdnv_p);
}
void dump_riemann(void){
  dump_gdnv_œÅ();
  dump_gdnv_u();
  dump_gdnv_v();
  dump_gdnv_p();
}


// ****************************************************************************
// * Dump computed fluxes from solution
// ****************************************************************************
cells void dump_flux_œÅ(void){
  if (lid==0) printf("\n[dump] flux_œÅ");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", flux_œÅ);
}
cells void dump_flux_u(void){
  if (lid==0) printf("\n[dump] flux_u");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", flux_u);
}
cells void dump_flux_v(void){
  if (lid==0) printf("\n[dump] flux_v");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", flux_v);
}
cells void dump_flux_E(void){ 
  if (lid==0) printf("\n[dump] flux_E");
  if ((lid%4)==0) printf("\n\t");
  printf("%12.12f ", flux_E);
}
void dump_cmpflx(void){
  dump_flux_œÅ();
  dump_flux_u();
  dump_flux_v();
  dump_flux_E();
}
