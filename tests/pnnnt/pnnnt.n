///////////////////////////////////////////////////////////////////////////////
// This NABLA port is an implementation of the PENNANT Mini-App              //
// from Charles R. Ferenbaugh (cferenba@lanl.gov), LANL                      //
// ‚àá contributor(s): CAMIER Jean-Sylvain - Jean-Sylvain.Camier@cea.fr        //
///////////////////////////////////////////////////////////////////////////////
// PENNANT is an unstructured mesh physics mini-app designed for advanced    //
// architecture research. It contains mesh data structures and a few physics //
// algorithms adapted from the LANL rad-hydro code FLAG, and gives a sample  //
// of the typical memory access patterns of FLAG.                            //
///////////////////////////////////////////////////////////////////////////////
// Copyright 2012, Los Alamos National Security, LLC. All rights reserved.   //
// This software was produced under US Government contract DE-AC52-06NA25396 //
// for Los Alamos National Laboratory, which is operated by Los Alamos       //
// National Security, LLC for the U.S. Department of Energy.                 //
// The US Government has rights to use, reproduce and distribute this        //
// software.                                                                 //
// NEITHER THE GOVERNMENT NOR LOS ALAMOS NATIONAL SECURITY, LLC MAKES ANY    //
// WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY LIABILITY FOR THE USE OF     //
// THIS SOFTWARE.                                                            //
// If this software is modified to produce derivative works, such modified   //
// software should be clearly marked, so as not to confuse it with the       //
// version available from LANL.                                              //
// Additionally, redistribution and use in source and binary forms, with or  //
// without modification, are permitted provided that the following           //
// conditions are met:                                                       //
//  1. Redistributions of source code must retain the above copyright notice,//
//     this list of conditions and the following disclaimer.                 //
//  2. Redistributions in binary form must reproduce the above copyright     //
//     notice, this list of conditions and the following disclaimer in the   //
//     documentation and/or other materials provided with the distribution.  //
//  3. Neither the name of Los Alamos National Security, LLC, Los Alamos     //
//     National Laboratory, LANL, the U.S. Government, nor the names of its  //
//     contributors may be used to endorse or promote products derived from  //
//     this software without specific prior written permission.              //
///////////////////////////////////////////////////////////////////////////////
// THIS SOFTWARE IS PROVIDED BY LOS ALAMOS NATIONAL SECURITY, LLC AND        //
// CONTRIBUTORS ‚ÄúAS IS‚Äù AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,    //
// BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS //
// FOR A PARTICULAR PURPOSE ARE DISCLAIMED.                                  //
// IN NO EVENT SHALL LOS ALAMOS NATIONAL SECURITY, LLC OR CONTRIBUTORS BE    //
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR       //
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF      //
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  //
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN   //
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)   //
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF    //
// THE POSSIBILITY OF SUCH DAMAGE.                                           //
///////////////////////////////////////////////////////////////////////////////
// End cycle 48, time = 1.00000000000000e+00, dt = 7.22554862846492e-03
with ‚Ñù¬≤;

// ****************************************************************************
// Default options should match test/sedovsmall/sedovsmall.pnt
// cstop=100, tstop=1.0, meshtype=rect, meshparams=3 3 1.125 1.125
// subregion=0.0 0.3 0.0 0.3, rinitsub=1.0, einitsub=40.222, bcx=0.0 1.125
// bcy=0.0 1.125, ssmin=0.1, q1=0.1, q2=1.0, dtinit=0.0025
// ****************************************************************************
options{
  // Mesh options
  ‚Ñù LENGTH       = 1.125;
  ‚Ñï X_EDGE_ELEMS = 3;
  ‚Ñï Y_EDGE_ELEMS = 3;
  ‚Ñï Z_EDGE_ELEMS = 1;
  ‚Ñï option_max_iterations = 0;// ! utilis√© en dur dans le backend lambda !
  ‚Ñù option_Œ¥t_initial = 1e-7; // ! utilis√© en dur dans le backend lambda !
  ‚Ñù option_stoptime = 1.0;    // ! utilis√© en dur dans le backend lambda !
  // Pennant options
  ‚Ñæ trace       = false;
  ‚Ñï cstop       = 64;     // simulation stop cycle
  ‚Ñù tstop       = 1.0;    // simulation stop time
  ‚Ñù dtmax       = 1.e99;  // maximum timestep size
  ‚Ñù dtinit      = 0.0025; // initial timestep size
  ‚Ñù dtfac       = 1.2;    // factor limiting timestep growth
  ‚Ñï dtreport    = 10;     // frequency for timestep reports
  ‚Ñù cfl         = 0.6;    // Courant number, limits timestep
  ‚Ñù cflv        = 0.1;    // volume change limit for timestep
  ‚Ñù rinit       = 1.0;    // initial density for main mesh
  ‚Ñù einit       = 0.0;    // initial energy for main mesh
  ‚Ñæ impacts     = false;
  ‚Ñæ subregion   = true;
  ‚Ñù sbxmin      = 0.0;
  ‚Ñù sbxmax      = 0.3;
  ‚Ñù sbymin      = 0.0;
  ‚Ñù sbymax      = 0.3;
  ‚Ñù rinitsub    = 1.0;    // initial density in subregion
  ‚Ñù einitsub    = 40.222; // initial energy in subregion
  ‚Ñù uinitradial = 0.0;    // initial velocity in radial direction
  ‚Ñù Œ≥           = 1.6666666666666667;//5./3.;  // coeff. for ideal gas equation
  ‚Ñù ssmin       = 0.1;    // minimum sound speed for gas
  ‚Ñù alpha       = 0.5;    // alpha coefficient for TTS model
  ‚Ñù q1          = 0.1;    // linear coefficients for Q model
  ‚Ñù q2          = 1.0;    // quadratic coefficients for Q model
  ‚Ñù Œµ           = 1.e-12;
  ‚Ñù Œπ           = 1.e-99;
};


// ****************************************************************************
// * Zone/Sides/Corners Variables
// ****************************************************************************
cells{
  ‚Ñù¬≤ zx;    // zone center coordinates
  ‚Ñù¬≤ zxp;   // zone ctr coords, middle of cycle
  ‚Ñù zarea;  // zone area
  ‚Ñù zvol;   // zone volume
  ‚Ñù zareap; // zone area, middle of cycle
  ‚Ñù zvolp;  // zone volume, middle of cycle
  ‚Ñù zvol0;  // zone volume, start of cycle
  ‚Ñù zdl;    // zone characteristic length
  ‚Ñù zm;     // zone mass
  ‚Ñù zr;     // zone density
  ‚Ñù zrp;    // zone density, middle of cycle
  ‚Ñù ze;     // zone specific internal energy (energy per unit mass)
  ‚Ñù zetot;  // zone total internal energy
  ‚Ñù zw;     // zone work done in cycle
  ‚Ñù zwrate; // zone work rate
  ‚Ñù zp;     // zone pressure
  ‚Ñù zss;    // zone sound speed
  ‚Ñù zdu;    // zone velocity difference
  ‚Ñù z0per;  // zone tmp variable in PolyGas calcStateAtHalf
  ‚Ñù¬≤ z0uc;  // zone tmp centered velocity
  // Sides
  ‚Ñù sarea[faces];  // area
  ‚Ñù svol[faces];   // volume
  ‚Ñù sareap[faces]; // area, middle of cycle
  ‚Ñù svolp[faces];  // volume, middle of cycle
  ‚Ñù¬≤ ssurfp[faces];// surface vector
  ‚Ñù smf[faces];    // mass fraction
  ‚Ñù¬≤ sfp[faces];   // force from pressure
  ‚Ñù¬≤ sfq[faces];   // force from artificial visc.
  ‚Ñù¬≤ sft[faces];   // force from tts
  // Corners
  ‚Ñù¬≤ cftot[nodes]; // force, total from all sources
  ‚Ñù cmaswt[nodes]; // contribution to pmaswt
  ‚Ñù carea[nodes]; // tmp
  ‚Ñù cevol[nodes]; // tmp
  ‚Ñù cdu[nodes];   // tmp
  ‚Ñù cdiv[nodes];  // tmp
  ‚Ñù ccos[nodes];  // tmp
  ‚Ñù¬≤ cqe0[nodes]; // tmp
  ‚Ñù¬≤ cqe1[nodes]; // tmp
  ‚Ñù cw[nodes];    // tmp
  ‚Ñù crmu[nodes];  // tmp
  // Utilis√© par legion
  ‚Ñï znump;
};

// ****************************************************************************
// * Point Variables
// ****************************************************************************
nodes{
  ‚Ñù¬≤ px,px0,pxp; // point coordinates, start & middle of cycle
  ‚Ñù¬≤ pu,pu0;     // point velocity
  ‚Ñù¬≤ pap,pf;     // point acceleration, force
  ‚Ñù pmaswt;      // point mass, weighted by 1/r
  ‚Ñæ has_bcx;     // Utilis√© par legion
  ‚Ñæ has_bcy;     // Utilis√© par legion
};

// ****************************************************************************
// * Edge Variables
// ****************************************************************************
faces{
  ‚Ñù¬≤ ex,exp; // edge center coordinates & middle of cycle
  ‚Ñù elen;    // edge length
};

// ****************************************************************************
// * Global Variables
// ****************************************************************************
global{
  ‚Ñï cycle;  // simulation cycle number
  ‚Ñù dt;     // current timestep
  ‚Ñù dtrec;  // maximum timestep for hydro
  ‚Ñù dvovmax;//
};

// ****************************************************************************
// * Initialization ]-‚àû,-0.0[
// ****************************************************************************

‚àÄ nodes iniMeshPx @ -33 { px = coord; }

‚àÄ cells iniMeshZx @ -32 { zx=0; ‚àÄ nodes zx+=px; zx/=#nodes; }
‚àÄ faces iniMeshEx @ -32 { ex=0; ‚àÄ nodes ex+=px; ex/=#nodes; }

‚àÄ cells iniMeshCalcVols @ -31.8 {
  zvol=0;
  zarea=0; 
  ‚àÄ nodes{
    sarea = ¬Ω * cross2D(px[#+1]-px,zx-px);
    svol = ‚Öì* sarea * (px.x+px[#+1].x+zx.x);
    zarea += sarea;
    zvol  += svol;
  }
}

‚àÄ cells iniMeshCalcSideFracs @ -31.7 { ‚àÄ faces smf = sarea/zarea; }

iniGlobals @ -20.0 { time=0; cycle=0; }
iniTestCase @ -20 {
  if (!impacts) return;
  subregion=false;
  cfl=0.15;
}

‚àÄ cells iniZr @ -14.9 { zr=rinit; }
‚àÄ cells iniZe @ -14.9 { ze=einit; }
‚àÄ cells iniZwrate @ -14.9 { zwrate=0; }

‚àÄ cells iniImpacts @ -14.8 if (impacts) {
  const int n=NABLA_NB_CELLS;
  const int l=‚àö(n);
  const int center=n/2+l/2;
  const int k0=n/4+l/3;
  const int k1=3*n/4+l/4;
  if (uid==center || uid==k0 || uid==k1){
    cout<<"\n[35m[iniImpacts]"<<uid<<"[m";
    zr = rinitsub;
    ze = einitsub;
  }
}
‚àÄ cells iniSubRegion @ -14.8 if (subregion) {
  if (!(zx.x > (sbxmin-Œµ) && zx.x < (sbxmax+Œµ) &&
        zx.y > (sbymin-Œµ) && zx.y < (sbymax+Œµ))) continue;
  zr = rinitsub;
  ze = einitsub;
}

‚àÄ cells iniZm @ -14.7 { zm=zr*zvol; }
‚àÄ cells iniZetot @ -14.6 { zetot=ze*zm; }

// Legion not vs != for the if statement
//‚àÄ nodes niPuRadial @ -14.5 if (uinitradial != 0.0) {
//  const ‚Ñù pmag = length(px);
//  pu=(pmag>Œµ)?uinitradial*px/pmag:0;
//}
‚àÄ nodes iniPuStd @ -14.5 if (uinitradial==0.0) { pu=0.0; }

iniRstDtHydro @ -14.4 { dtrec = +‚àû; }


// ****************************************************************************
// * Compute loop ‚äÇ ]+0.0,+‚àû[ 
// ****************************************************************************

incCycle @ 1.0 { cycle += 1; }

calcGlobalDt @ 2.0 {
  const ‚Ñù dtlast = dt;
  dt = dtmax;
  if (cycle == 1) {
    dt=(dtinit<dt)?dtinit;
  } else {
    const ‚Ñù dtrecover = dtfac * dtlast;
    if (dtrecover<dt) dt = dtrecover;
  }
  dt=((tstop-time)<dt)?tstop-time;
  dt=(dtrec<dt)?dtrec;
}


‚àÄ nodes savePx @ 3.0 { px0=px; }
‚àÄ nodes savePu @ 3.0 { pu0=pu; }
‚àÄ cells saveZvol @ 3.0 { zvol0=zvol; }

‚àÄ nodes advPosHalf0 @ 3.1 { pxp = px0+¬Ω*pu0*dt; }

‚àÄ cells calcZxp @ 3.2 { zxp=0; ‚àÄ nodes zxp+=pxp; zxp/=#nodes; }
‚àÄ faces calcExp @ 3.2 { exp=0; ‚àÄ nodes exp+=pxp; exp/=#nodes; }

‚àÄ cells calcVols @ 3.4 {
  zareap=0; 
  zvolp=0;
  ‚àÄ nodes {
    sareap = ¬Ω*cross2D(pxp[#+1]-pxp,zxp-pxp);
    svolp = ‚Öì*sareap*(pxp.x+pxp[#+1].x+zxp.x);
    zareap+=sareap;
    zvolp +=svolp;
  } 
}

‚àÄ cells calcSurfVecs @ 3.5 { ‚àÄ faces ssurfp = rotateCCW(exp-zxp); }
‚àÄ faces calcEdgeLen @ 3.5 { elen = length(pxp[1]-pxp[0]); }

‚àÄ cells calcCharLen @ 3.6 { zdl = 1.e99; ‚àÄ faces zdl=fmin(zdl,4.0*sareap/elen); }

‚àÄ cells calcZrp @ 4.0 { zrp = zm/zvolp; }

‚àÄ cells calcCrnrMass @ 4.1 { ‚àÄ nodes cmaswt = ¬Ω*zrp*zareap*(smf+smf[#-1]); }

‚àÄ cells calcEOS1 @ 5.0 {
  const ‚Ñù Œ≥m1 = Œ≥ - 1.0;
  const ‚Ñù ss2 = fmax(ssmin*ssmin,1.e-99);
  const ‚Ñù rx = zr;
  const ‚Ñù local_ex = fmax(ze,0.0);
  const ‚Ñù local_px = Œ≥m1*rx*local_ex;
  const ‚Ñù prex = Œ≥m1*local_ex;
  const ‚Ñù perx = Œ≥m1*rx;
  const ‚Ñù csqd = fmax(ss2, prex+perx*local_px/(rx*rx));
  zp =local_px;
  z0per = perx;
  zss = ‚àö(csqd);
}

‚àÄ cells calcEOS2 @ 5.1 {
  const ‚Ñù dth = ¬Ω * dt;
  const ‚Ñù zminv = 1.0 / zm;
  const ‚Ñù dv = (zvolp - zvol0) * zminv;
  const ‚Ñù bulk = zr * zss * zss;
  const ‚Ñù denom = 1.0 + ¬Ω * z0per * dv;
  const ‚Ñù src = zwrate * dth * zminv;
  zp += (z0per * src - zr * bulk * dv) / denom;
}

‚àÄ cells pgasCalcForce @ 6.0 { ‚àÄ faces sfp=-zp * ssurfp; }

‚àÄ cells ttsCalcForce @ 6.1 {
  ‚àÄ faces {
    const ‚Ñù svfacinv = zareap / sareap;
    const ‚Ñù srho = zrp * smf * svfacinv;
    ‚Ñù sstmp = fmax(zss, ssmin);
    sstmp = alpha * sstmp * sstmp;
    const ‚Ñù sdp = sstmp * (srho - zrp);
    const ‚Ñù¬≥ sqq = -sdp * ssurfp;
    sft = sqq;
  }
}

‚àÄ cells qcsZuc @ 6.2 { z0uc=0; ‚àÄ nodes z0uc += pu; z0uc/=#nodes; }

‚àÄ cells qcsCornerDiv @ 6.3 {
  ‚àÄ nodes {
    const ‚Ñù¬≥ up0 = pu;
    const ‚Ñù¬≥ xp0 = pxp;
    const ‚Ñù¬≥ up1 = ¬Ω * (pu + pu[#+1]);
    const ‚Ñù¬≥ xp1 = exp;
    const ‚Ñù¬≥ up2 = z0uc;
    const ‚Ñù¬≥ xp2 = zxp;
    const ‚Ñù¬≥ up3 = ¬Ω * (pu[#-1] + pu);
    const ‚Ñù¬≥ xp3 = exp[#-1];
    const ‚Ñù cvolume = ¬Ω * cross2D(xp2-xp0, xp3-xp1);
    carea = cvolume;
    const ‚Ñù¬≥ v1 = xp3-xp0;
    const ‚Ñù¬≥ v2 = xp1-xp0;
    const ‚Ñù de1 = elen[#-1];
    const ‚Ñù de2 = elen[#];
    ‚Ñù minelen = fmin(de1, de2);
    ccos = ((minelen<Œµ)?0.0:4.0*dot2D(v1,v2)/(de1*de2));
    cdiv = (cross2D(up2-up0, xp3-xp1)-cross2D(up3-up1, xp2-xp0))/(2.0*cvolume);
    const ‚Ñù¬≥ dxx1 = ¬Ω * (xp1+xp2-xp0-xp3);
    const ‚Ñù¬≥ dxx2 = ¬Ω * (xp2+xp3-xp0-xp1);
    const ‚Ñù dx1 = length(dxx1);
    const ‚Ñù dx2 = length(dxx2);
    const ‚Ñù¬≥ duav = ¬º*(up0+up1+up2+up3);
    const ‚Ñù test1 = fabs(dot2D(dxx1,duav)*dx2);
    const ‚Ñù test2 = fabs(dot2D(dxx2,duav)*dx1);
    const ‚Ñù num = (test1>test2?dx1:dx2);
    const ‚Ñù den = (test1>test2?dx2:dx1);
    const ‚Ñù r = num / den;
    const ‚Ñù evol = fmin(sqrt(4.0*cvolume*r),2.0*minelen);
    const ‚Ñù dv1 = length2(up1+up2-up0-up3);
    const ‚Ñù dv2 = length2(up2+up3-up0-up1);
    const ‚Ñù du = sqrt(fmax(dv1, dv2));
    cevol = (cdiv < 0.0 ? evol : 0.);
    cdu   = (cdiv < 0.0 ? du   : 0.);
  }
}

‚àÄ cells qcsCrmu @ 6.4 { // Kurapatenko viscous scalar
  const ‚Ñù Œ≥p1 = Œ≥ + 1.0;
  ‚àÄ nodes {
    const ‚Ñù ztmp2 = ¬º*q2*Œ≥p1*cdu;
    const ‚Ñù ztmp1 = q1 * zss;
    const ‚Ñù zkur = ztmp2 + ‚àö(ztmp2¬≤ + ztmp1¬≤);
    const ‚Ñù rmu = zkur * zrp * cevol;
    crmu = (cdiv>0.0)?0.0:rmu;
  }
}

‚àÄ cells qcsC0qe @ 6.5 {
  ‚àÄ nodes {
    cqe0 = crmu * (pu-pu[#-1])/elen[#-1];
    cqe1 = crmu * (pu[#+1]-pu)/elen;
  }
}

‚àÄ cells qcsExtraVars @ 6.6 {
  ‚àÄ nodes {
    const ‚Ñù csin2 = 1.0-ccos¬≤;
    cw   = ((csin2 < 1.e-4) ? 0.0:carea/csin2);
    ccos = ((csin2 < 1.e-4) ? 0.0:ccos);
  }
}

‚àÄ cells qcsForcesCorners @ 6.7 {
  ‚àÄ faces sfq = (cw*(cqe1+ccos*cqe0)+
                 cw[#+1]*(cqe0[#+1]+ccos[#+1]*cqe1[#+1]))/elen;
}

‚àÄ cells qcsSetVelDiff @ 6.8 {
  ‚Ñù z0tmp=0;
   ‚àÄ nodes {
    const ‚Ñù¬≥ dx = pxp[#+1]-pxp;
    const ‚Ñù¬≥ du = pu[#+1]-pu;
    const ‚Ñù lenx = elen;
    const ‚Ñù dux = (lenx > 0.0)?fabs(dot2D(du,dx))/lenx:0.0;
    z0tmp = fmax(z0tmp, dux);
  }
  zdu = q1 * zss + 2.0 * q2 * z0tmp;
}

‚àÄ cells sumCrnrForce @ 7.0 { ‚àÄ nodes cftot=(sfp+sfq+sft)-(sfp[#-1]+sfq[#-1]+sft[#-1]); }

‚àÄ nodes sumCrnrMasses @ 8.0 { pmaswt=0; ‚àÄ cells pmaswt+=cmaswt; }

‚àÄ nodes sumCrnrForces @ 8.1 { pf=0; ‚àÄ cells pf+=cftot; }
 
‚àÄ /*outer*/ nodes applyFixedBC_X @ 9.0 {
  if (px.x!=0.0 && px.x!=LENGTH) continue;
  const ‚Ñù¬≥ vfixx = ‚Ñù¬≥(1,0,0);
  pu = project(pu, vfixx);
  pf = project(pf, vfixx);
}
‚àÄ /*outer*/ nodes applyFixedBC_Y @ 9.1 {
  if (px.y!=0.0 && px.y!=LENGTH) continue;
  const ‚Ñù¬≥ vfixy = ‚Ñù¬≥(0,1,0);
  pu = project(pu, vfixy);
  pf = project(pf, vfixy);
} 

‚àÄ nodes calcAccel @ 10.0 { pap = pf/fmax(pmaswt,Œπ); }

‚àÄ nodes advPosFullPu @ 11.0 { pu = pu0 + pap*dt; }
‚àÄ nodes advPosFullPx @ 11.1 { px = px0 + ¬Ω*(pu+pu0)*dt; }

‚àÄ cells updateZx @ 13.0 { zx=0; ‚àÄ nodes zx+=px; zx/=#nodes; }
‚àÄ faces updateEx @ 13.0 { ex=0; ‚àÄ nodes ex+=px; ex/=#nodes; }
‚àÄ cells updateVols @ 13.2 { 
  zvol=zarea=0; 
  ‚àÄ nodes {
    sarea = ¬Ω * cross2D(px[#+1]-px,zx-px);
    svol = ‚Öì* sarea * (px.x+px[#+1].x+zx.x);
    zarea += sarea;
    zvol  += svol;
  }
}

‚àÄ cells calcWork @ 14.0 {
  zw=0; 
  const ‚Ñù dth = ¬Ω * dt;
  ‚àÄ nodes { 
    const ‚Ñù¬≥ sftot = sfp + sfq;
    const ‚Ñù sd1 = dot2D( sftot, (pu0+pu));
    const ‚Ñù sd2 = dot2D(-sftot, (pu0[#+1]+pu[#+1]));
    const ‚Ñù dwork = -dth*(sd1*pxp.x+sd2*pxp[#+1].x);
    zetot += dwork;
    zw += dwork;
  }
}

‚àÄ cells calcWorkRate @ 15.0 { 
  const ‚Ñù dvol=zvol-zvol0;
  zwrate = (zw+zp*dvol)/dt;
}

‚àÄ cells calcEnergy @ 16.0 { ze = zetot/(zm+Œπ); }
‚àÄ cells calcRho @ 16.0 { zr = zm / zvol; }


resetDtHydro @ 12.0 { dtrec=dtmax; dvovmax=Œπ;}

‚àÄ cells calcDtCourant @ 19.0 {
  const ‚Ñù du = fmax(zdu, fmax(zss,Œπ));
  const ‚Ñù zdthyd = zdl * cfl / du;
  const ‚Ñù dtnew = (zdthyd < dtmax)?zdthyd:dtmax;
  if (dtnew < dtrec) dtrec = dtnew;
}

‚àÄ cells calcDtVolume @ 20.0 {
  const ‚Ñù zdvov = fabs((zvol-zvol0)/zvol0);
  dvovmax = (zdvov>dvovmax)?zdvov;
}

calcDtVolumeTst @ 20.1 {
  const ‚Ñù dtnew = dt * cflv / dvovmax;
  if (dtnew < dtrec) dtrec = dtnew;
}

incTime @ 30.0 {
  time += dt;
  cout<<"End cycle "<<cycle
      <<", time = "<<time<<", dt = "<<dt<<endl;
}

tstExit @ 40.0 {
  if (cycle < cstop && time < tstop) return;
  if (X_EDGE_ELEMS==3 && Y_EDGE_ELEMS==3 && Z_EDGE_ELEMS==1) assert(iteration==48);
  //exit;
}


// ****************************************************************************
// * Mathematical functions
// ****************************************************************************
‚Ñù length(const ‚Ñù¬≤ v){ return sqrt(v.x*v.x + v.y*v.y); }
‚Ñù length2(const ‚Ñù¬≤ v){ return(v.x*v.x + v.y*v.y); }
‚Ñù dot2D(const ‚Ñù¬≤ v1, const ‚Ñù¬≤ v2){ return(v1.x*v2.x + v1.y*v2.y); }
‚Ñù¬≤ rotateCCW(const ‚Ñù¬≤ v){ return ‚Ñù¬≤(-v.y, v.x,0); }
‚Ñù cross2D(const ‚Ñù¬≤ v1, const ‚Ñù¬≤ v2){ return (v1.x*v2.y - v1.y*v2.x); }
‚Ñù¬≤ project(‚Ñù¬≤ v, const ‚Ñù¬≤ u){ return v-dot(v,u)*u; }
